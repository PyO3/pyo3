<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PyO3 user guide</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="PyO3 user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="module.html"><strong aria-hidden="true">1.</strong> Python Modules</a></li><li class="chapter-item expanded "><a href="function.html"><strong aria-hidden="true">2.</strong> Python Functions</a></li><li class="chapter-item expanded "><a href="class.html"><strong aria-hidden="true">3.</strong> Python Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/protocols.html"><strong aria-hidden="true">3.1.</strong> Class customizations</a></li></ol></li><li class="chapter-item expanded "><a href="conversions.html"><strong aria-hidden="true">4.</strong> Type Conversions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conversions/tables.html"><strong aria-hidden="true">4.1.</strong> Mapping of Rust types to Python types</a></li><li class="chapter-item expanded "><a href="conversions/traits.html"><strong aria-hidden="true">4.2.</strong> Conversion traits</a></li></ol></li><li class="chapter-item expanded "><a href="exception.html"><strong aria-hidden="true">5.</strong> Python Exceptions</a></li><li class="chapter-item expanded "><a href="python_from_rust.html"><strong aria-hidden="true">6.</strong> Calling Python from Rust</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">7.</strong> GIL, mutability and object types</a></li><li class="chapter-item expanded "><a href="parallelism.html"><strong aria-hidden="true">8.</strong> Parallelism</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">9.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">10.</strong> Features Reference</a></li><li class="chapter-item expanded "><a href="advanced.html"><strong aria-hidden="true">11.</strong> Advanced Topics</a></li><li class="chapter-item expanded "><a href="building_and_distribution.html"><strong aria-hidden="true">12.</strong> Building and Distribution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building_and_distribution/multiple_python_versions.html"><strong aria-hidden="true">12.1.</strong> Supporting multiple Python versions</a></li></ol></li><li class="chapter-item expanded "><a href="ecosystem.html"><strong aria-hidden="true">13.</strong> Useful Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecosystem/logging.html"><strong aria-hidden="true">13.1.</strong> Logging</a></li><li class="chapter-item expanded "><a href="ecosystem/async-await.html"><strong aria-hidden="true">13.2.</strong> Async / Await</a></li></ol></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">14.</strong> FAQ &amp; Troubleshooting</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="migration.html">Appendix A: Migration Guide</a></li><li class="chapter-item expanded affix "><a href="rust_cpython.html">Appendix B: PyO3 and rust-cpython</a></li><li class="chapter-item expanded affix "><a href="trait_bounds.html">Appendix C: Trait bounds</a></li><li class="chapter-item expanded affix "><a href="changelog.html">CHANGELOG</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">PyO3 user guide</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-pyo3-user-guide"><a class="header" href="#the-pyo3-user-guide">The PyO3 user guide</a></h1>
<p>Welcome to the PyO3 user guide! This book is a companion to <a href="https://docs.rs/pyo3">PyO3's API docs</a>. It contains examples and documentation to explain all of PyO3's use cases in detail.</p>
<p>Please choose from the chapters on the left to jump to individual topics, or continue below to start with PyO3's README.</p>
<h1 id="pyo3"><a class="header" href="#pyo3">PyO3</a></h1>
<p><a href="https://github.com/PyO3/pyo3/actions"><img src="https://github.com/PyO3/pyo3/workflows/CI/badge.svg" alt="actions status" /></a>
<a href="https://pyo3.rs/dev/bench/"><img src="https://github.com/PyO3/pyo3/actions/workflows/bench.yml/badge.svg" alt="benchmark" /></a>
<a href="https://codecov.io/gh/PyO3/pyo3"><img src="https://codecov.io/gh/PyO3/pyo3/branch/main/graph/badge.svg" alt="codecov" /></a>
<a href="https://crates.io/crates/pyo3"><img src="https://img.shields.io/crates/v/pyo3" alt="crates.io" /></a>
<a href="https://rust-lang.github.io/rfcs/2495-min-rust-version.html"><img src="https://img.shields.io/badge/rustc-1.41+-blue.svg" alt="minimum rustc 1.41" /></a>
<a href="https://gitter.im/PyO3/Lobby"><img src="https://img.shields.io/gitter/room/nwjs/nw.js.svg" alt="dev chat" /></a>
<a href="https://github.com/PyO3/pyo3/blob/main/Contributing.md"><img src="https://img.shields.io/badge/contribute-on%20github-Green" alt="contributing notes" /></a></p>
<p><a href="http://www.rust-lang.org/">Rust</a> bindings for <a href="https://www.python.org/">Python</a>, including tools for creating native Python extension modules. Running and interacting with Python code from a Rust binary is also supported.</p>
<ul>
<li>
<p>User Guide: <a href="https://pyo3.rs">stable</a> | <a href="https://pyo3.rs/main">main</a></p>
</li>
<li>
<p>API Documentation: <a href="https://docs.rs/pyo3/">stable</a> | <a href="https://pyo3.rs/main/doc">main</a></p>
</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>PyO3 supports the following software versions:</p>
<ul>
<li>Python 3.6 and up (CPython and PyPy)</li>
<li>Rust 1.41 and up</li>
</ul>
<p>You can use PyO3 to write a native Python module in Rust, or to embed Python in a Rust binary. The following sections explain each of these in turn.</p>
<h3 id="using-rust-from-python"><a class="header" href="#using-rust-from-python">Using Rust from Python</a></h3>
<p>PyO3 can be used to generate a native Python module. The easiest way to try this out for the first time is to use <a href="https://github.com/PyO3/maturin"><code>maturin</code></a>. <code>maturin</code> is a tool for building and publishing Rust-based Python packages with minimal configuration. The following steps set up some files for an example Python module, install <code>maturin</code>, and then show how build and import the Python module.</p>
<p>First, create a new folder (let's call it <code>string_sum</code>) containing the following two files:</p>
<p><strong><code>Cargo.toml</code></strong></p>
<pre><code class="language-toml">[package]
name = &quot;string-sum&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[lib]
name = &quot;string_sum&quot;
# &quot;cdylib&quot; is necessary to produce a shared library for Python to import from.
#
# Downstream Rust code (including code in `bin/`, `examples/`, and `tests/`) will not be able
# to `use string_sum;` unless the &quot;rlib&quot; or &quot;lib&quot; crate type is also included, e.g.:
# crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]
crate-type = [&quot;cdylib&quot;]

[dependencies.pyo3]
version = &quot;0.14.4&quot;
features = [&quot;extension-module&quot;]
</code></pre>
<p><strong><code>src/lib.rs</code></strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

/// Formats the sum of two numbers as string.
#[pyfunction]
fn sum_as_string(a: usize, b: usize) -&gt; PyResult&lt;String&gt; {
    Ok((a + b).to_string())
}

/// A Python module implemented in Rust. The name of this function must match
/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able to
/// import the module.
#[pymodule]
fn string_sum(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>With those two files in place, now <code>maturin</code> needs to be installed. This can be done using Python's package manager <code>pip</code>. First, load up a new Python <code>virtualenv</code>, and install <code>maturin</code> into it:</p>
<pre><code class="language-bash">$ cd string_sum
$ python -m venv .env
$ source .env/bin/activate
$ pip install maturin
</code></pre>
<p>Now build and execute the module:</p>
<pre><code class="language-bash">$ maturin develop
# lots of progress output as maturin runs the compilation...
$ python
&gt;&gt;&gt; import string_sum
&gt;&gt;&gt; string_sum.sum_as_string(5, 20)
'25'
</code></pre>
<p>As well as with <code>maturin</code>, it is possible to build using <a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a> or <a href="https://pyo3.rs/latest/building_and_distribution.html#manual-builds">manually</a>. Both offer more flexibility than <code>maturin</code> but require further configuration.</p>
<h3 id="using-python-from-rust"><a class="header" href="#using-python-from-rust">Using Python from Rust</a></h3>
<p>To embed Python into a Rust binary, you need to ensure that your Python installation contains a shared library. The following steps demonstrate how to ensure this (for Ubuntu), and then give some example code which runs an embedded Python interpreter.</p>
<p>To install the Python shared library on Ubuntu:</p>
<pre><code class="language-bash">sudo apt install python3-dev
</code></pre>
<p>Start a new project with <code>cargo new</code> and add  <code>pyo3</code> to the <code>Cargo.toml</code> like this:</p>
<pre><code class="language-toml">[dependencies.pyo3]
version = &quot;0.14.4&quot;
features = [&quot;auto-initialize&quot;]
</code></pre>
<p>Example program displaying the value of <code>sys.version</code> and the current user name:</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::IntoPyDict;

fn main() -&gt; PyResult&lt;()&gt; {
    Python::with_gil(|py| {
        let sys = py.import(&quot;sys&quot;)?;
        let version: String = sys.get(&quot;version&quot;)?.extract()?;

        let locals = [(&quot;os&quot;, py.import(&quot;os&quot;)?)].into_py_dict(py);
        let code = &quot;os.getenv('USER') or os.getenv('USERNAME') or 'Unknown'&quot;;
        let user: String = py.eval(code, None, Some(&amp;locals))?.extract()?;

        println!(&quot;Hello {}, I'm Python {}&quot;, user, version);
        Ok(())
    })
}
</code></pre></pre>
<p>The guide has <a href="https://pyo3.rs/latest/python_from_rust.html">a section</a> with lots of examples
about this topic.</p>
<h2 id="tools-and-libraries"><a class="header" href="#tools-and-libraries">Tools and libraries</a></h2>
<ul>
<li><a href="https://github.com/PyO3/maturin">maturin</a> <em>Zero configuration build tool for Rust-made Python extensions</em>.</li>
<li><a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a> <em>Setuptools plugin for Rust support</em>.</li>
<li><a href="https://github.com/PyO3/pyo3-built">pyo3-built</a> <em>Simple macro to expose metadata obtained with the <a href="https://crates.io/crates/built"><code>built</code></a> crate as a <a href="https://docs.rs/pyo3/0.12.0/pyo3/types/struct.PyDict.html"><code>PyDict</code></a></em></li>
<li><a href="https://github.com/PyO3/rust-numpy">rust-numpy</a> <em>Rust binding of NumPy C-API</em></li>
<li><a href="https://github.com/gperinazzo/dict-derive">dict-derive</a> <em>Derive FromPyObject to automatically transform Python dicts into Rust structs</em></li>
<li><a href="https://github.com/vorner/pyo3-log">pyo3-log</a> <em>Bridge from Rust to Python logging</em></li>
<li><a href="https://github.com/davidhewitt/pythonize">pythonize</a> <em>Serde serializer for converting Rust objects to JSON-compatible Python objects</em></li>
<li><a href="https://github.com/awestlake87/pyo3-asyncio">pyo3-asyncio</a> Utilities for working with Python's Asyncio library and async functions</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<ul>
<li><a href="https://github.com/mre/hyperjson">hyperjson</a> <em>A hyper-fast Python module for reading/writing JSON data using Rust's serde-json</em></li>
<li><a href="https://github.com/PyO3/setuptools-rust/tree/main/examples/html-py-ever">html-py-ever</a> <em>Using <a href="https://github.com/servo/html5ever">html5ever</a> through <a href="https://github.com/kuchiki-rs/kuchiki">kuchiki</a> to speed up html parsing and css-selecting.</em></li>
<li><a href="https://github.com/ManifoldFR/point-process-rust/tree/master/pylib">point-process</a> <em>High level API for pointprocesses as a Python library</em></li>
<li><a href="https://github.com/autopilot-rs/autopy">autopy</a> <em>A simple, cross-platform GUI automation library for Python and Rust.</em>
<ul>
<li>Contains an example of building wheels on TravisCI and appveyor using <a href="https://github.com/joerick/cibuildwheel">cibuildwheel</a></li>
</ul>
</li>
<li><a href="https://github.com/ijl/orjson">orjson</a> <em>Fast Python JSON library</em></li>
<li><a href="https://github.com/dronesforwork/inline-python">inline-python</a> <em>Inline Python code directly in your Rust code</em></li>
<li><a href="https://github.com/kngwyu/rogue-gym">Rogue-Gym</a> <em>Customizable rogue-like game for AI experiments</em>
<ul>
<li>Contains an example of building wheels on Azure Pipelines</li>
</ul>
</li>
<li><a href="https://github.com/thedrow/fastuuid/">fastuuid</a> <em>Python bindings to Rust's UUID library</em></li>
<li><a href="https://github.com/wasmerio/wasmer-python">wasmer-python</a> <em>Python library to run WebAssembly binaries</em></li>
<li><a href="https://github.com/cds-astro/mocpy">mocpy</a> <em>Astronomical Python library offering data structures for describing any arbitrary coverage regions on the unit sphere</em></li>
<li><a href="https://github.com/huggingface/tokenizers/tree/master/bindings/python">tokenizers</a> <em>Python bindings to the Hugging Face tokenizers (NLP) written in Rust</em></li>
<li><a href="https://github.com/Project-Dream-Weaver/Pyre">pyre</a> <em>Fast Python HTTP server written in Rust</em></li>
<li><a href="https://github.com/Stranger6667/jsonschema-rs/tree/master/bindings/python">jsonschema-rs</a> <em>Fast JSON Schema validation library</em></li>
<li><a href="https://github.com/Stranger6667/css-inline/tree/master/bindings/python">css-inline</a> <em>CSS inlining for Python implemented in Rust</em></li>
<li><a href="https://github.com/pyca/cryptography/tree/main/src/rust">cryptography</a> <em>Python cryptography library with some functionality in Rust</em></li>
<li><a href="https://github.com/daggy1234/polaroid">polaroid</a> <em>Hyper Fast and safe image manipulation library for Python written in Rust</em></li>
<li><a href="https://github.com/aviramha/ormsgpack">ormsgpack</a> <em>Fast Python msgpack library</em></li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Everyone is welcomed to contribute to PyO3! There are many ways to support the project, such as:</p>
<ul>
<li>help PyO3 users with issues on Github and Gitter</li>
<li>improve documentation</li>
<li>write features and bugfixes</li>
<li>publish blogs and examples of how to use PyO3</li>
</ul>
<p>Our <a href="https://github.com/PyO3/pyo3/blob/main/Contributing.md">contributing notes</a> and <a href="https://github.com/PyO3/pyo3/blob/master/Architecture.md">architecture guide</a> have more resources if you wish to volunteer time for PyO3 and are searching where to start.</p>
<p>If you don't have time to contribute yourself but still wish to support the project's future success, some of our maintainers have Github sponsorship pages:</p>
<ul>
<li><a href="https://github.com/sponsors/davidhewitt">davidhewitt</a></li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>PyO3 is licensed under the <a href="http://opensource.org/licenses/APACHE-2.0">Apache-2.0 license</a>.
Python is licensed under the <a href="https://docs.python.org/2/license.html">Python License</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-modules"><a class="header" href="#python-modules">Python Modules</a></h1>
<p>You can create a module using <code>#[pymodule]</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyfunction]
fn double(x: usize) -&gt; usize {
    x * 2
}

/// This module is implemented in Rust.
#[pymodule]
fn my_extension(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(double, m)?)?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>#[pymodule]</code> procedural macro takes care of exporting the initialization function of your
module to Python.</p>
<p>The module's name defaults to the name of the Rust function. You can override the module name by
using <code>#[pyo3(name = &quot;custom_name&quot;)]</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyfunction]
fn double(x: usize) -&gt; usize {
    x * 2
}

#[pymodule]
#[pyo3(name = &quot;custom_name&quot;)]
fn my_extension(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(double, m)?)?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>The name of the module must match the name of the <code>.so</code> or <code>.pyd</code>
file. Otherwise, you will get an import error in Python with the following message:
<code>ImportError: dynamic module does not define module export function (PyInit_name_of_your_module)</code></p>
<p>To import the module, either:</p>
<ul>
<li>copy the shared library as described in <a href="building_and_distribution.html#manual-builds">Manual builds</a>, or</li>
<li>use a tool, e.g. <code>maturin develop</code> with <a href="https://github.com/PyO3/maturin">maturin</a> or
<code>python setup.py develop</code> with <a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a>.</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>The <a href="https://doc.rust-lang.org/stable/book/ch03-04-comments.html">Rust doc comments</a> of the module
initialization function will be applied automatically as the Python docstring of your module.</p>
<p>For example, building off of the above code, this will print <code>This module is implemented in Rust.</code>:</p>
<pre><code class="language-python">import my_extension

print(my_extension.__doc__)
</code></pre>
<h2 id="organizing-your-module-registration-code"><a class="header" href="#organizing-your-module-registration-code">Organizing your module registration code</a></h2>
<p>For most projects, it's adequate to centralize all your FFI code into a single Rust module.</p>
<p>However, for larger projects, it can be helpful to split your Rust code into several Rust modules to keep your code 
readable. Unfortunately, though, some of the macros like <code>wrap_pyfunction!</code> do not yet work when used on code defined 
in other modules (<a href="https://github.com/PyO3/pyo3/issues/1709">#1709</a>). One way to work around this is to pass 
references to the <code>PyModule</code> so that each module registers its own FFI code. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use pyo3::prelude::*;

#[pymodule]
fn my_extension(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    dirutil::register(py, m)?;
    osutil::register(py, m)?;
    Ok(())
}

// src/dirutil.rs
<span class="boring">mod dirutil {
</span>use pyo3::prelude::*;

pub(crate) fn register(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;SomeClass&gt;()?;
    Ok(())
}

#[pyclass]
struct SomeClass {
    x: usize,
}
<span class="boring">}
</span>
// src/osutil.rs
<span class="boring">mod osutil {
</span>use pyo3::prelude::*;

pub(crate) fn register(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(determine_current_os, m)?)?;
    Ok(())
}

#[pyfunction]
fn determine_current_os() -&gt; String {
    &quot;linux&quot;.to_owned()
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Another workaround for splitting FFI code across multiple modules (<a href="https://github.com/PyO3/pyo3/issues/1709">#1709</a>)
is to add <code>use module::*</code>, like this: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use pyo3::prelude::*;
use osutil::*;

#[pymodule]
fn my_extension(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(determine_current_os, m)?)?;
    Ok(())
}

// src/osutil.rs
<span class="boring">mod osutil {
</span>use pyo3::prelude::*;

#[pyfunction]
pub(crate) fn determine_current_os() -&gt; String {
    &quot;linux&quot;.to_owned()
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="python-submodules"><a class="header" href="#python-submodules">Python submodules</a></h2>
<p>You can create a module hierarchy within a single extension module by using 
<a href="https://docs.rs/pyo3/0.14.4/pyo3/prelude/struct.PyModule.html#method.add_submodule"><code>PyModule.add_submodule()</code></a>.
For example, you could define the modules <code>parent_module</code> and <code>parent_module.child_module</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pymodule]
fn parent_module(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    register_child_module(py, m)?;
    Ok(())
}

fn register_child_module(py: Python, parent_module: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    let child_module = PyModule::new(py, &quot;child_module&quot;)?;
    child_module.add_function(wrap_pyfunction!(func, child_module)?)?;
    parent_module.add_submodule(child_module)?;
    Ok(())
}

#[pyfunction]
fn func() -&gt; String {
    &quot;func&quot;.to_string()
}

<span class="boring">Python::with_gil(|py| {
</span><span class="boring">   use pyo3::wrap_pymodule;
</span><span class="boring">   use pyo3::types::IntoPyDict;
</span><span class="boring">   let parent_module = wrap_pymodule!(parent_module)(py);
</span><span class="boring">   let ctx = [(&quot;parent_module&quot;, parent_module)].into_py_dict(py);
</span><span class="boring">
</span><span class="boring">   py.run(&quot;assert parent_module.child_module.func() == 'func'&quot;, None, Some(&amp;ctx)).unwrap();
</span><span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p>Note that this does not define a package, so this wonâ€™t allow Python code to directly import 
submodules by using <code>from parent_module import child_module</code>. For more information, see 
<a href="https://github.com/PyO3/pyo3/issues/759">#759</a> and 
<a href="https://github.com/PyO3/pyo3/issues/1517#issuecomment-808664021">#1517</a>.</p>
<p>It is not necessary to add <code>#[pymodule]</code> on nested modules, which is only required on the top-level module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-functions"><a class="header" href="#python-functions">Python Functions</a></h1>
<p>PyO3 supports two ways to define a free function in Python. Both require registering the function to a <a href="./module.html">module</a>.</p>
<p>One way is annotating a function with <code>#[pyfunction]</code> and then adding it to the module using the <code>wrap_pyfunction!</code> macro.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyfunction]
fn double(x: usize) -&gt; usize {
    x * 2
}

#[pymodule]
fn my_extension(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(double, m)?)?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively, there is a shorthand: the function can be placed inside the module definition and
annotated with <code>#[pyfn]</code>, as below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pymodule]
fn my_extension(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {

    #[pyfn(m)]
    fn double(x: usize) -&gt; usize {
        x * 2
    }

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><code>#[pyfn(m)]</code> is just syntactic sugar for <code>#[pyfunction]</code>, and takes all the same options
documented in the rest of this chapter. The code above is expanded to the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pymodule]
fn my_extension(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {

    #[pyfunction]
    fn double(x: usize) -&gt; usize {
        x * 2
    }

    m.add_function(wrap_pyfunction!(double, m)?)?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="function-options"><a class="header" href="#function-options">Function options</a></h2>
<p>The <code>#[pyo3]</code> attribute can be used to modify properties of the generated Python function. It can take any combination of the following options:</p>
<ul>
<li>
<p><code>#[pyo3(name = &quot;...&quot;)]</code></p>
<p>Overrides the name generated in Python:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyfunction]
#[pyo3(name = &quot;no_args&quot;)]
fn no_args_py() -&gt; usize { 42 }

#[pymodule]
fn module_with_functions(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(no_args_py, m)?)?;
    Ok(())
}

<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let m = pyo3::wrap_pymodule!(module_with_functions)(py);
</span><span class="boring">    assert!(m.getattr(py, &quot;no_args&quot;).is_ok());
</span><span class="boring">    assert!(m.getattr(py, &quot;no_args_py&quot;).is_err());
</span><span class="boring">});
</span><span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h2 id="argument-parsing"><a class="header" href="#argument-parsing">Argument parsing</a></h2>
<p>The <code>#[pyfunction]</code> attribute supports specifying details of argument parsing. The details are given in the section <a href="class.html#method-arguments">&quot;Method arguments&quot; of the Classes chapter</a>.  Here is an example for a function that accepts arbitrary keyword arguments (<code>**kwargs</code> in Python syntax) and returns the number that was passed:</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::PyDict;

#[pyfunction(kwds=&quot;**&quot;)]
fn num_kwds(kwds: Option&lt;&amp;PyDict&gt;) -&gt; usize {
    kwds.map_or(0, |dict| dict.len())
}

#[pymodule]
fn module_with_functions(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(num_kwds, m)?).unwrap();
    Ok(())
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="making-the-function-signature-available-to-python"><a class="header" href="#making-the-function-signature-available-to-python">Making the function signature available to Python</a></h2>
<p>In order to make the function signature available to Python to be retrieved via
<code>inspect.signature</code>, use the <code>#[pyo3(text_signature)]</code> annotation as in the example
below. The <code>/</code> signifies the end of positional-only arguments. (This
is not a feature of this library in particular, but the general format used by
CPython for annotating signatures of built-in functions.)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

/// This function adds two unsigned 64-bit integers.
#[pyfunction]
#[pyo3(text_signature = &quot;(a, b, /)&quot;)]
fn add(a: u64, b: u64) -&gt; u64 {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>This also works for classes and methods:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::types::PyType;

// it works even if the item is not documented:

#[pyclass]
#[pyo3(text_signature = &quot;(c, d, /)&quot;)]
struct MyClass {}

#[pymethods]
impl MyClass {
    // the signature for the constructor is attached
    // to the struct definition instead.
    #[new]
    fn new(c: i32, d: &amp;str) -&gt; Self {
        Self {}
    }
    // the self argument should be written $self
    #[pyo3(text_signature = &quot;($self, e, f)&quot;)]
    fn my_method(&amp;self, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    #[classmethod]
    #[pyo3(text_signature = &quot;(cls, e, f)&quot;)]
    fn my_class_method(cls: &amp;PyType, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    #[staticmethod]
    #[pyo3(text_signature = &quot;(e, f)&quot;)]
    fn my_static_method(e: i32, f: i32) -&gt; i32 {
        e + f
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that <code>text_signature</code> on classes is not compatible with compilation in
<code>abi3</code> mode until Python 3.10 or greater.</p>
<h3 id="making-the-function-signature-available-to-python-old-method"><a class="header" href="#making-the-function-signature-available-to-python-old-method">Making the function signature available to Python (old method)</a></h3>
<p>Alternatively, simply make sure the first line of your docstring is
formatted like in the following example. Please note that the newline after the
<code>--</code> is mandatory. The <code>/</code> signifies the end of positional-only arguments.</p>
<p><code>#[pyo3(text_signature)]</code> should be preferred, since it will override automatically
generated signatures when those are added in a future version of PyO3.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

/// add(a, b, /)
/// --
///
/// This function adds two unsigned 64-bit integers.
#[pyfunction]
fn add(a: u64, b: u64) -&gt; u64 {
    a + b
}

// a function with a signature but without docs. Both blank lines after the `--` are mandatory.

/// sub(a, b, /)
/// --
///
///
#[pyfunction]
fn sub(a: u64, b: u64) -&gt; u64 {
    a - b
}
<span class="boring">}
</span></code></pre></pre>
<p>When annotated like this, signatures are also correctly displayed in IPython.</p>
<pre><code class="language-ignore">&gt;&gt;&gt; pyo3_test.add?
Signature: pyo3_test.add(a, b, /)
Docstring: This function adds two unsigned 64-bit integers.
Type:      builtin_function_or_method
</code></pre>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<p>Currently, there are no conversions between <code>Fn</code>s in Rust and callables in Python. This would
definitely be possible and very useful, so contributions are welcome. In the meantime, you can do
the following:</p>
<h3 id="calling-python-functions-in-rust"><a class="header" href="#calling-python-functions-in-rust">Calling Python functions in Rust</a></h3>
<p>You can pass Python <code>def</code>'d functions and built-in functions to Rust functions <a href="https://docs.rs/pyo3/0.14.4/pyo3/types/struct.PyFunction.html"><code>PyFunction</code></a>
corresponds to regular Python functions while <a href="https://docs.rs/pyo3/0.14.4/pyo3/types/struct.PyCFunction.html"><code>PyCFunction</code></a> describes built-ins such as
<code>repr()</code>.</p>
<p>You can also use <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.PyAny.html#tymethod.is_callable"><code>PyAny::is_callable</code></a> to check if you have a callable object. <code>is_callable</code> will
return <code>true</code> for functions (including lambdas), methods and objects with a <code>__call__</code> method.
You can call the object with <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.PyAny.html#tymethod.call"><code>PyAny::call</code></a> with the args as first parameter and the kwargs
(or <code>None</code>) as second parameter. There are also <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.PyAny.html#tymethod.call0"><code>PyAny::call0</code></a> with no args and <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.PyAny.html#tymethod.call1"><code>PyAny::call1</code></a>
with only positional args.</p>
<h3 id="calling-rust-functions-in-python"><a class="header" href="#calling-rust-functions-in-python">Calling Rust functions in Python</a></h3>
<p>If you have a static function, you can expose it with <code>#[pyfunction]</code> and use <a href="https://docs.rs/pyo3/0.14.4/pyo3/macro.wrap_pyfunction.html"><code>wrap_pyfunction!</code></a>
to get the corresponding <a href="https://docs.rs/pyo3/0.14.4/pyo3/types/struct.PyCFunction.html"><code>PyCFunction</code></a>. For dynamic functions, e.g. lambdas and functions that
were passed as arguments, you must put them in some kind of owned container, e.g. a <code>Box</code>.
(A long-term solution will be a special container similar to wasm-bindgen's <code>Closure</code>). You can
then use a <code>#[pyclass]</code> struct with that container as a field as a way to pass the function over
the FFI barrier. You can even make that class callable with <code>__call__</code> so it looks like a function
in Python code.</p>
<h3 id="accessing-the-module-of-a-function"><a class="header" href="#accessing-the-module-of-a-function">Accessing the module of a function</a></h3>
<p>It is possible to access the module of a <code>#[pyfunction]</code> in the function body by using <code>#[pyo3(pass_module)]</code> option:</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

#[pyfunction]
#[pyo3(pass_module)]
fn pyfunction_with_module(module: &amp;PyModule) -&gt; PyResult&lt;&amp;str&gt; {
    module.name()
}

#[pymodule]
fn module_with_fn(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(pyfunction_with_module, m)?)
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>If <code>pass_module</code> is set, the first argument <strong>must</strong> be the <code>&amp;PyModule</code>. It is then possible to use the module
in the function body.</p>
<h2 id="accessing-the-ffi-functions"><a class="header" href="#accessing-the-ffi-functions">Accessing the FFI functions</a></h2>
<p>In order to make Rust functions callable from Python, PyO3 generates an <code>extern &quot;C&quot;</code>
function whose exact signature depends on the Rust signature.  (PyO3 chooses the optimal
Python argument passing convention.) It then embeds the call to the Rust function inside this
FFI-wrapper function. This wrapper handles extraction of the regular arguments and the keyword
arguments from the input <code>PyObject</code>s.</p>
<p>The <code>wrap_pyfunction</code> macro can be used to directly get a <code>PyCFunction</code> given a
<code>#[pyfunction]</code> and a <code>PyModule</code>: <code>wrap_pyfunction!(rust_fun, module)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-classes"><a class="header" href="#python-classes">Python Classes</a></h1>
<p>PyO3 exposes a group of attributes powered by Rust's proc macro system for defining Python classes as Rust structs.</p>
<p>The main attribute is <code>#[pyclass]</code>, which is placed upon a Rust <code>struct</code> to generate a Python type for it. A struct will usually also have <em>one</em> <code>#[pymethods]</code>-annotated <code>impl</code> block for the struct, which is used to define Python methods and constants for the generated Python type. (If the <a href="features.html#multiple-pymethods"><code>multiple-pymethods</code></a> feature is enabled each <code>#[pyclass]</code> is allowed to have multiple <code>#[pymethods]</code> blocks.) Finally, there may be multiple <code>#[pyproto]</code> trait implementations for the struct, which are used to define certain python magic methods such as <code>__str__</code>.</p>
<p>This chapter will discuss the functionality and configuration these attributes offer. Below is a list of links to the relevant section of this chapter for each:</p>
<ul>
<li><a href="class.html#defining-a-new-class"><code>#[pyclass]</code></a>
<ul>
<li><a href="class.html#object-properties-using-pyo3get-set"><code>#[pyo3(get, set)]</code></a></li>
</ul>
</li>
<li><a href="class.html#instance-methods"><code>#[pymethods]</code></a>
<ul>
<li><a href="class.html#constructor"><code>#[new]</code></a></li>
<li><a href="class.html#object-properties-using-getter-and-setter"><code>#[getter]</code></a></li>
<li><a href="class.html#object-properties-using-getter-and-setter"><code>#[setter]</code></a></li>
<li><a href="class.html#static-methods"><code>#[staticmethod]</code></a></li>
<li><a href="class.html#class-methods"><code>#[classmethod]</code></a></li>
<li><a href="class.html#callable-objects"><code>#[call]</code></a></li>
<li><a href="class.html#class-attributes"><code>#[classattr]</code></a></li>
<li><a href="class.html#method-arguments"><code>#[args]</code></a></li>
</ul>
</li>
<li><a href="class/protocols.html"><code>#[pyproto]</code></a></li>
</ul>
<h2 id="defining-a-new-class"><a class="header" href="#defining-a-new-class">Defining a new class</a></h2>
<p>To define a custom Python class, a Rust struct needs to be annotated with the
<code>#[pyclass]</code> attribute.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
    debug: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>Because Python objects are freely shared between threads by the Python interpreter, all structs annotated with <code>#[pyclass]</code> must implement <code>Send</code> (unless annotated with <a href="class.html#customizing-the-class"><code>#[pyclass(unsendable)]</code></a>).</p>
<p>The above example generates implementations for <a href="https://docs.rs/pyo3/0.14.4/pyo3/type_object/trait.PyTypeInfo.html"><code>PyTypeInfo</code></a>, <a href="https://docs.rs/pyo3/0.14.4/pyo3/type_object/trait.PyTypeObject.html"><code>PyTypeObject</code></a>, and <a href="https://docs.rs/pyo3/0.14.4/pyo3/pyclass/trait.PyClass.html"><code>PyClass</code></a> for <code>MyClass</code>. To see these generated implementations, refer to the <a href="class.html#implementation-details">implementation details</a> at the end of this chapter.</p>
<h2 id="adding-the-class-to-a-module"><a class="header" href="#adding-the-class-to-a-module">Adding the class to a module</a></h2>
<p>Custom Python classes can then be added to a module using <code>add_class()</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">   num: i32,
</span><span class="boring">   debug: bool,
</span><span class="boring">}
</span>#[pymodule]
fn mymodule(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;MyClass&gt;()?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="pycell-and-interior-mutability"><a class="header" href="#pycell-and-interior-mutability">PyCell and interior mutability</a></h2>
<p>You sometimes need to convert your <code>pyclass</code> into a Python object and access it
from Rust code (e.g., for testing it).
<a href="https://docs.rs/pyo3/0.14.4/pyo3/pycell/struct.PyCell.html"><code>PyCell</code></a> is the primary interface for that.</p>
<p><code>PyCell&lt;T: PyClass&gt;</code> is always allocated in the Python heap, so Rust doesn't have ownership of it.
In other words, Rust code can only extract a <code>&amp;PyCell&lt;T&gt;</code>, not a <code>PyCell&lt;T&gt;</code>.</p>
<p>Thus, to mutate data behind <code>&amp;PyCell</code> safely, PyO3 employs the
<a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">Interior Mutability Pattern</a>
like <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>.</p>
<p>Users who are familiar with <code>RefCell</code> can use <code>PyCell</code> just like <code>RefCell</code>.</p>
<p>For users who are not very familiar with <code>RefCell</code>, here is a reminder of Rust's rules of borrowing:</p>
<ul>
<li>At any given time, you can have either (but not both of) one mutable reference or any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<p><code>PyCell</code>, like <code>RefCell</code>, ensures these borrowing rules by tracking references at runtime.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyDict;
</span>#[pyclass]
struct MyClass {
    #[pyo3(get)]
    num: i32,
    debug: bool,
}
Python::with_gil(|py| {
    let obj = PyCell::new(py, MyClass { num: 3, debug: true }).unwrap();
    {
        let obj_ref = obj.borrow(); // Get PyRef
        assert_eq!(obj_ref.num, 3);
        // You cannot get PyRefMut unless all PyRefs are dropped
        assert!(obj.try_borrow_mut().is_err());
    }
    {
        let mut obj_mut = obj.borrow_mut(); // Get PyRefMut
        obj_mut.num = 5;
        // You cannot get any other refs until the PyRefMut is dropped
        assert!(obj.try_borrow().is_err());
        assert!(obj.try_borrow_mut().is_err());
    }

    // You can convert `&amp;PyCell` to a Python object
    pyo3::py_run!(py, obj, &quot;assert obj.num == 5&quot;);
});
<span class="boring">}
</span></code></pre></pre>
<p><code>&amp;PyCell&lt;T&gt;</code> is bounded by the same lifetime as a <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.GILGuard.html"><code>GILGuard</code></a>.
To make the object longer lived (for example, to store it in a struct on the
Rust side), you can use <code>Py&lt;T&gt;</code>, which stores an object longer than the GIL
lifetime, and therefore needs a <code>Python&lt;'_&gt;</code> token to access.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}
fn return_myclass() -&gt; Py&lt;MyClass&gt; {
    Python::with_gil(|py| Py::new(py, MyClass { num: 1 }).unwrap())
}
let obj = return_myclass();
Python::with_gil(|py|{
    let cell = obj.as_ref(py); // Py&lt;MyClass&gt;::as_ref returns &amp;PyCell&lt;MyClass&gt;
    let obj_ref = cell.borrow(); // Get PyRef&lt;T&gt;
    assert_eq!(obj_ref.num, 1);
});
<span class="boring">}
</span></code></pre></pre>
<h2 id="customizing-the-class"><a class="header" href="#customizing-the-class">Customizing the class</a></h2>
<p>The <code>#[pyclass]</code> macro accepts the following parameters:</p>
<ul>
<li><code>name=&quot;XXX&quot;</code> - Set the class name shown in Python code. By default, the struct name is used as the class name.</li>
<li><code>freelist=XXX</code> - The <code>freelist</code> parameter adds support of free allocation list to custom class.
The performance improvement applies to types that are often created and deleted in a row,
so that they can benefit from a freelist. <code>XXX</code> is a number of items for the free list.</li>
<li><code>gc</code> - Classes with the <code>gc</code> parameter participate in Python garbage collection.
If a custom class contains references to other Python objects that can be collected, the <a href="https://docs.rs/pyo3/0.14.4/pyo3/class/gc/trait.PyGCProtocol.html"><code>PyGCProtocol</code></a> trait has to be implemented.</li>
<li><code>weakref</code> - Adds support for Python weak references.</li>
<li><code>extends=BaseType</code> - Use a custom base class. The base <code>BaseType</code> must implement <code>PyTypeInfo</code>.</li>
<li><code>subclass</code> - Allows Python classes to inherit from this class.</li>
<li><code>dict</code> - Adds <code>__dict__</code> support, so that the instances of this type have a dictionary containing arbitrary instance variables.</li>
<li><code>unsendable</code> - Making it safe to expose <code>!Send</code> structs to Python, where all object can be accessed
by multiple threads. A class marked with <code>unsendable</code> panics when accessed by another thread.</li>
<li><code>module=&quot;XXX&quot;</code> - Set the name of the module the class will be shown as defined in. If not given, the class
will be a virtual member of the <code>builtins</code> module.</li>
</ul>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<p>By default it is not possible to create an instance of a custom class from Python code.
To declare a constructor, you need to define a method and annotate it with the <code>#[new]</code>
attribute. Only Python's <code>__new__</code> method can be specified, <code>__init__</code> is not available.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}

#[pymethods]
impl MyClass {
    #[new]
    fn new(num: i32) -&gt; Self {
        MyClass { num }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively, if your <code>new</code> method may fail you can return <code>PyResult&lt;Self&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}

#[pymethods]
impl MyClass {
    #[new]
    fn new(num: i32) -&gt; PyResult&lt;Self&gt; {
        Ok(MyClass { num })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If no method marked with <code>#[new]</code> is declared, object instances can only be
created from Rust, but not from Python.</p>
<p>For arguments, see the <code>Method arguments</code> section below.</p>
<h3 id="return-type"><a class="header" href="#return-type">Return type</a></h3>
<p>Generally, <code>#[new]</code> method have to return <code>T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code> or
<code>PyResult&lt;T&gt; where T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code>.</p>
<p>For constructors that may fail, you should wrap the return type in a PyResult as well.
Consult the table below to determine which type your constructor should return:</p>
<table><thead><tr><th></th><th><strong>Cannot fail</strong></th><th><strong>May fail</strong></th></tr></thead><tbody>
<tr><td><strong>No inheritance</strong></td><td><code>T</code></td><td><code>PyResult&lt;T&gt;</code></td></tr>
<tr><td><strong>Inheritance(T Inherits U)</strong></td><td><code>(T, U)</code></td><td><code>PyResult&lt;(T, U)&gt;</code></td></tr>
<tr><td><strong>Inheritance(General Case)</strong></td><td><a href="https://docs.rs/pyo3/0.14.4/pyo3/pyclass_init/struct.PyClassInitializer.html"><code>PyClassInitializer&lt;T&gt;</code></a></td><td><code>PyResult&lt;PyClassInitializer&lt;T&gt;&gt;</code></td></tr>
</tbody></table>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>By default, <code>PyAny</code> is used as the base class. To override this default,
use the <code>extends</code> parameter for <code>pyclass</code> with the full path to the base class.</p>
<p>For convenience, <code>(T, U)</code> implements <code>Into&lt;PyClassInitializer&lt;T&gt;&gt;</code> where <code>U</code> is the
baseclass of <code>T</code>.
But for more deeply nested inheritance, you have to return <code>PyClassInitializer&lt;T&gt;</code>
explicitly.</p>
<p>To get a parent class from a child, use <a href="https://docs.rs/pyo3/0.14.4/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> instead of <code>&amp;self</code> for methods,
or <a href="https://docs.rs/pyo3/0.14.4/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a> instead of <code>&amp;mut self</code>.
Then you can access a parent class by <code>self_.as_ref()</code> as <code>&amp;Self::BaseClass</code>,
or by <code>self_.into_super()</code> as <code>PyRef&lt;Self::BaseClass&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass(subclass)]
struct BaseClass {
    val1: usize,
}

#[pymethods]
impl BaseClass {
    #[new]
    fn new() -&gt; Self {
        BaseClass { val1: 10 }
    }

    pub fn method(&amp;self) -&gt; PyResult&lt;usize&gt; {
        Ok(self.val1)
    }
}

#[pyclass(extends=BaseClass, subclass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; (Self, BaseClass) {
        (SubClass { val2: 15 }, BaseClass::new())
    }

    fn method2(self_: PyRef&lt;Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let super_ = self_.as_ref();  // Get &amp;BaseClass
        super_.method().map(|x| x * self_.val2)
    }
}

#[pyclass(extends=SubClass)]
struct SubSubClass {
    val3: usize,
}

#[pymethods]
impl SubSubClass {
    #[new]
    fn new() -&gt; PyClassInitializer&lt;Self&gt; {
        PyClassInitializer::from(SubClass::new())
            .add_subclass(SubSubClass{val3: 20})
    }

    fn method3(self_: PyRef&lt;Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let v = self_.val3;
        let super_ = self_.into_super();  // Get PyRef&lt;SubClass&gt;
        SubClass::method2(super_).map(|x| x * v)
    }
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let subsub = pyo3::PyCell::new(py, SubSubClass::new()).unwrap();
</span><span class="boring">    pyo3::py_run!(py, subsub, &quot;assert subsub.method3() == 3000&quot;)
</span><span class="boring">});
</span><span class="boring">}
</span></code></pre></pre>
<p>You can also inherit native types such as <code>PyDict</code>, if they implement
<a href="https://docs.rs/pyo3/0.14.4/pyo3/type_object/trait.PySizedLayout.html"><code>PySizedLayout</code></a>. However, this is not supported when building for the Python limited API (aka the <code>abi3</code> feature of PyO3).</p>
<p>However, because of some technical problems, we don't currently provide safe upcasting methods for types
that inherit native types. Even in such cases, you can unsafely get a base class by raw pointer conversion.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(not(Py_LIMITED_API))] {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyDict;
use pyo3::{AsPyPointer, PyNativeType};
use std::collections::HashMap;

#[pyclass(extends=PyDict)]
#[derive(Default)]
struct DictWithCounter {
    counter: HashMap&lt;String, usize&gt;,
}

#[pymethods]
impl DictWithCounter {
    #[new]
    fn new() -&gt; Self {
        Self::default()
    }
    fn set(mut self_: PyRefMut&lt;Self&gt;, key: String, value: &amp;PyAny) -&gt; PyResult&lt;()&gt; {
        self_.counter.entry(key.clone()).or_insert(0);
        let py = self_.py();
        let dict: &amp;PyDict = unsafe { py.from_borrowed_ptr_or_err(self_.as_ptr())? };
        dict.set_item(key, value)
    }
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let cnt = pyo3::PyCell::new(py, DictWithCounter::new()).unwrap();
</span><span class="boring">    pyo3::py_run!(py, cnt, &quot;cnt.set('abc', 10); assert cnt['abc'] == 10&quot;)
</span><span class="boring">});
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>If <code>SubClass</code> does not provide a baseclass initialization, the compilation fails.</p>
<pre><code class="language-compile_fail"># use pyo3::prelude::*;

#[pyclass]
struct BaseClass {
    val1: usize,
}

#[pyclass(extends=BaseClass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; Self {
        SubClass { val2: 15 }
    }
}
</code></pre>
<h2 id="object-properties"><a class="header" href="#object-properties">Object properties</a></h2>
<p>PyO3 supports two ways to add properties to your <code>#[pyclass]</code>:</p>
<ul>
<li>For simple fields with no side effects, a <code>#[pyo3(get, set)]</code> attribute can be added directly to the field definition in the <code>#[pyclass]</code>.</li>
<li>For properties which require computation you can define <code>#[getter]</code> and <code>#[setter]</code> functions in the <a href="class.html#instance-methods"><code>#[pymethods]</code></a> block.</li>
</ul>
<p>We'll cover each of these in the following sections.</p>
<h3 id="object-properties-using-pyo3get-set"><a class="header" href="#object-properties-using-pyo3get-set">Object properties using <code>#[pyo3(get, set)]</code></a></h3>
<p>For simple cases where a member variable is just read and written with no side effects, you can declare getters and setters in your <code>#[pyclass]</code> field definition using the <code>pyo3</code> attribute, like in the example below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    #[pyo3(get, set)]
    num: i32
}
<span class="boring">}
</span></code></pre></pre>
<p>The above would make the <code>num</code> field available for reading and writing as a <code>self.num</code> Python property. To expose the property with a different name to the field, specify this alongside the rest of the options, e.g. <code>#[pyo3(get, set, name = &quot;custom_name&quot;)]</code>.</p>
<p>Properties can be readonly or writeonly by using just <code>#[pyo3(get)]</code> or <code>#[pyo3(set)]</code> respectively.</p>
<p>To use these annotations, your field type must implement some conversion traits:</p>
<ul>
<li>For <code>get</code> the field type must implement both <code>IntoPy&lt;PyObject&gt;</code> and <code>Clone</code>.</li>
<li>For <code>set</code> the field type must implement <code>FromPyObject</code>.</li>
</ul>
<h3 id="object-properties-using-getter-and-setter"><a class="header" href="#object-properties-using-getter-and-setter">Object properties using <code>#[getter]</code> and <code>#[setter]</code></a></h3>
<p>For cases which don't satisfy the <code>#[pyo3(get, set)]</code> trait requirements, or need side effects, descriptor methods can be defined in a <code>#[pymethods]</code> <code>impl</code> block.</p>
<p>This is done using the <code>#[getter]</code> and <code>#[setter]</code> attributes, like in the example below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}

#[pymethods]
impl MyClass {
    #[getter]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A getter or setter's function name is used as the property name by default. There are several
ways how to override the name.</p>
<p>If a function name starts with <code>get_</code> or <code>set_</code> for getter or setter respectively,
the descriptor name becomes the function name with this prefix removed. This is also useful in case of
Rust keywords like <code>type</code>
(<a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/raw-identifiers.html">raw identifiers</a>
can be used since Rust 2018).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter]
    fn get_num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, a property <code>num</code> is defined and available from Python code as <code>self.num</code>.</p>
<p>Both the <code>#[getter]</code> and <code>#[setter]</code> attributes accept one parameter.
If this parameter is specified, it is used as the property name, i.e.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">   num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter(number)]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter(number)]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, the property <code>number</code> is defined and available from Python code as <code>self.number</code>.</p>
<p>Attributes defined by <code>#[setter]</code> or <code>#[pyo3(set)]</code> will always raise <code>AttributeError</code> on <code>del</code>
operations. Support for defining custom <code>del</code> behavior is tracked in
<a href="https://github.com/PyO3/pyo3/issues/1778">#1778</a>.</p>
<h2 id="instance-methods"><a class="header" href="#instance-methods">Instance methods</a></h2>
<p>To define a Python compatible method, an <code>impl</code> block for your struct has to be annotated with the
<code>#[pymethods]</code> attribute. PyO3 generates Python compatible wrappers for all functions in this
block with some variations, like descriptors, class method static methods, etc.</p>
<p>Since Rust allows any number of <code>impl</code> blocks, you can easily split methods
between those accessible to Python (and Rust) and those accessible only to Rust. However to have multiple
<code>#[pymethods]</code>-annotated <code>impl</code> blocks for the same struct you must enable the <a href="features.html#multiple-pymethods"><code>multiple-pymethods</code></a> feature of PyO3.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method1(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }

    fn set_method(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Calls to these methods are protected by the GIL, so both <code>&amp;self</code> and <code>&amp;mut self</code> can be used.
The return type must be <code>PyResult&lt;T&gt;</code> or <code>T</code> for some <code>T</code> that implements <code>IntoPy&lt;PyObject&gt;</code>;
the latter is allowed if the method cannot raise Python exceptions.</p>
<p>A <code>Python</code> parameter can be specified as part of method signature, in this case the <code>py</code> argument
gets injected by the method wrapper, e.g.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method2(&amp;self, py: Python) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>From the Python perspective, the <code>method2</code> in this example does not accept any arguments.</p>
<h2 id="class-methods"><a class="header" href="#class-methods">Class methods</a></h2>
<p>To create a class method for a custom class, the method needs to be annotated
with the <code>#[classmethod]</code> attribute.
This is the equivalent of the Python decorator <code>@classmethod</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyType;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[classmethod]
    fn cls_method(cls: &amp;PyType) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Declares a class method callable from Python.</p>
<ul>
<li>The first parameter is the type object of the class on which the method is called.
This may be the type object of a derived class.</li>
<li>The first parameter implicitly has type <code>&amp;PyType</code>.</li>
<li>For details on <code>parameter-list</code>, see the documentation of <code>Method arguments</code> section.</li>
<li>The return type must be <code>PyResult&lt;T&gt;</code> or <code>T</code> for some <code>T</code> that implements <code>IntoPy&lt;PyObject&gt;</code>.</li>
</ul>
<h2 id="static-methods"><a class="header" href="#static-methods">Static methods</a></h2>
<p>To create a static method for a custom class, the method needs to be annotated with the
<code>#[staticmethod]</code> attribute. The return type must be <code>T</code> or <code>PyResult&lt;T&gt;</code> for some <code>T</code> that implements
<code>IntoPy&lt;PyObject&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[staticmethod]
    fn static_method(param1: i32, param2: &amp;str) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="class-attributes"><a class="header" href="#class-attributes">Class attributes</a></h2>
<p>To create a class attribute (also called <a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables">class variable</a>), a method without
any arguments can be annotated with the <code>#[classattr]</code> attribute. The return type must be <code>T</code> for
some <code>T</code> that implements <code>IntoPy&lt;PyObject&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>#[pymethods]
impl MyClass {
    #[classattr]
    fn my_attribute() -&gt; String {
        &quot;hello&quot;.to_string()
    }
}

Python::with_gil(|py| {
    let my_class = py.get_type::&lt;MyClass&gt;();
    pyo3::py_run!(py, my_class, &quot;assert my_class.my_attribute == 'hello'&quot;)
});
<span class="boring">}
</span></code></pre></pre>
<p>Note that unlike class variables defined in Python code, class attributes defined in Rust cannot
be mutated at all:</p>
<pre><code class="language-rust ignore">// Would raise a `TypeError: can't set attributes of built-in/extension type 'MyClass'`
pyo3::py_run!(py, my_class, &quot;my_class.my_attribute = 'foo'&quot;)
</code></pre>
<p>If the class attribute is defined with <code>const</code> code only, one can also annotate associated
constants:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>#[pymethods]
impl MyClass {
    #[classattr]
    const MY_CONST_ATTRIBUTE: &amp;'static str = &quot;foobar&quot;;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="callable-objects"><a class="header" href="#callable-objects">Callable objects</a></h2>
<p>To specify a custom <code>__call__</code> method for a custom class, the method needs to be annotated with
the <code>#[call]</code> attribute. Arguments of the method are specified as for instance methods.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyTuple;
<span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[call]
    #[args(args=&quot;*&quot;)]
    fn __call__(&amp;self, args: &amp;PyTuple) -&gt; PyResult&lt;i32&gt; {
        println!(&quot;MyClass has been called&quot;);
        Ok(self.num)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="method-arguments"><a class="header" href="#method-arguments">Method arguments</a></h2>
<p>By default, PyO3 uses function signatures to determine which arguments are required. Then it scans
the incoming <code>args</code> and <code>kwargs</code> parameters. If it can not find all required
parameters, it raises a <code>TypeError</code> exception. It is possible to override the default behavior
with the <code>#[args(...)]</code> attribute. This attribute accepts a comma separated list of parameters in
the form of <code>attr_name=&quot;default value&quot;</code>. Each parameter has to match the method parameter by name.</p>
<p>Each parameter can be one of the following types:</p>
<ul>
<li><code>&quot;*&quot;</code>: var arguments separator, each parameter defined after <code>&quot;*&quot;</code> is a keyword-only parameter.
Corresponds to python's <code>def meth(*, arg1.., arg2=..)</code>.</li>
<li><code>args=&quot;*&quot;</code>: &quot;args&quot; is var args, corresponds to Python's <code>def meth(*args)</code>. Type of the <code>args</code>
parameter has to be <code>&amp;PyTuple</code>.</li>
<li><code>kwargs=&quot;**&quot;</code>: &quot;kwargs&quot; receives keyword arguments, corresponds to Python's <code>def meth(**kwargs)</code>.
The type of the <code>kwargs</code> parameter has to be <code>Option&lt;&amp;PyDict&gt;</code>.</li>
<li><code>arg=&quot;Value&quot;</code>: arguments with default value. Corresponds to Python's <code>def meth(arg=Value)</code>.
If the <code>arg</code> argument is defined after var arguments, it is treated as a keyword-only argument.
Note that <code>Value</code> has to be valid rust code, PyO3 just inserts it into the generated
code unmodified.</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::{PyDict, PyTuple};
<span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[new]
    #[args(num = &quot;-1&quot;, debug = &quot;true&quot;)]
    fn new(num: i32, debug: bool) -&gt; Self {
        MyClass { num, debug }
    }

    #[args(
        num = &quot;10&quot;,
        debug = &quot;true&quot;,
        py_args = &quot;*&quot;,
        name = &quot;\&quot;Hello\&quot;&quot;,
        py_kwargs = &quot;**&quot;
    )]
    fn method(
        &amp;mut self,
        num: i32,
        debug: bool,
        name: &amp;str,
        py_args: &amp;PyTuple,
        py_kwargs: Option&lt;&amp;PyDict&gt;,
    ) -&gt; PyResult&lt;String&gt; {
        self.debug = debug;
        self.num = num;
        Ok(format!(
            &quot;py_args={:?}, py_kwargs={:?}, name={}, num={}, debug={}&quot;,
            py_args, py_kwargs, name, self.num, self.debug
        ))
    }

    fn make_change(&amp;mut self, num: i32, debug: bool) -&gt; PyResult&lt;String&gt; {
        self.num = num;
        self.debug = debug;
        Ok(format!(&quot;num={}, debug={}&quot;, self.num, self.debug))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>N.B. the position of the <code>&quot;*&quot;</code> argument (if included) controls the system of handling positional and keyword arguments. In Python:</p>
<pre><code class="language-python">import mymodule

mc = mymodule.MyClass()
print(mc.method(44, False, &quot;World&quot;, 666, x=44, y=55))
print(mc.method(num=-1, name=&quot;World&quot;))
print(mc.make_change(44, False))
print(mc.make_change(debug=False, num=-1))
</code></pre>
<p>Produces output:</p>
<pre><code class="language-text">py_args=('World', 666), py_kwargs=Some({'x': 44, 'y': 55}), name=Hello, num=44, debug=false
py_args=(), py_kwargs=None, name=World, num=-1, debug=true
num=44, debug=false
num=-1, debug=false
</code></pre>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation details</a></h2>
<p>The <code>#[pyclass]</code> macros rely on a lot of conditional code generation: each <code>#[pyclass]</code> can optionally have a <code>#[pymethods]</code> block as well as several different possible <code>#[pyproto]</code> trait implementations.</p>
<p>To support this flexibility the <code>#[pyclass]</code> macro expands to a blob of boilerplate code which sets up the structure for <a href="https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/README.md">&quot;dtolnay specialization&quot;</a>. This implementation pattern enables the Rust compiler to use <code>#[pymethods]</code> and <code>#[pyproto]</code> implementations when they are present, and fall back to default (empty) definitions when they are not.</p>
<p>This simple technique works for the case when there is zero or one implementations. To support multiple <code>#[pymethods]</code> for a <code>#[pyclass]</code> (in the <a href="features.html#multiple-pymethods"><code>multiple-pymethods</code></a> feature), a registry mechanism provided by the <a href="https://github.com/dtolnay/inventory"><code>inventory</code></a> crate is used instead. This collects <code>impl</code>s at library load time, but isn't supported on all platforms. See <a href="https://github.com/dtolnay/inventory#how-it-works">inventory: how it works</a> for more details.</p>
<p>The <code>#[pyclass]</code> macro expands to roughly the code seen below. The <code>PyClassImplCollector</code> is the type used internally by PyO3 for dtolnay specialization:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(not(feature = &quot;multiple-pymethods&quot;))] {
</span><span class="boring">use pyo3::prelude::*;
</span>// Note: the implementation differs slightly with the `multiple-pymethods` feature enabled.

/// Class for demonstration
struct MyClass {
    num: i32,
    debug: bool,
}

unsafe impl pyo3::PyTypeInfo for MyClass {
    type AsRefTarget = PyCell&lt;Self&gt;;

    const NAME: &amp;'static str = &quot;MyClass&quot;;
    const MODULE: Option&lt;&amp;'static str&gt; = None;

    #[inline]
    fn type_object_raw(py: pyo3::Python) -&gt; *mut pyo3::ffi::PyTypeObject {
        use pyo3::type_object::LazyStaticType;
        static TYPE_OBJECT: LazyStaticType = LazyStaticType::new();
        TYPE_OBJECT.get_or_init::&lt;Self&gt;(py)
    }
}

impl pyo3::pyclass::PyClass for MyClass {
    type Dict = pyo3::pyclass_slots::PyClassDummySlot;
    type WeakRef = pyo3::pyclass_slots::PyClassDummySlot;
    type BaseNativeType = PyAny;
}

impl pyo3::IntoPy&lt;PyObject&gt; for MyClass {
    fn into_py(self, py: pyo3::Python) -&gt; pyo3::PyObject {
        pyo3::IntoPy::into_py(pyo3::Py::new(py, self).unwrap(), py)
    }
}

impl pyo3::class::impl_::PyClassImpl for MyClass {
    const DOC: &amp;'static str = &quot;Class for demonstration&quot;;
    const IS_GC: bool = false;
    const IS_BASETYPE: bool = false;
    const IS_SUBCLASS: bool = false;
    type Layout = PyCell&lt;MyClass&gt;;
    type BaseType = PyAny;
    type ThreadChecker = pyo3::class::impl_::ThreadCheckerStub&lt;MyClass&gt;;

    fn for_each_method_def(visitor: &amp;mut dyn FnMut(&amp;[pyo3::class::PyMethodDefType])) {
        use pyo3::class::impl_::*;
        let collector = PyClassImplCollector::&lt;MyClass&gt;::new();
        visitor(collector.py_methods());
        visitor(collector.py_class_descriptors());
        visitor(collector.object_protocol_methods());
        visitor(collector.async_protocol_methods());
        visitor(collector.context_protocol_methods());
        visitor(collector.descr_protocol_methods());
        visitor(collector.mapping_protocol_methods());
        visitor(collector.number_protocol_methods());
    }
    fn get_new() -&gt; Option&lt;pyo3::ffi::newfunc&gt; {
        use pyo3::class::impl_::*;
        let collector = PyClassImplCollector::&lt;Self&gt;::new();
        collector.new_impl()
    }
    fn get_alloc() -&gt; Option&lt;pyo3::ffi::allocfunc&gt; {
        use pyo3::class::impl_::*;
        let collector = PyClassImplCollector::&lt;Self&gt;::new();
        collector.alloc_impl()
    }
    fn get_free() -&gt; Option&lt;pyo3::ffi::freefunc&gt; {
        use pyo3::class::impl_::*;
        let collector = PyClassImplCollector::&lt;Self&gt;::new();
        collector.free_impl()
    }
    fn get_call() -&gt; Option&lt;pyo3::ffi::PyCFunctionWithKeywords&gt; {
        use pyo3::class::impl_::*;
        let collector = PyClassImplCollector::&lt;Self&gt;::new();
        collector.call_impl()
    }
    fn for_each_proto_slot(visitor: &amp;mut dyn FnMut(&amp;[pyo3::ffi::PyType_Slot])) {
        // Implementation which uses dtolnay specialization to load all slots.
        use pyo3::class::impl_::*;
        let collector = PyClassImplCollector::&lt;Self&gt;::new();
        visitor(collector.object_protocol_slots());
        visitor(collector.number_protocol_slots());
        visitor(collector.iter_protocol_slots());
        visitor(collector.gc_protocol_slots());
        visitor(collector.descr_protocol_slots());
        visitor(collector.mapping_protocol_slots());
        visitor(collector.sequence_protocol_slots());
        visitor(collector.async_protocol_slots());
        visitor(collector.buffer_protocol_slots());
    }

    fn get_buffer() -&gt; Option&lt;&amp;'static pyo3::class::impl_::PyBufferProcs&gt; {
        use pyo3::class::impl_::*;
        let collector = PyClassImplCollector::&lt;Self&gt;::new();
        collector.buffer_procs()
    }
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let cls = py.get_type::&lt;MyClass&gt;();
</span><span class="boring">    pyo3::py_run!(py, cls, &quot;assert cls.__name__ == 'MyClass'&quot;)
</span><span class="boring">});
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="class-customizations"><a class="header" href="#class-customizations">Class customizations</a></h2>
<p>PyO3 uses the <code>#[pyproto]</code> attribute in combination with special traits to implement certain protocol (aka <code>__dunder__</code>) methods of Python classes. The special traits are listed in this chapter of the guide. See also the <a href="https://docs.rs/pyo3/0.14.4/pyo3/class/index.html">documentation for the <code>pyo3::class</code> module</a>.</p>
<p>Python's object model defines several protocols for different object behavior, such as the sequence, mapping, and number protocols. You may be familiar with implementing these protocols in Python classes by &quot;dunder&quot; methods, such as <code>__str__</code> or <code>__repr__</code>.</p>
<p>In the Python C-API which PyO3 is dependent upon, many of these protocol methods have to be provided into special &quot;slots&quot; on the class type object. To fill these slots PyO3 uses the <code>#[pyproto]</code> attribute in combination with special traits.</p>
<p>All <code>#[pyproto]</code> methods can return <code>T</code> instead of <code>PyResult&lt;T&gt;</code> if the method implementation is infallible. In addition, if the return type is <code>()</code>, it can be omitted altogether.</p>
<p>There are many &quot;dunder&quot; methods which are not included in any of PyO3's protocol traits, such as <code>__dir__</code>. These methods can be implemented in <code>#[pymethods]</code> as already covered in the previous section.</p>
<h3 id="basic-object-customization"><a class="header" href="#basic-object-customization">Basic object customization</a></h3>
<p>The <a href="https://docs.rs/pyo3/0.14.4/pyo3/class/basic/trait.PyObjectProtocol.html"><code>PyObjectProtocol</code></a> trait provides several basic customizations.</p>
<h4 id="attribute-access"><a class="header" href="#attribute-access">Attribute access</a></h4>
<p>To customize object attribute access, define the following methods:</p>
<ul>
<li><code>fn __getattr__(&amp;self, name: impl FromPyObject) -&gt; PyResult&lt;impl IntoPy&lt;PyObject&gt;&gt;</code></li>
<li><code>fn __setattr__(&amp;mut self, name: impl FromPyObject, value: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __delattr__(&amp;mut self, name: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
</ul>
<p>Each method corresponds to Python's <code>self.attr</code>, <code>self.attr = value</code> and <code>del self.attr</code> code.</p>
<h4 id="string-conversions"><a class="header" href="#string-conversions">String Conversions</a></h4>
<ul>
<li>
<p><code>fn __repr__(&amp;self) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
</li>
<li>
<p><code>fn __str__(&amp;self) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
<p>Possible return types for <code>__str__</code> and <code>__repr__</code> are <code>PyResult&lt;String&gt;</code> or <code>PyResult&lt;PyString&gt;</code>.</p>
</li>
</ul>
<h4 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison operators</a></h4>
<ul>
<li>
<p><code>fn __richcmp__(&amp;self, other: impl FromPyObject, op: CompareOp) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Overloads Python comparison operations (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>).
The <code>op</code> argument indicates the comparison operation being performed.
The return type will normally be <code>PyResult&lt;bool&gt;</code>, but any Python object can be returned.
If <code>other</code> is not of the type specified in the signature, the generated code will
automatically <code>return NotImplemented</code>.</p>
</li>
<li>
<p><code>fn __hash__(&amp;self) -&gt; PyResult&lt;impl PrimInt&gt;</code></p>
<p>Objects that compare equal must have the same hash value.
The return type must be <code>PyResult&lt;T&gt;</code> where <code>T</code> is one of Rust's primitive integer types.</p>
</li>
</ul>
<h4 id="other-methods"><a class="header" href="#other-methods">Other methods</a></h4>
<ul>
<li>
<p><code>fn __bool__(&amp;self) -&gt; PyResult&lt;bool&gt;</code></p>
<p>Determines the &quot;truthyness&quot; of the object.</p>
</li>
</ul>
<h3 id="emulating-numeric-types"><a class="header" href="#emulating-numeric-types">Emulating numeric types</a></h3>
<p>The <a href="https://docs.rs/pyo3/0.14.4/pyo3/class/number/trait.PyNumberProtocol.html"><code>PyNumberProtocol</code></a> trait can be implemented to emulate <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types">numeric types</a>.</p>
<ul>
<li><code>fn __add__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __sub__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __mul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __matmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __truediv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __floordiv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __mod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __divmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __pow__(lhs: impl FromPyObject, rhs: impl FromPyObject, modulo: Option&lt;impl FromPyObject&gt;) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __lshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __and__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __or__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __xor__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
</ul>
<p>These methods are called to implement the binary arithmetic operations
(<code>+</code>, <code>-</code>, <code>*</code>, <code>@</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>divmod()</code>, <code>pow()</code> and <code>**</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>^</code>, and <code>|</code>).</p>
<p>If <code>rhs</code> is not of the type specified in the signature, the generated code
will automatically <code>return NotImplemented</code>.  This is not the case for <code>lhs</code>
which must match signature or else raise a TypeError.</p>
<p>The reflected operations are also available:</p>
<ul>
<li><code>fn __radd__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rsub__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rmatmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rtruediv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rfloordiv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rdivmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rpow__(lhs: impl FromPyObject, rhs: impl FromPyObject, modulo: Option&lt;impl FromPyObject&gt;) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rlshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rrshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rand__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __ror__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rxor__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
</ul>
<p>The code generated for these methods expect that all arguments match the
signature, or raise a TypeError.</p>
<p>This trait also has support the augmented arithmetic assignments (<code>+=</code>, <code>-=</code>,
<code>*=</code>, <code>@=</code>, <code>/=</code>, <code>//=</code>, <code>%=</code>, <code>**=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>):</p>
<ul>
<li><code>fn __iadd__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __isub__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __imul__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __imatmul__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __itruediv__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __ifloordiv__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __imod__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __ipow__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __ilshift__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __irshift__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __iand__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __ior__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __ixor__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
</ul>
<p>The following methods implement the unary arithmetic operations (<code>-</code>, <code>+</code>, <code>abs()</code> and <code>~</code>):</p>
<ul>
<li><code>fn __neg__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __pos__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __abs__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __invert__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
</ul>
<p>Support for coercions:</p>
<ul>
<li><code>fn __int__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __float__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
</ul>
<p>Other:</p>
<ul>
<li><code>fn __index__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
</ul>
<h3 id="emulating-sequential-containers-such-as-lists-or-tuples"><a class="header" href="#emulating-sequential-containers-such-as-lists-or-tuples">Emulating sequential containers (such as lists or tuples)</a></h3>
<p>The <a href="https://docs.rs/pyo3/0.14.4/pyo3/class/sequence/trait.PySequenceProtocol.html"><code>PySequenceProtocol</code></a> trait can be implemented to emulate
<a href="https://docs.python.org/3/reference/datamodel.html#emulating-container-types">sequential container types</a>.</p>
<p>For a sequence, the keys are the integers <em>k</em> for which <em>0 &lt;= k &lt; N</em>,
where <em>N</em> is the length of the sequence.</p>
<ul>
<li>
<p><code>fn __len__(&amp;self) -&gt; PyResult&lt;usize&gt;</code></p>
<p>Implements the built-in function <code>len()</code> for the sequence.</p>
</li>
<li>
<p><code>fn __getitem__(&amp;self, idx: isize) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Implements evaluation of the <code>self[idx]</code> element.
If the <code>idx</code> value is outside the set of indexes for the sequence, <code>IndexError</code> should be raised.</p>
<p><em>Note:</em> Negative integer indexes are handled as follows: if <code>__len__()</code> is defined,
it is called and the sequence length is used to compute a positive index,
which is passed to <code>__getitem__()</code>.
If <code>__len__()</code> is not defined, the index is passed as is to the function.</p>
</li>
<li>
<p><code>fn __setitem__(&amp;mut self, idx: isize, value: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></p>
<p>Implements assignment to the <code>self[idx]</code> element. Same note as for <code>__getitem__()</code>.
Should only be implemented if sequence elements can be replaced.</p>
</li>
<li>
<p><code>fn __delitem__(&amp;mut self, idx: isize) -&gt; PyResult&lt;()&gt;</code></p>
<p>Implements deletion of the <code>self[idx]</code> element. Same note as for <code>__getitem__()</code>.
Should only be implemented if sequence elements can be deleted.</p>
</li>
<li>
<p><code>fn __contains__(&amp;self, item: impl FromPyObject) -&gt; PyResult&lt;bool&gt;</code></p>
<p>Implements membership test operators.
Should return true if <code>item</code> is in <code>self</code>, false otherwise.
For objects that donâ€™t define <code>__contains__()</code>, the membership test simply
traverses the sequence until it finds a match.</p>
</li>
<li>
<p><code>fn __concat__(&amp;self, other: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Concatenates two sequences.
Used by the <code>+</code> operator, after trying the numeric addition via
the <code>PyNumberProtocol</code> trait method.</p>
</li>
<li>
<p><code>fn __repeat__(&amp;self, count: isize) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Repeats the sequence <code>count</code> times.
Used by the <code>*</code> operator, after trying the numeric multiplication via
the <code>PyNumberProtocol</code> trait method.</p>
</li>
<li>
<p><code>fn __inplace_concat__(&amp;mut self, other: impl FromPyObject) -&gt; PyResult&lt;Self&gt;</code></p>
<p>Concatenates two sequences in place. Returns the modified first operand.
Used by the <code>+=</code> operator, after trying the numeric in place addition via
the <code>PyNumberProtocol</code> trait method.</p>
</li>
<li>
<p><code>fn __inplace_repeat__(&amp;mut self, count: isize) -&gt; PyResult&lt;Self&gt;</code></p>
<p>Repeats the sequence <code>count</code> times in place. Returns the modified first operand.
Used by the <code>*=</code> operator, after trying the numeric in place multiplication via
the <code>PyNumberProtocol</code> trait method.</p>
</li>
</ul>
<h3 id="emulating-mapping-containers-such-as-dictionaries"><a class="header" href="#emulating-mapping-containers-such-as-dictionaries">Emulating mapping containers (such as dictionaries)</a></h3>
<p>The <a href="https://docs.rs/pyo3/0.14.4/pyo3/class/mapping/trait.PyMappingProtocol.html"><code>PyMappingProtocol</code></a> trait allows to emulate
<a href="https://docs.python.org/3/reference/datamodel.html#emulating-container-types">mapping container types</a>.</p>
<p>For a mapping, the keys may be Python objects of arbitrary type.</p>
<ul>
<li>
<p><code>fn __len__(&amp;self) -&gt; PyResult&lt;usize&gt;</code></p>
<p>Implements the built-in function <code>len()</code> for the mapping.</p>
</li>
<li>
<p><code>fn __getitem__(&amp;self, key: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Implements evaluation of the <code>self[key]</code> element.
If <code>key</code> is of an inappropriate type, <code>TypeError</code> may be raised;
if <code>key</code> is missing (not in the container), <code>KeyError</code> should be raised.</p>
</li>
<li>
<p><code>fn __setitem__(&amp;mut self, key: impl FromPyObject, value: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></p>
<p>Implements assignment to the <code>self[key]</code> element or insertion of a new <code>key</code>
mapping to <code>value</code>.
Should only be implemented if the mapping support changes to the values for keys,
or if new keys can be added.
The same exceptions should be raised for improper key values as
for the <code>__getitem__()</code> method.</p>
</li>
<li>
<p><code>fn __delitem__(&amp;mut self, key: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></p>
<p>Implements deletion of the <code>self[key]</code> element.
Should only be implemented if the mapping supports removal of keys.
The same exceptions should be raised for improper key values as
for the <code>__getitem__()</code> method.</p>
</li>
</ul>
<h3 id="garbage-collector-integration"><a class="header" href="#garbage-collector-integration">Garbage Collector Integration</a></h3>
<p>If your type owns references to other Python objects, you will need to
integrate with Python's garbage collector so that the GC is aware of
those references.
To do this, implement the <a href="https://docs.rs/pyo3/0.14.4/pyo3/class/gc/trait.PyGCProtocol.html"><code>PyGCProtocol</code></a> trait for your struct.
It includes two methods <code>__traverse__</code> and <code>__clear__</code>.
These correspond to the slots <code>tp_traverse</code> and <code>tp_clear</code> in the Python C API.
<code>__traverse__</code> must call <code>visit.call()</code> for each reference to another Python object.
<code>__clear__</code> must clear out any mutable references to other Python objects
(thus breaking reference cycles). Immutable references do not have to be cleared,
as every cycle must contain at least one mutable reference.
Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::PyTraverseError;
use pyo3::gc::{PyGCProtocol, PyVisit};

#[pyclass]
struct ClassWithGCSupport {
    obj: Option&lt;PyObject&gt;,
}

#[pyproto]
impl PyGCProtocol for ClassWithGCSupport {
    fn __traverse__(&amp;self, visit: PyVisit) -&gt; Result&lt;(), PyTraverseError&gt; {
        if let Some(obj) = &amp;self.obj {
            visit.call(obj)?
        }
        Ok(())
    }

    fn __clear__(&amp;mut self) {
        // Clear reference, this decrements ref counter.
        self.obj = None;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Special protocol trait implementations have to be annotated with the <code>#[pyproto]</code> attribute.</p>
<p>It is also possible to enable GC for custom classes using the <code>gc</code> parameter of the <code>pyclass</code> attribute.
i.e. <code>#[pyclass(gc)]</code>. In that case instances of custom class participate in Python garbage
collection, and it is possible to track them with <code>gc</code> module methods. When using the <code>gc</code> parameter,
it is <em>required</em> to implement the <code>PyGCProtocol</code> trait, failure to do so will result in an error
at compile time:</p>
<pre><code class="language-compile_fail">#[pyclass(gc)]
struct GCTracked {} // Fails because it does not implement PyGCProtocol
</code></pre>
<h3 id="iterator-types"><a class="header" href="#iterator-types">Iterator Types</a></h3>
<p>Iterators can be defined using the
<a href="https://docs.rs/pyo3/0.14.4/pyo3/class/iter/trait.PyIterProtocol.html"><code>PyIterProtocol</code></a> trait.
It includes two methods <code>__iter__</code> and <code>__next__</code>:</p>
<ul>
<li><code>fn __iter__(slf: PyRefMut&lt;Self&gt;) -&gt; PyResult&lt;impl IntoPy&lt;PyObject&gt;&gt;</code></li>
<li><code>fn __next__(slf: PyRefMut&lt;Self&gt;) -&gt; PyResult&lt;Option&lt;impl IntoPy&lt;PyObject&gt;&gt;&gt;</code></li>
</ul>
<p>Returning <code>None</code> from <code>__next__</code> indicates that that there are no further items.
These two methods can be take either <code>PyRef&lt;Self&gt;</code> or <code>PyRefMut&lt;Self&gt;</code> as their
first argument, so that mutable borrow can be avoided if needed.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::PyIterProtocol;

#[pyclass]
struct MyIterator {
    iter: Box&lt;Iterator&lt;Item = PyObject&gt; + Send&gt;,
}

#[pyproto]
impl PyIterProtocol for MyIterator {
    fn __iter__(slf: PyRef&lt;Self&gt;) -&gt; PyRef&lt;Self&gt; {
        slf
    }
    fn __next__(mut slf: PyRefMut&lt;Self&gt;) -&gt; Option&lt;PyObject&gt; {
        slf.iter.next()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In many cases you'll have a distinction between the type being iterated over (i.e. the <em>iterable</em>) and the iterator it
provides. In this case, you should implement <code>PyIterProtocol</code> for both the iterable and the iterator, but the iterable
only needs to support <code>__iter__()</code> while the iterator must support both <code>__iter__()</code> and <code>__next__()</code>. The default
implementations in <code>PyIterProtocol</code> will ensure that the objects behave correctly in Python. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::PyIterProtocol;
</span>
#[pyclass]
struct Iter {
    inner: std::vec::IntoIter&lt;usize&gt;,
}

#[pyproto]
impl PyIterProtocol for Iter {
    fn __iter__(slf: PyRef&lt;Self&gt;) -&gt; PyRef&lt;Self&gt; {
        slf
    }

    fn __next__(mut slf: PyRefMut&lt;Self&gt;) -&gt; Option&lt;usize&gt; {
        slf.inner.next()
    }
}

#[pyclass]
struct Container {
    iter: Vec&lt;usize&gt;,
}

#[pyproto]
impl PyIterProtocol for Container {
    fn __iter__(slf: PyRef&lt;Self&gt;) -&gt; PyResult&lt;Py&lt;Iter&gt;&gt; {
        let iter = Iter {
            inner: slf.iter.clone().into_iter(),
        };
        Py::new(slf.py(), iter)
    }
}

<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let container = Container { iter: vec![1, 2, 3, 4] };
</span><span class="boring">    let inst = pyo3::PyCell::new(py, container).unwrap();
</span><span class="boring">    pyo3::py_run!(py, inst, &quot;assert list(inst) == [1, 2, 3, 4]&quot;);
</span><span class="boring">    pyo3::py_run!(py, inst, &quot;assert list(iter(iter(inst))) == [1, 2, 3, 4]&quot;);
</span><span class="boring">});
</span><span class="boring">}
</span></code></pre></pre>
<p>For more details on Python's iteration protocols, check out <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types">the &quot;Iterator Types&quot; section of the library
documentation</a>.</p>
<h4 id="returning-a-value-from-iteration"><a class="header" href="#returning-a-value-from-iteration">Returning a value from iteration</a></h4>
<p>This guide has so far shown how to use <code>Option&lt;T&gt;</code> to implement yielding values during iteration.
In Python a generator can also return a value. To express this in Rust, PyO3 provides the
<a href="https://docs.rs/pyo3/0.14.4/pyo3/class/iter/enum.IterNextOutput.html"><code>IterNextOutput</code></a> enum to
both <code>Yield</code> values and <code>Return</code> a final value - see its docs for further details and an example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-conversions"><a class="header" href="#type-conversions">Type Conversions</a></h1>
<p>In this portion of the guide we'll talk about the mapping of Python types to Rust types offered by PyO3, as well as the traits available to perform conversions between them.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mapping-of-rust-types-to-python-types"><a class="header" href="#mapping-of-rust-types-to-python-types">Mapping of Rust types to Python types</a></h2>
<p>When writing functions callable from Python (such as a <code>#[pyfunction]</code> or in a <code>#[pymethods]</code> block), the trait <code>FromPyObject</code> is required for function arguments, and <code>IntoPy&lt;PyObject&gt;</code> is required for function return values.</p>
<p>Consult the tables in the following section to find the Rust types provided by PyO3 which implement these traits.</p>
<h3 id="argument-types"><a class="header" href="#argument-types">Argument Types</a></h3>
<p>When accepting a function argument, it is possible to either use Rust library types or PyO3's Python-native types. (See the next section for discussion on when to use each.)</p>
<p>The table below contains the Python type and the corresponding function argument types that will accept them:</p>
<table><thead><tr><th>Python</th><th align="center">Rust</th><th align="center">Rust (Python-native)</th></tr></thead><tbody>
<tr><td><code>object</code></td><td align="center">-</td><td align="center"><code>&amp;PyAny</code></td></tr>
<tr><td><code>str</code></td><td align="center"><code>String</code>, <code>Cow&lt;str&gt;</code>, <code>&amp;str</code>, <code>OsString</code>, <code>PathBuf</code></td><td align="center"><code>&amp;PyUnicode</code></td></tr>
<tr><td><code>bytes</code></td><td align="center"><code>Vec&lt;u8&gt;</code>, <code>&amp;[u8]</code></td><td align="center"><code>&amp;PyBytes</code></td></tr>
<tr><td><code>bool</code></td><td align="center"><code>bool</code></td><td align="center"><code>&amp;PyBool</code></td></tr>
<tr><td><code>int</code></td><td align="center">Any integer type (<code>i32</code>, <code>u32</code>, <code>usize</code>, etc)</td><td align="center"><code>&amp;PyLong</code></td></tr>
<tr><td><code>float</code></td><td align="center"><code>f32</code>, <code>f64</code></td><td align="center"><code>&amp;PyFloat</code></td></tr>
<tr><td><code>complex</code></td><td align="center"><code>num_complex::Complex</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td align="center"><code>&amp;PyComplex</code></td></tr>
<tr><td><code>list[T]</code></td><td align="center"><code>Vec&lt;T&gt;</code></td><td align="center"><code>&amp;PyList</code></td></tr>
<tr><td><code>dict[K, V]</code></td><td align="center"><code>HashMap&lt;K, V&gt;</code>, <code>BTreeMap&lt;K, V&gt;</code>, <code>hashbrown::HashMap&lt;K, V&gt;</code><sup class="footnote-reference"><a href="#2">2</a></sup>, <code>indexmap::IndexMap&lt;K, V&gt;</code><sup class="footnote-reference"><a href="#3">3</a></sup></td><td align="center"><code>&amp;PyDict</code></td></tr>
<tr><td><code>tuple[T, U]</code></td><td align="center"><code>(T, U)</code>, <code>Vec&lt;T&gt;</code></td><td align="center"><code>&amp;PyTuple</code></td></tr>
<tr><td><code>set[T]</code></td><td align="center"><code>HashSet&lt;T&gt;</code>, <code>BTreeSet&lt;T&gt;</code>, <code>hashbrown::HashSet&lt;T&gt;</code><sup class="footnote-reference"><a href="#2">2</a></sup></td><td align="center"><code>&amp;PySet</code></td></tr>
<tr><td><code>frozenset[T]</code></td><td align="center"><code>HashSet&lt;T&gt;</code>, <code>BTreeSet&lt;T&gt;</code>, <code>hashbrown::HashSet&lt;T&gt;</code><sup class="footnote-reference"><a href="#2">2</a></sup></td><td align="center"><code>&amp;PyFrozenSet</code></td></tr>
<tr><td><code>bytearray</code></td><td align="center"><code>Vec&lt;u8&gt;</code></td><td align="center"><code>&amp;PyByteArray</code></td></tr>
<tr><td><code>slice</code></td><td align="center">-</td><td align="center"><code>&amp;PySlice</code></td></tr>
<tr><td><code>type</code></td><td align="center">-</td><td align="center"><code>&amp;PyType</code></td></tr>
<tr><td><code>module</code></td><td align="center">-</td><td align="center"><code>&amp;PyModule</code></td></tr>
<tr><td><code>datetime.datetime</code></td><td align="center">-</td><td align="center"><code>&amp;PyDateTime</code></td></tr>
<tr><td><code>datetime.date</code></td><td align="center">-</td><td align="center"><code>&amp;PyDate</code></td></tr>
<tr><td><code>datetime.time</code></td><td align="center">-</td><td align="center"><code>&amp;PyTime</code></td></tr>
<tr><td><code>datetime.tzinfo</code></td><td align="center">-</td><td align="center"><code>&amp;PyTzInfo</code></td></tr>
<tr><td><code>datetime.timedelta</code></td><td align="center">-</td><td align="center"><code>&amp;PyDelta</code></td></tr>
<tr><td><code>typing.Optional[T]</code></td><td align="center"><code>Option&lt;T&gt;</code></td><td align="center">-</td></tr>
<tr><td><code>typing.Sequence[T]</code></td><td align="center"><code>Vec&lt;T&gt;</code></td><td align="center"><code>&amp;PySequence</code></td></tr>
<tr><td><code>typing.Iterator[Any]</code></td><td align="center">-</td><td align="center"><code>&amp;PyIterator</code></td></tr>
<tr><td><code>typing.Union[...]</code></td><td align="center">See <a href="conversions/traits.html#deriving-a-hrefhttpsdocsrspyo3latestpyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-enums"><code>#[derive(FromPyObject)]</code></a></td><td align="center">-</td></tr>
</tbody></table>
<p>There are also a few special types related to the GIL and Rust-defined <code>#[pyclass]</code>es which may come in useful:</p>
<table><thead><tr><th>What</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Python</code></td><td>A GIL token, used to pass to PyO3 constructors to prove ownership of the GIL</td></tr>
<tr><td><code>Py&lt;T&gt;</code></td><td>A Python object isolated from the GIL lifetime. This can be sent to other threads.</td></tr>
<tr><td><code>PyObject</code></td><td>An alias for <code>Py&lt;PyAny&gt;</code></td></tr>
<tr><td><code>&amp;PyCell&lt;T&gt;</code></td><td>A <code>#[pyclass]</code> value owned by Python.</td></tr>
<tr><td><code>PyRef&lt;T&gt;</code></td><td>A <code>#[pyclass]</code> borrowed immutably.</td></tr>
<tr><td><code>PyRefMut&lt;T&gt;</code></td><td>A <code>#[pyclass]</code> borrowed mutably.</td></tr>
</tbody></table>
<p>For more detail on accepting <code>#[pyclass]</code> values as function arguments, see <a href="conversions/../class.html">the section of this guide on Python Classes</a>.</p>
<h4 id="using-rust-library-types-vs-python-native-types"><a class="header" href="#using-rust-library-types-vs-python-native-types">Using Rust library types vs Python-native types</a></h4>
<p>Using Rust library types as function arguments will incur a conversion cost compared to using the Python-native types. Using the Python-native types is almost zero-cost (they just require a type check similar to the Python builtin function <code>isinstance()</code>).</p>
<p>However, once that conversion cost has been paid, the Rust standard library types offer a number of benefits:</p>
<ul>
<li>You can write functionality in native-speed Rust code (free of Python's runtime costs).</li>
<li>You get better interoperability with the rest of the Rust ecosystem.</li>
<li>You can use <code>Python::allow_threads</code> to release the Python GIL and let other Python threads make progress while your Rust code is executing.</li>
<li>You also benefit from stricter type checking. For example you can specify <code>Vec&lt;i32&gt;</code>, which will only accept a Python <code>list</code> containing integers. The Python-native equivalent, <code>&amp;PyList</code>, would accept a Python <code>list</code> containing Python objects of any type.</li>
</ul>
<p>For most PyO3 usage the conversion cost is worth paying to get these benefits. As always, if you're not sure it's worth it in your case, benchmark it!</p>
<h3 id="returning-rust-values-to-python"><a class="header" href="#returning-rust-values-to-python">Returning Rust values to Python</a></h3>
<p>When returning values from functions callable from Python, Python-native types (<code>&amp;PyAny</code>, <code>&amp;PyDict</code> etc.) can be used with zero cost.</p>
<p>Because these types are references, in some situations the Rust compiler may ask for lifetime annotations. If this is the case, you should use <code>Py&lt;PyAny&gt;</code>, <code>Py&lt;PyDict&gt;</code> etc. instead - which are also zero-cost. For all of these Python-native types <code>T</code>, <code>Py&lt;T&gt;</code> can be created from <code>T</code> with an <code>.into()</code> conversion.</p>
<p>If your function is fallible, it should return <code>PyResult&lt;T&gt;</code> or <code>Result&lt;T, E&gt;</code> where <code>E</code> implements <code>From&lt;E&gt; for PyErr</code>. This will raise a <code>Python</code> exception if the <code>Err</code> variant is returned.</p>
<p>Finally, the following Rust types are also able to convert to Python as return values:</p>
<table><thead><tr><th>Rust type</th><th align="center">Resulting Python Type</th></tr></thead><tbody>
<tr><td><code>String</code></td><td align="center"><code>str</code></td></tr>
<tr><td><code>&amp;str</code></td><td align="center"><code>str</code></td></tr>
<tr><td><code>bool</code></td><td align="center"><code>bool</code></td></tr>
<tr><td>Any integer type (<code>i32</code>, <code>u32</code>, <code>usize</code>, etc)</td><td align="center"><code>int</code></td></tr>
<tr><td><code>f32</code>, <code>f64</code></td><td align="center"><code>float</code></td></tr>
<tr><td><code>Option&lt;T&gt;</code></td><td align="center"><code>Optional[T]</code></td></tr>
<tr><td><code>(T, U)</code></td><td align="center"><code>Tuple[T, U]</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td align="center"><code>List[T]</code></td></tr>
<tr><td><code>HashMap&lt;K, V&gt;</code></td><td align="center"><code>Dict[K, V]</code></td></tr>
<tr><td><code>BTreeMap&lt;K, V&gt;</code></td><td align="center"><code>Dict[K, V]</code></td></tr>
<tr><td><code>HashSet&lt;T&gt;</code></td><td align="center"><code>Set[T]</code></td></tr>
<tr><td><code>BTreeSet&lt;T&gt;</code></td><td align="center"><code>Set[T]</code></td></tr>
<tr><td><code>&amp;PyCell&lt;T: PyClass&gt;</code></td><td align="center"><code>T</code></td></tr>
<tr><td><code>PyRef&lt;T: PyClass&gt;</code></td><td align="center"><code>T</code></td></tr>
<tr><td><code>PyRefMut&lt;T: PyClass&gt;</code></td><td align="center"><code>T</code></td></tr>
</tbody></table>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Requires the <code>num-complex</code> optional feature.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Requires the <code>hashbrown</code> optional feature.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Requires the <code>indexmap</code> optional feature.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="conversion-traits"><a class="header" href="#conversion-traits">Conversion traits</a></h2>
<p>PyO3 provides some handy traits to convert between Python types and Rust types.</p>
<h3 id="extract-and-the-frompyobject-trait"><a class="header" href="#extract-and-the-frompyobject-trait"><code>.extract()</code> and the <code>FromPyObject</code> trait</a></h3>
<p>The easiest way to convert a Python object to a Rust value is using
<code>.extract()</code>.  It returns a <code>PyResult</code> with a type error if the conversion
fails, so usually you will use something like</p>
<pre><code class="language-ignore">let v: Vec&lt;i32&gt; = obj.extract()?;
</code></pre>
<p>This method is available for many Python object types, and can produce a wide
variety of Rust types, which you can check out in the implementor list of
<a href="https://docs.rs/pyo3/0.14.4/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a>.</p>
<p><a href="https://docs.rs/pyo3/0.14.4/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> is also implemented for your own Rust types wrapped as Python
objects (see <a href="conversions/class.html">the chapter about classes</a>).  There, in order to both be
able to operate on mutable references <em>and</em> satisfy Rust's rules of non-aliasing
mutable references, you have to extract the PyO3 reference wrappers <a href="https://docs.rs/pyo3/0.14.4/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a>
and <a href="https://docs.rs/pyo3/0.14.4/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a>.  They work like the reference wrappers of
<code>std::cell::RefCell</code> and ensure (at runtime) that Rust borrows are allowed.</p>
<h4 id="deriving-a-hrefhttpsdocsrspyo30144pyo3conversiontraitfrompyobjecthtmlfrompyobjecta"><a class="header" href="#deriving-a-hrefhttpsdocsrspyo30144pyo3conversiontraitfrompyobjecthtmlfrompyobjecta">Deriving <a href="https://docs.rs/pyo3/0.14.4/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a></a></h4>
<p><a href="https://docs.rs/pyo3/0.14.4/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> can be automatically derived for many kinds of structs and enums
if the member types themselves implement <code>FromPyObject</code>. This even includes members
with a generic type <code>T: FromPyObject</code>. Derivation for empty enums, enum variants and
structs is not supported.</p>
<h4 id="deriving-a-hrefhttpsdocsrspyo30144pyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-structs"><a class="header" href="#deriving-a-hrefhttpsdocsrspyo30144pyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-structs">Deriving <a href="https://docs.rs/pyo3/0.14.4/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for structs</a></h4>
<pre><code>use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyStruct {
    my_string: String,
}
</code></pre>
<p>The derivation generates code that will per default access the attribute <code>my_string</code> on
the Python object, i.e. <code>obj.getattr(&quot;my_string&quot;)</code>, and call <code>extract()</code> on the attribute.
It is also possible to access the value on the Python object through <code>obj.get_item(&quot;my_string&quot;)</code>
by setting the attribute <code>pyo3(item)</code> on the field:</p>
<pre><code>use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyStruct {
    #[pyo3(item)]
    my_string: String,
}
</code></pre>
<p>The argument passed to <code>getattr</code> and <code>get_item</code> can also be configured:</p>
<pre><code>use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyStruct {
    #[pyo3(item(&quot;key&quot;))]
    string_in_mapping: String,
    #[pyo3(attribute(&quot;name&quot;))]
    string_attr: String,
}
</code></pre>
<p>This tries to extract <code>string_attr</code> from the attribute <code>name</code> and <code>string_in_mapping</code>
from a mapping with the key <code>&quot;key&quot;</code>. The arguments for <code>attribute</code> are restricted to
non-empty string literals while <code>item</code> can take any valid literal that implements
<code>ToBorrowedObject</code>.</p>
<h4 id="deriving-a-hrefhttpsdocsrspyo30144pyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-tuple-structs"><a class="header" href="#deriving-a-hrefhttpsdocsrspyo30144pyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-tuple-structs">Deriving <a href="https://docs.rs/pyo3/0.14.4/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for tuple structs</a></h4>
<p>Tuple structs are also supported but do not allow customizing the extraction. The input is
always assumed to be a Python tuple with the same length as the Rust type, the <code>n</code>th field
is extracted from the <code>n</code>th item in the Python tuple.</p>
<pre><code>use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyTuple(String, String);
</code></pre>
<p>Tuple structs with a single field are treated as wrapper types which are described in the
following section. To override this behaviour and ensure that the input is in fact a tuple,
specify the struct as</p>
<pre><code>use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyTuple((String,));
</code></pre>
<h4 id="deriving-a-hrefhttpsdocsrspyo30144pyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-wrapper-types"><a class="header" href="#deriving-a-hrefhttpsdocsrspyo30144pyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-wrapper-types">Deriving <a href="https://docs.rs/pyo3/0.14.4/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for wrapper types</a></h4>
<p>The <code>pyo3(transparent)</code> attribute can be used on structs with exactly one field. This results
in extracting directly from the input object, i.e. <code>obj.extract()</code>, rather than trying to access
an item or attribute. This behaviour is enabled per default for newtype structs and tuple-variants
with a single field.</p>
<pre><code>use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyTransparentTupleStruct(String);

#[derive(FromPyObject)]
#[pyo3(transparent)]
struct RustyTransparentStruct {
    inner: String,
}
</code></pre>
<h4 id="deriving-a-hrefhttpsdocsrspyo30144pyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-enums"><a class="header" href="#deriving-a-hrefhttpsdocsrspyo30144pyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-enums">Deriving <a href="https://docs.rs/pyo3/0.14.4/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for enums</a></h4>
<p>The <code>FromPyObject</code> derivation for enums generates code that tries to extract the variants in the
order of the fields. As soon as a variant can be extracted succesfully, that variant is returned.
This makes it possible to extract Python types like <code>Union[str, int]</code>.</p>
<p>The same customizations and restrictions described for struct derivations apply to enum variants,
i.e. a tuple variant assumes that the input is a Python tuple, and a struct variant defaults to
extracting fields as attributes but can be configured in the same manner. The <code>transparent</code>
attribute can be applied to single-field-variants.</p>
<pre><code>use pyo3::prelude::*;

#[derive(FromPyObject)]
enum RustyEnum&lt;'a&gt; {
    Int(usize), // input is a positive int
    String(String), // input is a string
    IntTuple(usize, usize), // input is a 2-tuple with positive ints
    StringIntTuple(String, usize), // input is a 2-tuple with String and int
    Coordinates3d { // needs to be in front of 2d
        x: usize,
        y: usize,
        z: usize,
    },
    Coordinates2d { // only gets checked if the input did not have `z`
        #[pyo3(attribute(&quot;x&quot;))]
        a: usize,
        #[pyo3(attribute(&quot;y&quot;))]
        b: usize,
    },
    #[pyo3(transparent)]
    CatchAll(&amp;'a PyAny), // This extraction never fails
}
</code></pre>
<p>If none of the enum variants match, a <code>PyValueError</code> containing the names of the
tested variants is returned. The names reported in the error message can be customized
through the <code>pyo3(annotation = &quot;name&quot;)</code> attribute, e.g. to use conventional Python type
names:</p>
<pre><code>use pyo3::prelude::*;

#[derive(FromPyObject)]
enum RustyEnum {
    #[pyo3(transparent, annotation = &quot;str&quot;)]
    String(String),
    #[pyo3(transparent, annotation = &quot;int&quot;)]
    Int(isize),
}
</code></pre>
<p>If the input is neither a string nor an integer, the error message will be:
<code>&quot;'&lt;INPUT_TYPE&gt;' cannot be converted to 'Union[str, int]'&quot;</code>.</p>
<h4 id="derivefrompyobject-container-attributes"><a class="header" href="#derivefrompyobject-container-attributes"><code>#[derive(FromPyObject)]</code> Container Attributes</a></h4>
<ul>
<li><code>pyo3(transparent)</code>
<ul>
<li>extract the field directly from the object as <code>obj.extract()</code> instead of <code>get_item()</code> or
<code>getattr()</code></li>
<li>Newtype structs and tuple-variants are treated as transparent per default.</li>
<li>only supported for single-field structs and enum variants</li>
</ul>
</li>
<li><code>pyo3(annotation = &quot;name&quot;)</code>
<ul>
<li>changes the name of the failed variant in the generated error message in case of failure.</li>
<li>e.g. <code>pyo3(&quot;int&quot;)</code> reports the variant's type as <code>int</code>.</li>
<li>only supported for enum variants</li>
</ul>
</li>
</ul>
<h4 id="derivefrompyobject-field-attributes"><a class="header" href="#derivefrompyobject-field-attributes"><code>#[derive(FromPyObject)]</code> Field Attributes</a></h4>
<ul>
<li><code>pyo3(attribute)</code>, <code>pyo3(attribute(&quot;name&quot;))</code>
<ul>
<li>retrieve the field from an attribute, possibly with a custom name specified as an argument</li>
<li>argument must be a string-literal.</li>
</ul>
</li>
<li><code>pyo3(item)</code>, <code>pyo3(item(&quot;key&quot;))</code>
<ul>
<li>retrieve the field from a mapping, possibly with the custom key specified as an argument.</li>
<li>can be any literal that implements <code>ToBorrowedObject</code></li>
</ul>
</li>
</ul>
<h3 id="intopyt"><a class="header" href="#intopyt"><code>IntoPy&lt;T&gt;</code></a></h3>
<p>This trait defines the to-python conversion for a Rust type. It is usually implemented as
<code>IntoPy&lt;PyObject&gt;</code>, which is the trait needed for returning a value from <code>#[pyfunction]</code> and
<code>#[pymethods]</code>.</p>
<p>All types in PyO3 implement this trait, as does a <code>#[pyclass]</code> which doesn't use <code>extends</code>.</p>
<p>Occasionally you may choose to implement this for custom types which are mapped to Python types
<em>without</em> having a unique python type.</p>
<pre><code>use pyo3::prelude::*;

struct MyPyObjectWrapper(PyObject);

impl IntoPy&lt;PyObject&gt; for MyPyObjectWrapper {
    fn into_py(self, py: Python) -&gt; PyObject {
        self.0
    }
}
</code></pre>
<h3 id="the-topyobject-trait"><a class="header" href="#the-topyobject-trait">The <code>ToPyObject</code> trait</a></h3>
<p><a href="https://docs.rs/pyo3/0.14.4/pyo3/conversion/trait.ToPyObject.html"><code>ToPyObject</code></a> is a conversion trait that allows various objects to be
converted into <a href="https://docs.rs/pyo3/0.14.4/pyo3/type.PyObject.html"><code>PyObject</code></a>. <code>IntoPy&lt;PyObject&gt;</code> serves the
same purpose, except that it consumes <code>self</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-exceptions"><a class="header" href="#python-exceptions">Python Exceptions</a></h1>
<h2 id="defining-a-new-exception"><a class="header" href="#defining-a-new-exception">Defining a new exception</a></h2>
<p>You can use the <a href="https://docs.rs/pyo3/0.14.4/pyo3/macro.create_exception.html"><code>create_exception!</code></a> macro to define a new exception type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::create_exception;

create_exception!(module, MyError, pyo3::exceptions::PyException);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>module</code> is the name of the containing module.</li>
<li><code>MyError</code> is the name of the new exception type.</li>
</ul>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::create_exception;
use pyo3::types::IntoPyDict;
use pyo3::exceptions::PyException;

create_exception!(mymodule, CustomError, PyException);

Python::with_gil(|py| {
    let ctx = [(&quot;CustomError&quot;, py.get_type::&lt;CustomError&gt;())].into_py_dict(py);
    pyo3::py_run!(py, *ctx, &quot;assert str(CustomError) == \&quot;&lt;class 'mymodule.CustomError'&gt;\&quot;&quot;);
    pyo3::py_run!(py, *ctx, &quot;assert CustomError('oops').args == ('oops',)&quot;);
});
<span class="boring">}
</span></code></pre></pre>
<p>When using PyO3 to create an extension module, you can add the new exception to
the module like this, so that it is importable from Python:</p>
<pre><code class="language-rust ignore">
create_exception!(mymodule, CustomError, PyException);

#[pymodule]
fn mymodule(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    // ... other elements added to module ...
    m.add(&quot;CustomError&quot;, py.get_type::&lt;CustomError&gt;())?;

    Ok(())
}

</code></pre>
<h2 id="raising-an-exception"><a class="header" href="#raising-an-exception">Raising an exception</a></h2>
<p>To raise an exception, first you need to obtain an exception type and construct a new <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.PyErr.html"><code>PyErr</code></a>, then call the <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.PyErr.html#method.restore"><code>PyErr::restore</code></a> method to write the exception back to the Python interpreter's global state.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::{Python, PyErr};
use pyo3::exceptions::PyTypeError;

Python::with_gil(|py| {
    PyTypeError::new_err(&quot;Error&quot;).restore(py);
    assert!(PyErr::occurred(py));
    drop(PyErr::fetch(py));
});
<span class="boring">}
</span></code></pre></pre>
<p>From <code>pyfunction</code>s and <code>pyclass</code> methods, returning an <code>Err(PyErr)</code> is enough;
PyO3 will handle restoring the exception on the Python interpreter side.</p>
<p>If you already have a Python exception instance, you can simply call <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.PyErr.html#method.from_instance"><code>PyErr::from_instance</code></a>.</p>
<pre><code class="language-rust ignore">PyErr::from_instance(py, err).restore(py);
</code></pre>
<p>If a Rust type exists for the exception, then it is possible to use the <code>new_err</code> method.
For example, each standard exception defined in the <code>pyo3::exceptions</code> module
has a corresponding Rust type, exceptions defined by <a href="https://docs.rs/pyo3/0.14.4/pyo3/macro.create_exception.html"><code>create_exception!</code></a> and <a href="https://docs.rs/pyo3/0.14.4/pyo3/macro.import_exception.html"><code>import_exception!</code></a> macro
have Rust types as well.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::exceptions::PyValueError;
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">fn check_for_error() -&gt; bool {false}
</span>fn my_func(arg: PyObject) -&gt; PyResult&lt;()&gt; {
    if check_for_error() {
        Err(PyValueError::new_err(&quot;argument is wrong&quot;))
    } else {
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="checking-exception-types"><a class="header" href="#checking-exception-types">Checking exception types</a></h2>
<p>Python has an <a href="https://docs.python.org/3/library/functions.html#isinstance"><code>isinstance</code></a> method to check an object's type.
In PyO3 every native type has access to the <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.PyAny.html#method.is_instance"><code>PyAny::is_instance</code></a> method which does the same thing.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::Python;
use pyo3::types::{PyBool, PyList};

Python::with_gil(|py| {
    assert!(PyBool::new(py, true).is_instance::&lt;PyBool&gt;().unwrap());
    let list = PyList::new(py, &amp;[1, 2, 3, 4]);
    assert!(!list.is_instance::&lt;PyBool&gt;().unwrap());
    assert!(list.is_instance::&lt;PyList&gt;().unwrap());
});
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.PyAny.html#method.is_instance"><code>PyAny::is_instance</code></a> calls the underlying <a href="https://docs.rs/pyo3/0.14.4/pyo3/types/struct.PyType.html#method.is_instance"><code>PyType::is_instance</code></a>
method to do the actual work.</p>
<p>To check the type of an exception, you can similarly do:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::exceptions::PyTypeError;
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">Python::with_gil(|py| {
</span><span class="boring">let err = PyTypeError::new_err(());
</span>err.is_instance::&lt;PyTypeError&gt;(py);
<span class="boring">});
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="handling-rust-errors"><a class="header" href="#handling-rust-errors">Handling Rust errors</a></h2>
<p>The vast majority of operations in this library will return
<a href="https://docs.rs/pyo3/0.14.4/pyo3/prelude/type.PyResult.html"><code>PyResult&lt;T&gt;</code></a>,
which is an alias for the type <code>Result&lt;T, PyErr&gt;</code>.</p>
<p>A <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.PyErr.html"><code>PyErr</code></a> represents a Python exception. Errors within the PyO3 library are also exposed as
Python exceptions.</p>
<p>If your code has a custom error type e.g. <code>MyError</code>, adding an implementation of
<code>std::convert::From&lt;MyError&gt; for PyErr</code> is usually enough. PyO3 will then automatically convert
your error to a Python exception when needed.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::exceptions::PyOSError;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct CustomIOError;
</span><span class="boring">
</span><span class="boring">impl Error for CustomIOError {}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for CustomIOError {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
</span><span class="boring">        write!(f, &quot;Oh no!&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bind(_addr: &amp;str) -&gt; Result&lt;(), CustomIOError&gt; {
</span><span class="boring">    Err(CustomIOError)
</span><span class="boring">}
</span>impl std::convert::From&lt;CustomIOError&gt; for PyErr {
    fn from(err: CustomIOError) -&gt; PyErr {
        PyOSError::new_err(err.to_string())
    }
}

#[pyfunction]
fn connect(s: String) -&gt; Result&lt;bool, CustomIOError&gt; {
    bind(&quot;127.0.0.1:80&quot;)?;
    Ok(true)
}
<span class="boring">}
</span></code></pre></pre>
<p>The code snippet above will raise an <code>OSError</code> in Python if <code>bind()</code> returns a <code>CustomIOError</code>.</p>
<p>The <code>std::convert::From&lt;T&gt;</code> trait is implemented for most of the Rust standard library's error
types so the <code>?</code> operator can be used.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

fn parse_int(s: String) -&gt; PyResult&lt;usize&gt; {
    Ok(s.parse::&lt;usize&gt;()?)
}
<span class="boring">}
</span></code></pre></pre>
<p>The code snippet above will raise a <code>ValueError</code> in Python if <code>String::parse()</code> returns an error.</p>
<p>If lazy construction of the Python exception instance is desired, the
<a href="https://docs.rs/pyo3/0.14.4/pyo3/trait.PyErrArguments.html"><code>PyErrArguments</code></a>
trait can be implemented. In that case, actual exception argument creation is delayed
until the <code>PyErr</code> is needed.</p>
<h2 id="using-exceptions-defined-in-python-code"><a class="header" href="#using-exceptions-defined-in-python-code">Using exceptions defined in Python code</a></h2>
<p>It is possible to use an exception defined in Python code as a native Rust type.
The <code>import_exception!</code> macro allows importing a specific exception class and defines a Rust type
for that exception.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

mod io {
    pyo3::import_exception!(io, UnsupportedOperation);
}

fn tell(file: &amp;PyAny) -&gt; PyResult&lt;u64&gt; {
    use pyo3::exceptions::*;

    match file.call_method0(&quot;tell&quot;) {
        Err(_) =&gt; Err(io::UnsupportedOperation::new_err(&quot;not supported: tell&quot;)),
        Ok(x) =&gt; x.extract::&lt;u64&gt;(),
    }
}

<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/pyo3/0.14.4/pyo3/exceptions/index.html"><code>pyo3::exceptions</code></a>
defines exceptions for several standard library modules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-python-in-rust-code"><a class="header" href="#calling-python-in-rust-code">Calling Python in Rust code</a></h1>
<p>This chapter of the guide documents some ways to interact with Python code from Rust:</p>
<ul>
<li>How to call Python functions</li>
<li>How to execute existing Python code</li>
</ul>
<h2 id="calling-python-functions"><a class="header" href="#calling-python-functions">Calling Python functions</a></h2>
<p>Any Python-native object reference (such as <code>&amp;PyAny</code>, <code>&amp;PyList</code>, or <code>&amp;PyCell&lt;MyClass&gt;</code>) can be used to call Python functions.</p>
<p>PyO3 offers two APIs to make function calls:</p>
<ul>
<li><a href="https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call"><code>call</code></a> - call any callable Python object.</li>
<li><a href="https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call_method"><code>call_method</code></a> - call a method on the Python object.</li>
</ul>
<p>Both of these APIs take <code>args</code> and <code>kwargs</code> arguments (for positional and keyword arguments respectively). There are variants for less complex calls:</p>
<ul>
<li><a href="https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call1"><code>call1</code></a> and <a href="https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call_method1"><code>call_method1</code></a> to call only with positional <code>args</code>.</li>
<li><a href="https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call0"><code>call0</code></a> and <a href="https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call_method0"><code>call_method0</code></a> to call with no arguments.</li>
</ul>
<p>For convenience the <a href="types.html#pyt-and-pyobject"><code>Py&lt;T&gt;</code></a> smart pointer also exposes these same six API methods, but needs a <code>Python</code> token as an additional first argument to prove the GIL is held.</p>
<p>The example below shows a calling Python functions behind a <code>PyObject</code> (aka <code>Py&lt;PyAny&gt;</code>) reference:</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::{PyDict, PyTuple};

struct SomeObject;
impl SomeObject {
    fn new(py: Python) -&gt; PyObject {
        PyDict::new(py).to_object(py)
    }
}

fn main() {
    let arg1 = &quot;arg1&quot;;
    let arg2 = &quot;arg2&quot;;
    let arg3 = &quot;arg3&quot;;

    Python::with_gil(|py| {
        let obj = SomeObject::new(py);

        // call object without empty arguments
        obj.call0(py);

        // call object with PyTuple
        let args = PyTuple::new(py, &amp;[arg1, arg2, arg3]);
        obj.call1(py, args);

        // pass arguments as rust tuple
        let args = (arg1, arg2, arg3);
        obj.call1(py, args);
    });
}
</code></pre></pre>
<h3 id="creating-keyword-arguments"><a class="header" href="#creating-keyword-arguments">Creating keyword arguments</a></h3>
<p>For the <code>call</code> and <code>call_method</code> APIs, <code>kwargs</code> can be <code>None</code> or <code>Some(&amp;PyDict)</code>. You can use the <a href="https://docs.rs/pyo3/0.14.4/pyo3/types/trait.IntoPyDict.html"><code>IntoPyDict</code></a> trait to convert other dict-like containers, e.g. <code>HashMap</code> or <code>BTreeMap</code>, as well as tuples with up to 10 elements and <code>Vec</code>s where each element is a two-element tuple.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::{IntoPyDict, PyDict};
use std::collections::HashMap;

struct SomeObject;

impl SomeObject {
    fn new(py: Python) -&gt; PyObject {
        PyDict::new(py).to_object(py)
    }
}

fn main() {
    let key1 = &quot;key1&quot;;
    let val1 = 1;
    let key2 = &quot;key2&quot;;
    let val2 = 2;

    Python::with_gil(|py| {
        let obj = SomeObject::new(py);

        // call object with PyDict
        let kwargs = [(key1, val1)].into_py_dict(py);
        obj.call(py, (), Some(kwargs));

        // pass arguments as Vec
        let kwargs = vec![(key1, val1), (key2, val2)];
        obj.call(py, (), Some(kwargs.into_py_dict(py)));

        // pass arguments as HashMap
        let mut kwargs = HashMap::&lt;&amp;str, i32&gt;::new();
        kwargs.insert(key1, 1);
        obj.call(py, (), Some(kwargs.into_py_dict(py)));
   });
}
</code></pre></pre>
<h2 id="executing-existing-python-code"><a class="header" href="#executing-existing-python-code">Executing existing Python code</a></h2>
<p>If you already have some existing Python code that you need to execute from Rust, the following FAQs can help you select the right PyO3 functionality for your situation:</p>
<h3 id="want-to-access-python-apis-then-use-pymoduleimport"><a class="header" href="#want-to-access-python-apis-then-use-pymoduleimport">Want to access Python APIs? Then use <code>PyModule::import</code>.</a></h3>
<p><a href="https://docs.rs/pyo3/0.14.4/pyo3/types/struct.PyModule.html#method.import"><code>Pymodule::import</code></a> can
be used to get handle to a Python module from Rust. You can use this to import and use any Python
module available in your environment.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

fn main() -&gt; PyResult&lt;()&gt; {
    Python::with_gil(|py| {
        let builtins = PyModule::import(py, &quot;builtins&quot;)?;
        let total: i32 = builtins.getattr(&quot;sum&quot;)?.call1((vec![1, 2, 3],))?.extract()?;
        assert_eq!(total, 6);
        Ok(())
    })
}
</code></pre></pre>
<h3 id="want-to-run-just-an-expression-then-use-eval"><a class="header" href="#want-to-run-just-an-expression-then-use-eval">Want to run just an expression? Then use <code>eval</code>.</a></h3>
<p><a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.Python.html#method.eval"><code>Python::eval</code></a> is
a method to execute a <a href="https://docs.python.org/3.7/reference/expressions.html">Python expression</a>
and return the evaluated value as a <code>&amp;PyAny</code> object.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::IntoPyDict;

<span class="boring">fn main() -&gt; Result&lt;(), ()&gt; {
</span>Python::with_gil(|py| {
    let result = py.eval(&quot;[i * 10 for i in range(5)]&quot;, None, None).map_err(|e| {
        e.print_and_set_sys_last_vars(py);
    })?;
    let res: Vec&lt;i64&gt; = result.extract().unwrap();
    assert_eq!(res, vec![0, 10, 20, 30, 40]);
    Ok(())
})
<span class="boring">}
</span></code></pre></pre>
<h3 id="want-to-run-statements-then-use-run"><a class="header" href="#want-to-run-statements-then-use-run">Want to run statements? Then use <code>run</code>.</a></h3>
<p><a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.Python.html#method.run"><code>Python::run</code></a> is a method to execute one or more
<a href="https://docs.python.org/3.7/reference/simple_stmts.html">Python statements</a>.
This method returns nothing (like any Python statement), but you can get
access to manipulated objects via the <code>locals</code> dict.</p>
<p>You can also use the <a href="https://docs.rs/pyo3/0.14.4/pyo3/macro.py_run.html"><code>py_run!</code></a> macro, which is a shorthand for <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.Python.html#method.run"><code>Python::run</code></a>.
Since <a href="https://docs.rs/pyo3/0.14.4/pyo3/macro.py_run.html"><code>py_run!</code></a> panics on exceptions, we recommend you use this macro only for
quickly testing your Python extensions.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;
use pyo3::{PyCell, PyObjectProtocol, py_run};

<span class="boring">fn main() {
</span>#[pyclass]
struct UserData {
    id: u32,
    name: String,
}

#[pymethods]
impl UserData {
    fn as_tuple(&amp;self) -&gt; (u32, String) {
        (self.id, self.name.clone())
    }
}

#[pyproto]
impl PyObjectProtocol for UserData {
    fn __repr__(&amp;self) -&gt; PyResult&lt;String&gt; {
        Ok(format!(&quot;User {}(id: {})&quot;, self.name, self.id))
    }
}

Python::with_gil(|py| {
    let userdata = UserData {
        id: 34,
        name: &quot;Yu&quot;.to_string(),
    };
    let userdata = PyCell::new(py, userdata).unwrap();
    let userdata_as_tuple = (34, &quot;Yu&quot;);
    py_run!(py, userdata userdata_as_tuple, r#&quot;
assert repr(userdata) == &quot;User Yu(id: 34)&quot;
assert userdata.as_tuple() == userdata_as_tuple
    &quot;#);
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="you-have-a-python-file-or-code-snippet-then-use-pymodulefrom_code"><a class="header" href="#you-have-a-python-file-or-code-snippet-then-use-pymodulefrom_code">You have a Python file or code snippet? Then use <code>PyModule::from_code</code>.</a></h2>
<p><a href="https://docs.rs/pyo3/0.14.4/pyo3/types/struct.PyModule.html#method.from_code">PyModule::from_code</a>
can be used to generate a Python module which can then be used just as if it was imported with
<code>PyModule::import</code>.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::{prelude::*, types::{IntoPyDict, PyModule}};

<span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| {
    let activators = PyModule::from_code(py, r#&quot;
def relu(x):
    &quot;&quot;&quot;see https://en.wikipedia.org/wiki/Rectifier_(neural_networks)&quot;&quot;&quot;
    return max(0.0, x)

def leaky_relu(x, slope=0.01):
    return x if x &gt;= 0 else x * slope
    &quot;#, &quot;activators.py&quot;, &quot;activators&quot;)?;

    let relu_result: f64 = activators.getattr(&quot;relu&quot;)?.call1((-1.0,))?.extract()?;
    assert_eq!(relu_result, 0.0);

    let kwargs = [(&quot;slope&quot;, 0.2)].into_py_dict(py);
    let lrelu_result: f64 = activators
        .getattr(&quot;leaky_relu&quot;)?.call((-1.0,), Some(kwargs))?
        .extract()?;
    assert_eq!(lrelu_result, -0.2);
<span class="boring">   Ok(())
</span>})
<span class="boring">}
</span></code></pre></pre>
<h2 id="need-to-use-a-context-manager-from-rust"><a class="header" href="#need-to-use-a-context-manager-from-rust">Need to use a context manager from Rust?</a></h2>
<p>Use context managers by directly invoking <code>__enter__</code> and <code>__exit__</code>.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::PyModule;

fn main() {
    Python::with_gil(|py| {
        let custom_manager = PyModule::from_code(py, r#&quot;
class House(object):
    def __init__(self, address):
        self.address = address
    def __enter__(self):
        print(f&quot;Welcome to {self.address}!&quot;)
    def __exit__(self, type, value, traceback):
        if type:
            print(f&quot;Sorry you had {type} trouble at {self.address}&quot;)
        else:
            print(f&quot;Thank you for visiting {self.address}, come again soon!&quot;)

        &quot;#, &quot;house.py&quot;, &quot;house&quot;).unwrap();

        let house_class = custom_manager.getattr(&quot;House&quot;).unwrap();
        let house = house_class.call1((&quot;123 Main Street&quot;,)).unwrap();

        house.call_method0(&quot;__enter__&quot;).unwrap();

        let result = py.eval(&quot;undefined_variable + 1&quot;, None, None);

        // If the eval threw an exception we'll pass it through to the context manager.
        // Otherwise, __exit__  is called with empty arguments (Python &quot;None&quot;).
        match result {
            Ok(_) =&gt; {
                let none = py.None();
                house.call_method1(&quot;__exit__&quot;, (&amp;none, &amp;none, &amp;none)).unwrap();
            },
            Err(e) =&gt; {
                house.call_method1(
                    &quot;__exit__&quot;,
                    (e.ptype(py), e.pvalue(py), e.ptraceback(py))
                ).unwrap();
            }
        }
    })
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gil-lifetimes-mutability-and-python-object-types"><a class="header" href="#gil-lifetimes-mutability-and-python-object-types">GIL lifetimes, mutability and Python object types</a></h1>
<p>On first glance, PyO3 provides a huge number of different types that can be used
to wrap or refer to Python objects.  This page delves into the details and gives
an overview of their intended meaning, with examples when each type is best
used.</p>
<h2 id="mutability-and-rust-types"><a class="header" href="#mutability-and-rust-types">Mutability and Rust types</a></h2>
<p>Since Python has no concept of ownership, and works solely with boxed objects,
any Python object can be referenced any number of times, and mutation is allowed
from any reference.</p>
<p>The situation is helped a little by the Global Interpreter Lock (GIL), which
ensures that only one thread can use the Python interpreter and its API at the
same time, while non-Python operations (system calls and extension code) can
unlock the GIL.  (See <a href="parallelism.html">the section on parallelism</a> for how to do
that in PyO3.)</p>
<p>In PyO3, holding the GIL is modeled by acquiring a token of the type
<code>Python&lt;'py&gt;</code>, which serves three purposes:</p>
<ul>
<li>It provides some global API for the Python interpreter, such as
<a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.Python.html#method.eval"><code>eval</code></a>.</li>
<li>It can be passed to functions that require a proof of holding the GIL,
such as <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.Py.html#method.clone_ref"><code>Py::clone_ref</code></a>.</li>
<li>Its lifetime can be used to create Rust references that implicitly guarantee
holding the GIL, such as <a href="https://docs.rs/pyo3/0.14.4/pyo3/types/struct.PyAny.html"><code>&amp;'py PyAny</code></a>.</li>
</ul>
<p>The latter two points are the reason why some APIs in PyO3 require the <code>py: Python</code> argument, while others don't.</p>
<p>The PyO3 API for Python objects is written such that instead of requiring a
mutable Rust reference for mutating operations such as
<a href="https://docs.rs/pyo3/0.14.4/pyo3/types/struct.PyList.html#method.append"><code>PyList::append</code></a>, a shared reference (which, in turn, can only
be created through <code>Python&lt;'_&gt;</code> with a GIL lifetime) is sufficient.</p>
<p>However, Rust structs wrapped as Python objects (called <code>pyclass</code> types) usually
<em>do</em> need <code>&amp;mut</code> access.  Due to the GIL, PyO3 <em>can</em> guarantee thread-safe acces
to them, but it cannot statically guarantee uniqueness of <code>&amp;mut</code> references once
an object's ownership has been passed to the Python interpreter, ensuring
references is done at runtime using <code>PyCell</code>, a scheme very similar to
<code>std::cell::RefCell</code>.</p>
<h2 id="object-types"><a class="header" href="#object-types">Object types</a></h2>
<h3 id="a-hrefhttpsdocsrspyo30144pyo3typesstructpyanyhtmlpyanya"><a class="header" href="#a-hrefhttpsdocsrspyo30144pyo3typesstructpyanyhtmlpyanya"><a href="https://docs.rs/pyo3/0.14.4/pyo3/types/struct.PyAny.html"><code>PyAny</code></a></a></h3>
<p><strong>Represents:</strong> a Python object of unspecified type, restricted to a GIL
lifetime.  Currently, <code>PyAny</code> can only ever occur as a reference, <code>&amp;PyAny</code>.</p>
<p><strong>Used:</strong> Whenever you want to refer to some Python object and will have the
GIL for the whole duration you need to access that object. For example,
intermediate values and arguments to <code>pyfunction</code>s or <code>pymethod</code>s implemented
in Rust where any type is allowed.</p>
<p>Many general methods for interacting with Python objects are on the <code>PyAny</code> struct,
such as <code>getattr</code>, <code>setattr</code>, and <code>.call</code>.</p>
<p><strong>Conversions:</strong></p>
<p>For a <code>&amp;PyAny</code> object reference <code>any</code> where the underlying object is a Python-native type such as
a list:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::{Py, Python, PyAny, PyResult, types::PyList};
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let obj: &amp;PyAny = PyList::empty(py);

// To &amp;PyList with PyAny::downcast
let _: &amp;PyList = obj.downcast()?;

// To Py&lt;PyAny&gt; (aka PyObject) with .into()
let _: Py&lt;PyAny&gt; = obj.into();

// To Py&lt;PyList&gt; with PyAny::extract
let _: Py&lt;PyList&gt; = obj.extract()?;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p>For a <code>&amp;PyAny</code> object reference <code>any</code> where the underlying object is a <code>#[pyclass]</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::{Py, Python, PyAny, PyResult, types::PyList};
</span><span class="boring">#[pyclass] #[derive(Clone)] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let obj: &amp;PyAny = Py::new(py, MyClass { })?.into_ref(py);

// To &amp;PyCell&lt;MyClass&gt; with PyAny::downcast
let _: &amp;PyCell&lt;MyClass&gt; = obj.downcast()?;

// To Py&lt;PyAny&gt; (aka PyObject) with .into()
let _: Py&lt;PyAny&gt; = obj.into();

// To Py&lt;MyClass&gt; with PyAny::extract
let _: Py&lt;MyClass&gt; = obj.extract()?;

// To MyClass with PyAny::extract, if MyClass: Clone
let _: MyClass = obj.extract()?;

// To PyRef&lt;MyClass&gt; or PyRefMut&lt;MyClass&gt; with PyAny::extract
let _: PyRef&lt;MyClass&gt; = obj.extract()?;
let _: PyRefMut&lt;MyClass&gt; = obj.extract()?;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="pytuple-pydict-and-many-more"><a class="header" href="#pytuple-pydict-and-many-more"><code>PyTuple</code>, <code>PyDict</code>, and many more</a></h3>
<p><strong>Represents:</strong> a native Python object of known type, restricted to a GIL
lifetime just like <code>PyAny</code>.</p>
<p><strong>Used:</strong> Whenever you want to operate with native Python types while holding
the GIL.  Like <code>PyAny</code>, this is the most convenient form to use for function
arguments and intermediate values.</p>
<p>These types all implement <code>Deref&lt;Target = PyAny&gt;</code>, so they all expose the same
methods which can be found on <code>PyAny</code>.</p>
<p>To see all Python types exposed by <code>PyO3</code> you should consult the
<a href="https://docs.rs/pyo3/0.14.4/pyo3/types/index.html"><code>pyo3::types</code></a> module.</p>
<p><strong>Conversions:</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let list = PyList::empty(py);

// Use methods from PyAny on all Python types with Deref implementation
let _ = list.repr()?;

// To &amp;PyAny automatically with Deref implementation
let _: &amp;PyAny = list;

// To &amp;PyAny explicitly with .as_ref()
let _: &amp;PyAny = list.as_ref();

// To Py&lt;T&gt; with .into() or Py::from()
let _: Py&lt;PyList&gt; = list.into();

// To PyObject with .into() or .to_object(py)
let _: PyObject = list.into();
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="pyt-and-pyobject"><a class="header" href="#pyt-and-pyobject"><code>Py&lt;T&gt;</code> and <code>PyObject</code></a></h3>
<p><strong>Represents:</strong> a GIL-independent reference to a Python object. This can be a Python native type
(like <code>PyTuple</code>), or a <code>pyclass</code> type implemented in Rust. The most commonly-used variant,
<code>Py&lt;PyAny&gt;</code>, is also known as <code>PyObject</code>.</p>
<p><strong>Used:</strong> Whenever you want to carry around references to a Python object without caring about a
GIL lifetime.  For example, storing Python object references in a Rust struct that outlives the
Python-Rust FFI boundary, or returning objects from functions implemented in Rust back to Python.</p>
<p>Can be cloned using Python reference counts with <code>.clone()</code>.</p>
<p><strong>Conversions:</strong></p>
<p>For a <code>Py&lt;PyList&gt;</code>, the conversions are as below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">Python::with_gil(|py| {
</span>let list: Py&lt;PyList&gt; = PyList::empty(py).into();

// To &amp;PyList with Py::as_ref() (borrows from the Py)
let _: &amp;PyList = list.as_ref(py);

<span class="boring">let list_clone = list.clone(); // Because `.into_ref()` will consume `list`.
</span>// To &amp;PyList with Py::into_ref() (moves the pointer into PyO3's object storage)
let _: &amp;PyList = list.into_ref(py);

<span class="boring">let list = list_clone;
</span>// To Py&lt;PyAny&gt; (aka PyObject) with .into()
let _: Py&lt;PyAny&gt; = list.into();
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p>For a <code>#[pyclass] struct MyClass</code>, the conversions for <code>Py&lt;MyClass&gt;</code> are below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">Python::with_gil(|py| {
</span><span class="boring">#[pyclass] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let my_class: Py&lt;MyClass&gt; = Py::new(py, MyClass { })?;

// To &amp;PyCell&lt;MyClass&gt; with Py::as_ref() (borrows from the Py)
let _: &amp;PyCell&lt;MyClass&gt; = my_class.as_ref(py);

<span class="boring">let my_class_clone = my_class.clone(); // Because `.into_ref()` will consume `my_class`.
</span>// To &amp;PyCell&lt;MyClass&gt; with Py::into_ref() (moves the pointer into PyO3's object storage)
let _: &amp;PyCell&lt;MyClass&gt; = my_class.into_ref(py);

<span class="boring">let my_class = my_class_clone.clone();
</span>// To Py&lt;PyAny&gt; (aka PyObject) with .into_py(py)
let _: Py&lt;PyAny&gt; = my_class.into_py(py);

<span class="boring">let my_class = my_class_clone;
</span>// To PyRef&lt;MyClass&gt; with Py::borrow or Py::try_borrow
let _: PyRef&lt;MyClass&gt; = my_class.try_borrow(py)?;

// To PyRefMut&lt;MyClass&gt; with Py::borrow_mut or Py::try_borrow_mut
let _: PyRefMut&lt;MyClass&gt; = my_class.try_borrow_mut(py)?;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">});
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="pycellsometype"><a class="header" href="#pycellsometype"><code>PyCell&lt;SomeType&gt;</code></a></h3>
<p><strong>Represents:</strong> a reference to a Rust object (instance of <code>PyClass</code>) which is
wrapped in a Python object.  The cell part is an analog to stdlib's
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> to allow access to <code>&amp;mut</code> references.</p>
<p><strong>Used:</strong> for accessing pure-Rust API of the instance (members and functions
taking <code>&amp;SomeType</code> or <code>&amp;mut SomeType</code>) while maintaining the aliasing rules of
Rust references.</p>
<p>Like pyo3's Python native types, <code>PyCell&lt;T&gt;</code> implements <code>Deref&lt;Target = PyAny&gt;</code>,
so it also exposes all of the methods on <code>PyAny</code>.</p>
<p><strong>Conversions:</strong></p>
<p><code>PyCell&lt;T&gt;</code> can be used to access <code>&amp;T</code> and <code>&amp;mut T</code> via <code>PyRef&lt;T&gt;</code> and <code>PyRefMut&lt;T&gt;</code> respectively.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">#[pyclass] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let cell: &amp;PyCell&lt;MyClass&gt; = PyCell::new(py, MyClass { })?;

// To PyRef&lt;T&gt; with .borrow() or .try_borrow()
let py_ref: PyRef&lt;MyClass&gt; = cell.try_borrow()?;
let _: &amp;MyClass = &amp;*py_ref;
<span class="boring">drop(py_ref);
</span>
// To PyRefMut&lt;T&gt; with .borrow_mut() or .try_borrow_mut()
let mut py_ref_mut: PyRefMut&lt;MyClass&gt; = cell.try_borrow_mut()?;
let _: &amp;mut MyClass = &amp;mut *py_ref_mut;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p><code>PyCell&lt;T&gt;</code> can also be accessed like a Python-native type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">#[pyclass] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let cell: &amp;PyCell&lt;MyClass&gt; = PyCell::new(py, MyClass { })?;

// Use methods from PyAny on PyCell&lt;T&gt; with Deref implementation
let _ = cell.repr()?;

// To &amp;PyAny automatically with Deref implementation
let _: &amp;PyAny = cell;

// To &amp;PyAny explicitly with .as_ref()
let _: &amp;PyAny = cell.as_ref();
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="pyrefsometype-and-pyrefmutsometype"><a class="header" href="#pyrefsometype-and-pyrefmutsometype"><code>PyRef&lt;SomeType&gt;</code> and <code>PyRefMut&lt;SomeType&gt;</code></a></h3>
<p><strong>Represents:</strong> reference wrapper types employed by <code>PyCell</code> to keep track of
borrows, analog to <code>Ref</code> and <code>RefMut</code> used by <code>RefCell</code>.</p>
<p><strong>Used:</strong> while borrowing a <code>PyCell</code>.  They can also be used with <code>.extract()</code>
on types like <code>Py&lt;T&gt;</code> and <code>PyAny</code> to get a reference quickly.</p>
<h2 id="related-traits-and-types"><a class="header" href="#related-traits-and-types">Related traits and types</a></h2>
<h3 id="pyclass"><a class="header" href="#pyclass"><code>PyClass</code></a></h3>
<p>This trait marks structs defined in Rust that are also usable as Python classes,
usually defined using the <code>#[pyclass]</code> macro.</p>
<h3 id="pynativetype"><a class="header" href="#pynativetype"><code>PyNativeType</code></a></h3>
<p>This trait marks structs that mirror native Python types, such as <code>PyList</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallelism"><a class="header" href="#parallelism">Parallelism</a></h1>
<p>CPython has the infamous <a href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock">Global Interpreter Lock</a>, which prevents several threads from executing Python bytecode in parallel. This makes threading in Python a bad fit for <a href="https://stackoverflow.com/questions/868568/">CPU-bound</a> tasks and often forces developers to accept the overhead of multiprocessing.</p>
<p>In PyO3 parallelism can be easily achieved in Rust-only code. Let's take a look at our <a href="https://github.com/PyO3/pyo3/blob/main/examples/word-count/src/lib.rs">word-count</a> example, where we have a <code>search</code> function that utilizes the <a href="https://github.com/rayon-rs/rayon">rayon</a> crate to count words in parallel.</p>
<pre><code class="language-rust ignore">#[pyfunction]
fn search(contents: &amp;str, needle: &amp;str) -&gt; usize {
    contents
        .par_lines()
        .map(|line| count_line(line, needle))
        .sum()
}
</code></pre>
<p>But let's assume you have a long running Rust function which you would like to execute several times in parallel. For the sake of example let's take a sequential version of the word count:</p>
<pre><code class="language-rust ignore">fn search_sequential(contents: &amp;str, needle: &amp;str) -&gt; usize {
    contents.lines().map(|line| count_line(line, needle)).sum()
}
</code></pre>
<p>To enable parallel execution of this function, the <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.Python.html#method.allow_threads"><code>Python::allow_threads</code></a> method can be used to temporarily release the GIL, thus allowing other Python threads to run. We then have a function exposed to the Python runtime which calls <code>search_sequential</code> inside a closure passed to <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.Python.html#method.allow_threads"><code>Python::allow_threads</code></a> to enable true parallelism:</p>
<pre><code class="language-rust ignore">#[pyfunction]
fn search_sequential_allow_threads(py: Python, contents: &amp;str, needle: &amp;str) -&gt; usize {
    py.allow_threads(|| search_sequential(contents, needle))
}
</code></pre>
<p>Now Python threads can use more than one CPU core, resolving the limitation which usually makes multi-threading in Python only good for IO-bound tasks:</p>
<pre><code class="language-Python">from concurrent.futures import ThreadPoolExecutor
from word_count import search_sequential_allow_threads

executor = ThreadPoolExecutor(max_workers=2)

future_1 = executor.submit(
    word_count.search_sequential_allow_threads, contents, needle
)
future_2 = executor.submit(
    word_count.search_sequential_allow_threads, contents, needle
)
result_1 = future_1.result()
result_2 = future_2.result()
</code></pre>
<h2 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h2>
<p>Let's benchmark the <code>word-count</code> example to verify that we really did unlock parallelism with PyO3.</p>
<p>We are using <code>pytest-benchmark</code> to benchmark four word count functions:</p>
<ol>
<li>Pure Python version</li>
<li>Rust parallel version</li>
<li>Rust sequential version</li>
<li>Rust sequential version executed twice with two Python threads</li>
</ol>
<p>The benchmark script can be found <a href="https://github.com/PyO3/pyo3/blob/main/examples/word-count/tests/test_word_count.py">here</a>, and we can run <code>tox</code> in the <code>word-count</code> folder to benchmark these functions.</p>
<p>While the results of the benchmark of course depend on your machine, the relative results should be similar to this (mid 2020):</p>
<pre><code class="language-ignore">-------------------------------------------------------------------------------------------------- benchmark: 4 tests -------------------------------------------------------------------------------------------------
Name (time in ms)                                          Min                Max               Mean            StdDev             Median               IQR            Outliers       OPS            Rounds  Iterations
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
test_word_count_rust_parallel                           1.7315 (1.0)       4.6495 (1.0)       1.9972 (1.0)      0.4299 (1.0)       1.8142 (1.0)      0.2049 (1.0)         40;46  500.6943 (1.0)         375           1
test_word_count_rust_sequential                         7.3348 (4.24)     10.3556 (2.23)      8.0035 (4.01)     0.7785 (1.81)      7.5597 (4.17)     0.8641 (4.22)         26;5  124.9457 (0.25)        121           1
test_word_count_rust_sequential_twice_with_threads      7.9839 (4.61)     10.3065 (2.22)      8.4511 (4.23)     0.4709 (1.10)      8.2457 (4.55)     0.3927 (1.92)        17;17  118.3274 (0.24)        114           1
test_word_count_python_sequential                      27.3985 (15.82)    45.4527 (9.78)     28.9604 (14.50)    4.1449 (9.64)     27.5781 (15.20)    0.4638 (2.26)          3;5   34.5299 (0.07)         35           1
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</code></pre>
<p>You can see that the Python threaded version is not much slower than the Rust sequential version, which means compared to an execution on a single CPU core the speed has doubled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>PyO3's attributes (<code>#[pyclass]</code>, <code>#[pymodule]</code>, etc.) are <a href="https://doc.rust-lang.org/reference/procedural-macros.html">procedural macros</a>, which means that they rewrite the source of the annotated item. You can view the generated source with the following command, which also expands a few other things:</p>
<pre><code class="language-bash">cargo rustc --profile=check -- -Z unstable-options --pretty=expanded &gt; expanded.rs; rustfmt expanded.rs
</code></pre>
<p>(You might need to install <a href="https://github.com/rust-lang-nursery/rustfmt">rustfmt</a> if you don't already have it.)</p>
<p>You can also debug classic <code>!</code>-macros by adding <code>-Z trace-macros</code>:</p>
<pre><code class="language-bash">cargo rustc --profile=check -- -Z unstable-options --pretty=expanded -Z trace-macros &gt; expanded.rs; rustfmt expanded.rs
</code></pre>
<p>See <a href="https://github.com/dtolnay/cargo-expand">cargo expand</a> for a more elaborate version of those commands.</p>
<h2 id="running-with-valgrind"><a class="header" href="#running-with-valgrind">Running with Valgrind</a></h2>
<p>Valgrind is a tool to detect memory management bugs such as memory leaks.</p>
<p>You first need to install a debug build of Python, otherwise Valgrind won't produce usable results. In Ubuntu there's e.g. a <code>python3-dbg</code> package.</p>
<p>Activate an environment with the debug interpreter and recompile. If you're on Linux, use <code>ldd</code> with the name of your binary and check that you're linking e.g. <code>libpython3.6dm.so.1.0</code> instead of <code>libpython3.6m.so.1.0</code>.</p>
<p><a href="https://raw.githubusercontent.com/python/cpython/master/Misc/valgrind-python.supp">Download the suppressions file for cpython</a>.</p>
<p>Run Valgrind with <code>valgrind --suppressions=valgrind-python.supp ./my-command --with-options</code></p>
<h2 id="getting-a-stacktrace"><a class="header" href="#getting-a-stacktrace">Getting a stacktrace</a></h2>
<p>The best start to investigate a crash such as an segmentation fault is a backtrace.</p>
<ul>
<li>Link against a debug build of python as described in the previous chapter</li>
<li>Run <code>gdb &lt;my-binary&gt;</code></li>
<li>Enter <code>r</code> to run</li>
<li>After the crash occurred, enter <code>bt</code> or <code>bt full</code> to print the stacktrace</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features-reference"><a class="header" href="#features-reference">Features Reference</a></h1>
<p>PyO3 provides a number of Cargo features to customise functionality. This chapter of the guide provides detail on each of them.</p>
<p>By default, only the <code>macros</code> feature is enabled.</p>
<h2 id="features-for-extension-module-authors"><a class="header" href="#features-for-extension-module-authors">Features for extension module authors</a></h2>
<h3 id="extension-module"><a class="header" href="#extension-module"><code>extension-module</code></a></h3>
<p>This feature is required when building a Python extension module using PyO3.</p>
<p>It tells PyO3's build script to skip linking against <code>libpython.so</code> on Unix platforms, where this must not be done.</p>
<p>See the <a href="building_and_distribution.html#linking">building and distribution</a> section for further detail.</p>
<h3 id="abi3"><a class="header" href="#abi3"><code>abi3</code></a></h3>
<p>This feature is used when building Python extension modules to create wheels which are compatible with multiple Python versions.</p>
<p>It restricts PyO3's API to a subset of the full Python API which is guaranteed by <a href="https://www.python.org/dev/peps/pep-0384/">PEP 384</a> to be forwards-compatible with future Python versions.</p>
<p>See the <a href="building_and_distribution.html#py_limited_apiabi3">building and distribution</a> section for further detail.</p>
<h3 id="abi3-py36--abi3-py37--abi3-py38--abi3-py39"><a class="header" href="#abi3-py36--abi3-py37--abi3-py38--abi3-py39"><code>abi3-py36</code> / <code>abi3-py37</code> / <code>abi3-py38</code> / <code>abi3-py39</code></a></h3>
<p>These features are an extension of the <code>abi3</code> feature to specify the exact minimum Python version which the multiple-version-wheel will support.</p>
<p>See the <a href="building_and_distribution.html#minimum-python-version-for-abi3">building and distribution</a> section for further detail.</p>
<h2 id="features-for-embedding-python-in-rust"><a class="header" href="#features-for-embedding-python-in-rust">Features for embedding Python in Rust</a></h2>
<h3 id="auto-initialize"><a class="header" href="#auto-initialize"><code>auto-initialize</code></a></h3>
<p>This feature changes <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.Python.html#method.with_gil"><code>Python::with_gil</code></a> and <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.Python.html#method.acquire_gil"><code>Python::acquire_gil</code></a> to automatically initialize a Python interpreter (by calling <a href="https://docs.rs/pyo3/0.14.4/pyo3/fn.prepare_freethreaded_python.html"><code>prepare_freethreaded_python</code></a>) if needed.</p>
<p>If you do not enable this feature, you should call <code>pyo3::prepare_freethreaded_python()</code> before attempting to call any other Python APIs.</p>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<h3 id="macros-1"><a class="header" href="#macros-1"><code>macros</code></a></h3>
<p>This feature enables a dependency on the <code>pyo3-macros</code> crate, which provides the procedural macros portion of PyO3's API:</p>
<ul>
<li><code>#[pymodule]</code></li>
<li><code>#[pyfunction]</code></li>
<li><code>#[pyclass]</code></li>
<li><code>#[pymethods]</code></li>
<li><code>#[pyproto]</code></li>
<li><code>#[derive(FromPyObject)]</code></li>
</ul>
<p>It also provides the <code>py_run!</code> macro.</p>
<p>These macros require a number of dependencies which may not be needed by users who just need PyO3 for Python FFI. Disabling this feature enables faster builds for those users, as these dependencies will not be built if this feature is disabled.</p>
<blockquote>
<p>This feature is enabled by default. To disable it, set <code>default-features = false</code> for the <code>pyo3</code> entry in your Cargo.toml.</p>
</blockquote>
<h3 id="multiple-pymethods"><a class="header" href="#multiple-pymethods"><code>multiple-pymethods</code></a></h3>
<p>This feature enables a dependency on <code>inventory</code>, which enables each <code>#[pyclass]</code> to have more than one <code>#[pymethods]</code> block.</p>
<p>Most users should only need a single <code>#[pymethods]</code> per <code>#[pyclass]</code>. In addition, not all platforms (e.g. Wasm) are supported by <code>inventory</code>. For this reason this feature is not enabled by default, meaning fewer dependencies and faster compilation for the majority of users.</p>
<p>See <a href="class.html#implementation-details">the <code>#[pyclass]</code> implementation details</a> for more information.</p>
<h3 id="nightly"><a class="header" href="#nightly"><code>nightly</code></a></h3>
<p>The <code>nightly</code> feature needs the nightly Rust compiler. This allows PyO3 to use Rust's unstable specialization feature to apply the following optimizations:</p>
<ul>
<li><code>FromPyObject</code> for <code>Vec</code> and <code>[T;N]</code> can perform a <code>memcpy</code> when the object supports the Python buffer protocol.</li>
<li><code>ToBorrowedObject</code> can skip a reference count increase when the provided object is a Python native type.</li>
</ul>
<h3 id="num-bigint"><a class="header" href="#num-bigint"><code>num-bigint</code></a></h3>
<p>This feature adds a dependency on <a href="https://docs.rs/num-bigint">num-bigint</a> and enables conversions into its <a href="https://docs.rs/num-bigint/latest/num_bigint/struct.BigInt.html"><code>BigInt</code></a> and <a href="https://docs.rs/num-bigint/latest/num_bigint/struct.BigUInt.html"><code>BigUint</code></a> types.</p>
<h3 id="num-complex"><a class="header" href="#num-complex"><code>num-complex</code></a></h3>
<p>This feature adds a dependency on <a href="https://docs.rs/num-complex">num-complex</a> and enables conversions into its <a href="https://docs.rs/num-complex/latest/num_complex/struct.Complex.html"><code>Complex</code></a> type.</p>
<h3 id="serde"><a class="header" href="#serde"><code>serde</code></a></h3>
<p>The <code>serde</code> feature enables (de)serialization of Py<T> objects via <a href="https://serde.rs/">serde</a>.
This allows to use <a href="https://serde.rs/derive.html"><code>#[derive(Serialize, Deserialize)</code></a> on structs that hold references to <code>#[pyclass]</code> instances</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[pyclass]
#[derive(Serialize, Deserialize)]
struct Permission {
    name: String
}

#[pyclass]
#[derive(Serialize, Deserialize)]
struct User {
    username: String,
    permissions: Vec&lt;Py&lt;Permission&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced topics</a></h1>
<h2 id="ffi"><a class="header" href="#ffi">FFI</a></h2>
<p>PyO3 exposes much of Python's C API through the <code>ffi</code> module.</p>
<p>The C API is naturally unsafe and requires you to manage reference counts, errors and specific invariants yourself. Please refer to the <a href="https://docs.python.org/3/c-api/">C API Reference Manual</a> and <a href="https://doc.rust-lang.org/nightly/nomicon/ffi.html">The Rustonomicon</a> before using any function from that API.</p>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<p>PyO3's &quot;owned references&quot; (<code>&amp;PyAny</code> etc.) make PyO3 more ergonomic to use by ensuring that their lifetime can never be longer than the duration the Python GIL is held. This means that most of PyO3's API can assume the GIL is held. (If PyO3 could not assume this, every PyO3 API would need to take a <code>Python</code> GIL token to prove that the GIL is held.)</p>
<p>The caveat to these &quot;owned references&quot; is that Rust references do not normally convey ownership (they are always <code>Copy</code>, and cannot implement <code>Drop</code>). Whenever a PyO3 API returns an owned reference, PyO3 stores it internally, so that PyO3 can decrease the reference count just before PyO3 releases the GIL.</p>
<p>For most use cases this behaviour is invisible. Occasionally, however, users may need to clear memory usage sooner than PyO3 usually does. PyO3 exposes this functionality with the  the <code>GILPool</code> struct. When a <code>GILPool</code> is dropped, <em><strong>all</strong></em> owned references created after the <code>GILPool</code> was created will be cleared.</p>
<p>The unsafe function <code>Python::new_pool</code> allows you to create a new <code>GILPool</code>. When doing this, you must be very careful to ensure that once the <code>GILPool</code> is dropped you do not retain access any owned references created after the <code>GILPool</code> was created.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-and-distribution"><a class="header" href="#building-and-distribution">Building and Distribution</a></h1>
<p>This chapter of the guide goes into detail on how to build and distribute projects using PyO3. The way to achieve this is very different depending on whether the project is a Python module implemented in Rust, or a Rust binary embedding Python. For both types of project there are also common problems such as the Python version to build for and the <a href="https://en.wikipedia.org/wiki/Linker_(computing)">linker</a> arguments to use.</p>
<p>The material in this chapter is intended for users who have already read the PyO3 <a href="building_and_distribution.html#index.md">README</a>. It covers in turn the choices that can be made for Python modules and for Rust binaries. There is also a section at the end about cross-compiling projects using PyO3.</p>
<p>There is an additional sub-chapter dedicated to <a href="./building_and_distribution/multiple_python_versions.html">supporting multiple Python versions</a>.</p>
<h2 id="configuring-the-python-version"><a class="header" href="#configuring-the-python-version">Configuring the Python version</a></h2>
<p>PyO3 uses a build script (backed by the <a href="https://github.com/PyO3/pyo3/tree/main/pyo3-build-config"><code>pyo3-build-config</code></a> crate) to determine the Python version and set the correct linker arguments. By default it will attempt to use the following in order:</p>
<ul>
<li>Any active Python virtualenv.</li>
<li>The <code>python</code> executable (if it's a Python 3 interpreter).</li>
<li>The <code>python3</code> executable.</li>
</ul>
<p>You can override the Python interpreter by setting the <code>PYO3_PYTHON</code> environment variable, e.g. <code>PYO3_PYTHON=python3.6</code>, <code>PYO3_PYTHON=/usr/bin/python3.9</code>, or even a PyPy interpreter <code>PYO3_PYTHON=pypy3</code>.</p>
<p>Once the Python interpreter is located, <code>pyo3-build-config</code> executes it to query the information in the <code>sysconfig</code> module which is needed to configure the rest of the compilation.</p>
<p>To validate the configuration which PyO3 will use, you can run a compilation with the environment variable <code>PYO3_PRINT_CONFIG=1</code> set. An example output of doing this is shown below:</p>
<pre><code class="language-console">$ PYO3_PRINT_CONFIG=1 cargo build
   Compiling pyo3 v0.14.1 (/home/david/dev/pyo3)
error: failed to run custom build command for `pyo3 v0.14.1 (/home/david/dev/pyo3)`

Caused by:
  process didn't exit successfully: `/home/david/dev/pyo3/target/debug/build/pyo3-7a8cf4fe22e959b7/build-script-build` (exit status: 101)
  --- stdout
  cargo:rerun-if-env-changed=PYO3_CROSS
  cargo:rerun-if-env-changed=PYO3_CROSS_LIB_DIR
  cargo:rerun-if-env-changed=PYO3_CROSS_PYTHON_VERSION
  cargo:rerun-if-env-changed=PYO3_PRINT_CONFIG

  -- PYO3_PRINT_CONFIG=1 is set, printing configuration and halting compile --
  implementation=CPython
  version=3.8
  shared=true
  abi3=false
  lib_name=python3.8
  lib_dir=/usr/lib
  executable=/usr/bin/python
  pointer_width=64
  build_flags=WITH_THREAD
</code></pre>
<blockquote>
<p>Note: if you save the output config to a file, it is possible to manually override the contents and feed it back into PyO3 using the <code>PYO3_CONFIG_FILE</code> env var. For now, this is an advanced feature that should not be needed for most users. The format of the config file and its contents are deliberately unstable and undocumented. If you have a production use-case for this config file, please file an issue and help us stabilize it!</p>
</blockquote>
<h2 id="building-python-extension-modules"><a class="header" href="#building-python-extension-modules">Building Python extension modules</a></h2>
<p>Python extension modules need to be compiled differently depending on the OS (and architecture) that they are being compiled for. As well as multiple OSes (and architectures), there are also many different Python versions which are actively supported. Packages uploaded to <a href="https://pypi.org/">PyPI</a> usually want to upload prebuilt &quot;wheels&quot; covering many OS/arch/version combinations so that users on all these different platforms don't have to compile the package themselves. Package vendors can opt-in to the &quot;abi3&quot; limited Python API which allows their wheels to be used on multiple Python versions, reducing the number of wheels they need to compile, but restricts the functionality they can use.</p>
<p>There are many ways to go about this: it is possible to use <code>cargo</code> to build the extension module (along with some manual work, which varies with OS). The PyO3 ecosystem has two packaging tools, <a href="https://github.com/PyO3/maturin"><code>maturin</code></a> and <a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a>, which abstract over the OS difference and also support building wheels for PyPI upload.</p>
<p>PyO3 has some Cargo features to configure projects for building Python extension modules:</p>
<ul>
<li>The <code>extension-module</code> feature, which must be enabled when building Python extension modules.</li>
<li>The <code>abi3</code> feature and its version-specific <code>abi3-pyXY</code> companions, which are used to opt-in to the limited Python API in order to support multiple Python versions in a single wheel.</li>
</ul>
<p>This section describes each of these packaging tools before describiing how to build manually without them. It then proceeds with an explanation of the <code>extension-module</code> feature. Finally, there is a section describing PyO3's <code>abi3</code> features.</p>
<h3 id="packaging-tools"><a class="header" href="#packaging-tools">Packaging tools</a></h3>
<p>The PyO3 ecosystem has two main choices to abstract the process of developing Python extension modules:</p>
<ul>
<li><a href="https://github.com/PyO3/maturin"><code>maturin</code></a> is a command-line tool to build, package and upload Python modules. It makes opinionated choices about project layout meaning it needs very little configuration. This makes it a great choice for users who are building a Python extension from scratch and don't need flexibility.</li>
<li><a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a> is an add-on for <code>setuptools</code> which adds extra keyword arguments to the <code>setup.py</code> configuration file. It requires more configuration than <code>maturin</code>, however this gives additional flexibility for users adding Rust to an existing Python package that can't satisfy <code>maturin</code>'s constraints.</li>
</ul>
<p>Consult each project's documentation for full details on how to get started using them and how to upload wheels to PyPI.</p>
<p>There are also <a href="https://github.com/PyO3/pyo3/tree/main/examples/maturin-starter"><code>maturin-starter</code></a> and <a href="https://github.com/PyO3/pyo3/tree/main/examples/setuptools-rust-starter"><code>setuptools-rust-starter</code></a> examples in the PyO3 repository.</p>
<h3 id="manual-builds"><a class="header" href="#manual-builds">Manual builds</a></h3>
<p>To build a PyO3-based Python extension manually, start by running <code>cargo build</code> as normal in a library project which uses PyO3's <code>extension-module</code> feature and has the <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-crate-type-field"><code>cdylib</code> crate type</a>.</p>
<p>Once built, symlink (or copy) and rename the shared library from Cargo's <code>target/</code> directory to your desired output directory:</p>
<ul>
<li>on macOS, rename <code>libyour_module.dylib</code> to <code>your_module.so</code>.</li>
<li>on Windows, rename  <code>libyour_module.dll</code> to <code>your_module.pyd</code>.</li>
<li>on Linux, rename <code>libyour_module.so</code> to <code>your_module.so</code>.</li>
</ul>
<p>You can then open a Python shell in the output directory and you'll be able to run <code>import your_module</code>.</p>
<p>See, as an example, Bazel rules to build PyO3 on Linux at https://github.com/TheButlah/rules_pyo3.</p>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<p>On macOS, because the <code>extension-module</code> feature disables linking to <code>libpython</code> (<a href="building_and_distribution.html#the-extension-module-feature">see the next section</a>), some additional linker arguments need to be set. <code>maturin</code> and <code>setuptools-rust</code> both pass these arguments for PyO3 automatically, but projects using manual builds will need to set these directly in order to support macOS.</p>
<p>The easiest way to set the correct linker arguments is to add a <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code></a> with the following content:</p>
<pre><code class="language-rust ignore">fn main() {
  pyo3_build_config::add_extension_module_link_args();
}
</code></pre>
<p>Remember to also add <code>pyo3-build-config</code> to the <code>build-dependencies</code> section in <code>Cargo.toml</code>.</p>
<p>An alternative to using <code>pyo3-build-config</code> is add the following to a cargo configuration file (e.g. <code>.cargo/config.toml</code>):</p>
<pre><code class="language-toml">[target.x86_64-apple-darwin]
rustflags = [
  &quot;-C&quot;, &quot;link-arg=-undefined&quot;,
  &quot;-C&quot;, &quot;link-arg=dynamic_lookup&quot;,
]

[target.aarch64-apple-darwin]
rustflags = [
  &quot;-C&quot;, &quot;link-arg=-undefined&quot;,
  &quot;-C&quot;, &quot;link-arg=dynamic_lookup&quot;,
]
</code></pre>
<h3 id="the-extension-module-feature"><a class="header" href="#the-extension-module-feature">The <code>extension-module</code> feature</a></h3>
<p>PyO3's <code>extension-module</code> feature is used to disable <a href="https://en.wikipedia.org/wiki/Linker_(computing)">linking</a> to <code>libpython</code> on unix targets.</p>
<p>This is necessary because by default PyO3 links to <code>libpython</code>. This makes binaries, tests, and examples &quot;just work&quot;. However, Python extensions on unix must not link to libpython for <a href="https://www.python.org/dev/peps/pep-0513/">manylinux</a> compliance.</p>
<p>The downside of not linking to <code>libpython</code> is that binaries, tests, and examples (which usually embed Python) will fail to build. If you have an extension module as well as other outputs in a single project, you need to use optional Cargo features to disable the <code>extension-module</code> when you're not building the extension module. See <a href="faq.html#i-cant-run-cargo-test-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-_pyexc_systemerror">the FAQ</a> for an example workaround.</p>
<h3 id="py_limited_apiabi3"><a class="header" href="#py_limited_apiabi3"><code>Py_LIMITED_API</code>/<code>abi3</code></a></h3>
<p>By default, Python extension modules can only be used with the same Python version they were compiled against. For example, an extension module built for Python 3.5 can't be imported in Python 3.8. <a href="https://www.python.org/dev/peps/pep-0384/">PEP 384</a> introduced the idea of the limited Python API, which would have a stable ABI enabling extension modules built with it to be used against multiple Python versions. This is also known as <code>abi3</code>.</p>
<p>The advantage of building extension modules using the limited Python API is that package vendors only need to build and distribute a single copy (for each OS / architecture), and users can install it on all Python versions from the <a href="building_and_distribution.html#minimum-python-version-for-abi3">minimum version</a> and up. The downside of this is that PyO3 can't use optimizations which rely on being compiled against a known exact Python version. It's up to you to decide whether this matters for your extension module. It's also possible to design your extension module such that you can distribute <code>abi3</code> wheels but allow users compiling from source to benefit from additional optimizations - see the <a href="./building_and_distribution/multiple_python_versions.html">support for multiple python versions</a> section of this guide, in particular the <code>#[cfg(Py_LIMITED_API)]</code> flag.</p>
<p>There are three steps involved in making use of <code>abi3</code> when building Python packages as wheels:</p>
<ol>
<li>Enable the <code>abi3</code> feature in <code>pyo3</code>. This ensures <code>pyo3</code> only calls Python C-API functions which are part of the stable API, and on Windows also ensures that the project links against the correct shared object (no special behavior is required on other platforms):</li>
</ol>
<pre><code class="language-toml">[dependencies]
pyo3 = { version = &quot;0.14.4&quot;, features = [&quot;abi3&quot;] }
</code></pre>
<ol start="2">
<li>
<p>Ensure that the built shared objects are correctly marked as <code>abi3</code>. This is accomplished by telling your build system that you're using the limited API. <a href="https://github.com/PyO3/maturin"><code>maturin</code></a> &gt;= 0.9.0 and <a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a> &gt;= 0.11.4 support <code>abi3</code> wheels.
See the <a href="https://github.com/PyO3/maturin/pull/353">corresponding</a> <a href="https://github.com/PyO3/setuptools-rust/pull/82">PRs</a> for more.</p>
</li>
<li>
<p>Ensure that the <code>.whl</code> is correctly marked as <code>abi3</code>. For projects using <code>setuptools</code>, this is accomplished by passing <code>--py-limited-api=cp3x</code> (where <code>x</code> is the minimum Python version supported by the wheel, e.g. <code>--py-limited-api=cp35</code> for Python 3.5) to <code>setup.py bdist_wheel</code>.</p>
</li>
</ol>
<h4 id="minimum-python-version-for-abi3"><a class="header" href="#minimum-python-version-for-abi3">Minimum Python version for <code>abi3</code></a></h4>
<p>Because a single <code>abi3</code> wheel can be used with many different Python versions, PyO3 has feature flags <code>abi3-py36</code>, <code>abi3-py37</code>, <code>abi-py38</code> etc. to set the minimum required Python version for your <code>abi3</code> wheel.
For example, if you set the <code>abi3-py36</code> feature, your extension wheel can be used on all Python 3 versions from Python 3.6 and up. <code>maturin</code> and <code>setuptools-rust</code> will give the wheel a name like <code>my-extension-1.0-cp36-abi3-manylinux2020_x86_64.whl</code>.</p>
<p>As your extension module may be run with multiple different Python versions you may occasionally find you need to check the Python version at runtime to customize behavior. See <a href="./building_and_distribution/multiple_python_versions.html#checking-the-python-version-at-runtime">the relevant section of this guide</a> on supporting multiple Python versions at runtime.</p>
<p>PyO3 is only able to link your extension module to api3 version up to and including your host Python version. E.g., if you set <code>abi3-py38</code> and try to compile the crate with a host of Python 3.6, the build will fail.</p>
<p>As an advanced feature, you can build PyO3 wheel without calling Python interpreter with the environment variable <code>PYO3_NO_PYTHON</code> set. On unix systems this works unconditionally; on Windows you must also set the <code>RUSTFLAGS</code> evironment variable to contain <code>-L native=/path/to/python/libs</code> so that the linker can find <code>python3.lib</code>.</p>
<blockquote>
<p>Note: If you set more that one of these api version feature flags the highest version always wins. For example, with both <code>abi3-py36</code> and <code>abi3-py38</code> set, PyO3 would build a wheel which supports Python 3.8 and up.</p>
</blockquote>
<h4 id="missing-features"><a class="header" href="#missing-features">Missing features</a></h4>
<p>Due to limitations in the Python API, there are a few <code>pyo3</code> features that do
not work when compiling for <code>abi3</code>. These are:</p>
<ul>
<li><code>#[pyo3(text_signature = &quot;...&quot;)]</code> does not work on classes until Python 3.10 or greater.</li>
<li>The <code>dict</code> and <code>weakref</code> options on classes are not supported until Python 3.9 or greater.</li>
<li>The buffer API is not supported.</li>
<li>Optimizations which rely on knowledge of the exact Python version compiled against.</li>
</ul>
<h2 id="embedding-python-in-rust"><a class="header" href="#embedding-python-in-rust">Embedding Python in Rust</a></h2>
<p>If you want to embed the Python interpreter inside a Rust program, there are two modes in which this can be done: dynamically and statically. We'll cover each of these modes in the following sections. Each of them affect how you must distribute your program. Instead of learning how to do this yourself, you might want to consider using a project like <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a> to ship your application and all of its dependencies in a single file.</p>
<p>PyO3 automatically switches between the two linking modes depending on whether the Python distribution you have configured PyO3 to use (<a href="building_and_distribution.html#python-version">see above</a>) contains a shared library or a static library. The static library is most often seen in Python distributions compiled from source without the <code>--enable-shared</code> configuration option. For example, this is the default for <code>pyenv</code> on macOS.</p>
<h3 id="dynamically-embedding-the-python-interpreter"><a class="header" href="#dynamically-embedding-the-python-interpreter">Dynamically embedding the Python interpreter</a></h3>
<p>Embedding the Python interpreter dynamically is much easier than doing so statically. This is done by linking your program against a Python shared library (such as <code>libpython.3.9.so</code> on UNIX, or <code>python39.dll</code> on Windows). The implementation of the Python interpreter resides inside the shared library. This means that when the OS runs your Rust program it also needs to be able to find the Python shared library.</p>
<p>This mode of embedding works well for Rust tests which need access to the Python interpreter. It is also great for Rust software which is installed inside a Python virtualenv, because the virtualenv sets up appropriate environment variables to locate the correct Python shared library.</p>
<p>For distributing your program to non-technical users, you will have to consider including the Python shared library in your distribution as well as setting up wrapper scripts to set the right environment variables (such as <code>LD_LIBRARY_PATH</code> on UNIX, or <code>PATH</code> on Windows).</p>
<p>Note that PyPy cannot be embedded in Rust (or any other software). Support for this is tracked on the <a href="https://foss.heptapod.net/pypy/pypy/-/issues/3286">PyPy issue tracker</a>.</p>
<h3 id="statically-embedding-the-python-interpreter"><a class="header" href="#statically-embedding-the-python-interpreter">Statically embedding the Python interpreter</a></h3>
<p>Embedding the Python interpreter statically means including the contents of a Python static library directly inside your Rust binary. This means that to distribute your program you only need to ship your binary file: it contains the Python interpreter inside the binary!</p>
<p>On Windows static linking is almost never done, so Python distributions don't usually include a static library. The information below applies only to UNIX.</p>
<p>The Python static library is usually called <code>libpython.a</code>.</p>
<p>Static linking has a lot of complications, listed below. For these reasons PyO3 does not yet have first-class support for this embedding mode. See <a href="https://github.com/PyO3/pyo3/issues/416">issue 416 on PyO3's Github</a> for more information and to discuss any issues you encounter.</p>
<p>The <a href="features.html#auto-initialize"><code>auto-initialize</code></a> feature is deliberately disabled when embedding the interpreter statically because this is often unintentionally done by new users to PyO3 running test programs. Trying out PyO3 is much easier using dynamic embedding.</p>
<p>The known complications are:</p>
<ul>
<li>
<p>To import compiled extension modules (such as other Rust extension modules, or those written in C), your binary must have the correct linker flags set during compilation to export the original contents of <code>libpython.a</code> so that extensions can use them (e.g. <code>-Wl,--export-dynamic</code>).</p>
</li>
<li>
<p>The C compiler and flags which were used to create <code>libpython.a</code> must be compatible with your Rust compiler and flags, else you will experience compilation failures.</p>
<p>Significantly different compiler versions may see errors like this:</p>
<pre><code class="language-ignore">lto1: fatal error: bytecode stream in file 'rust-numpy/target/release/deps/libpyo3-6a7fb2ed970dbf26.rlib' generated with LTO version 6.0 instead of the expected 6.2
</code></pre>
<p>Mismatching flags may lead to errors like this:</p>
<pre><code class="language-ignore">/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/libpython3.9.a(zlibmodule.o): relocation R_X86_64_32 against `.data' can not be used when making a PIE object; recompile with -fPIE
</code></pre>
</li>
</ul>
<p>If you encounter these or other complications when linking the interpreter statically, discuss them on <a href="https://github.com/PyO3/pyo3/issues/416">issue 416 on PyO3's Github</a>. It is hoped that eventually that discussion will contain enough information and solutions that PyO3 can offer first-class support for static embedding.</p>
<h2 id="cross-compiling"><a class="header" href="#cross-compiling">Cross Compiling</a></h2>
<p>Thanks to Rust's great cross-compilation support, cross-compiling using PyO3 is relatively straightforward. To get started, you'll need a few pieces of software:</p>
<ul>
<li>A toolchain for your target.</li>
<li>The appropriate options in your Cargo <code>.config</code> for the platform you're targeting and the toolchain you are using.</li>
<li>A Python interpreter that's already been compiled for your target.</li>
<li>A Python interpreter that is built for your host and available through the <code>PATH</code> or setting the <a href="building_and_distribution.html#python-version"><code>PYO3_PYTHON</code></a> variable.</li>
</ul>
<p>After you've obtained the above, you can build a cross-compiled PyO3 module by using Cargo's <code>--target</code> flag. PyO3's build script will detect that you are attempting a cross-compile based on your host machine and the desired target.</p>
<p>When cross-compiling, PyO3's build script cannot execute the target Python interpreter to query the configuration, so there are a few additional environment variables you may need to set:</p>
<ul>
<li><code>PYO3_CROSS</code>: If present this variable forces PyO3 to configure as a cross-compilation.</li>
<li><code>PYO3_CROSS_LIB_DIR</code>: This variable must be set to the directory containing the target's libpython DSO and the associated <code>_sysconfigdata*.py</code> file for Unix-like targets, or the Python DLL import libraries for the Windows target.</li>
<li><code>PYO3_CROSS_PYTHON_VERSION</code>: Major and minor version (e.g. 3.9) of the target Python installation. This variable is only needed if PyO3 cannot determine the version to target from <code>abi3-py3*</code> features, or if there are multiple versions of Python present in <code>PYO3_CROSS_LIB_DIR</code>.</li>
</ul>
<p>An example might look like the following (assuming your target's sysroot is at <code>/home/pyo3/cross/sysroot</code> and that your target is <code>armv7</code>):</p>
<pre><code class="language-sh">export PYO3_CROSS_LIB_DIR=&quot;/home/pyo3/cross/sysroot/usr/lib&quot;

cargo build --target armv7-unknown-linux-gnueabihf
</code></pre>
<p>If there are multiple python versions at the cross lib directory and you cannot set a more precise location to include both the <code>libpython</code> DSO and <code>_sysconfigdata*.py</code> files, you can set the required version:</p>
<pre><code class="language-sh">export PYO3_CROSS_PYTHON_VERSION=3.8
export PYO3_CROSS_LIB_DIR=&quot;/home/pyo3/cross/sysroot/usr/lib&quot;

cargo build --target armv7-unknown-linux-gnueabihf
</code></pre>
<p>Or another example with the same sys root but building for Windows:</p>
<pre><code class="language-sh">export PYO3_CROSS_PYTHON_VERSION=3.9
export PYO3_CROSS_LIB_DIR=&quot;/home/pyo3/cross/sysroot/usr/lib&quot;

cargo build --target x86_64-pc-windows-gnu
</code></pre>
<p>Any of the <code>abi3-py3*</code> features can be enabled instead of setting <code>PYO3_CROSS_PYTHON_VERSION</code> in the above examples.</p>
<p>The following resources may also be useful for cross-compiling:</p>
<ul>
<li><a href="https://github.com/japaric/rust-cross">github.com/japaric/rust-cross</a> is a primer on cross compiling Rust.</li>
<li><a href="https://github.com/rust-embedded/cross">github.com/rust-embedded/cross</a> uses Docker to make Rust cross-compilation easier.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supporting-multiple-python-versions"><a class="header" href="#supporting-multiple-python-versions">Supporting multiple Python versions</a></h1>
<p>PyO3 supports all actively-supported Python 3 and PyPy versions. As much as possible, this is done internally to PyO3 so that your crate's code does not need to adapt to the differences between each version. However, as Python features grow and change between versions, PyO3 cannot a completely identical API for every Python version. This may require you to add conditional compilation to your crate or runtime checks for the Python version.</p>
<p>This section of the guide first introduces the <code>pyo3-build-config</code> crate, which you can use as a <code>build-dependency</code> to add additional <code>#[cfg]</code> flags which allow you to support multiple Python versions at compile-time.</p>
<p>Second, we'll show how to check the Python version at runtime. This can be useful when building for multiple versions with the <code>abi3</code> feature, where the Python API compiled against is not always the same as the one in use.</p>
<h2 id="conditional-compilation-for-different-python-versions"><a class="header" href="#conditional-compilation-for-different-python-versions">Conditional compilation for different Python versions</a></h2>
<p>The <code>pyo3-build-config</code> exposes multiple <a href="https://doc.rust-lang.org/rust-by-example/attribute/cfg.html"><code>#[cfg]</code> flags</a> which can be used to conditionally compile code for a given Python version. PyO3 itself depends on this crate, so by using it you can be sure that you are configured correctly for the Python version PyO3 is building against.</p>
<p>This allows us to write code like the following</p>
<pre><code class="language-rust ignore">#[cfg(Py_3_7)]
fn function_only_supported_on_python_3_7_and_up() { }

#[cfg(not(Py_3_8))]
fn function_only_supported_before_python_3_8() { }

#[cfg(not(Py_LIMITED_API))]
fn function_incompatible_with_abi3_feature() { }
</code></pre>
<p>The following sections first show how to add these <code>#[cfg]</code> flags to your build process, and then cover some common patterns flags in a little more detail.</p>
<p>To see a full reference of all the <code>#[cfg]</code> flags provided, see the <a href="https://docs.rs/pyo3-build-config"><code>pyo3-build-cfg</code> docs</a>.</p>
<h3 id="using-pyo3-build-config"><a class="header" href="#using-pyo3-build-config">Using <code>pyo3-build-config</code></a></h3>
<p>You can use the <code>#[cfg]</code> flags in just two steps:</p>
<ol>
<li>
<p>Add <code>pyo3-build-config</code> it to your crate's build dependencies in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[build-dependencies]
pyo3-build-config = &quot;version = &quot;0.14.4&quot;&quot;
</code></pre>
</li>
<li>
<p>Add a <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code></a> file to your crate with the following contents:</p>
<pre><code class="language-rust ignore">fn main() {
    // If you have an existing build.rs file, just add this line to it.
    pyo3_build_config::use_pyo3_cfgs();
}
</code></pre>
</li>
</ol>
<p>After these steps you are ready to annotate your code!</p>
<h3 id="common-usages-of-pyo3-build-cfg-flags"><a class="header" href="#common-usages-of-pyo3-build-cfg-flags">Common usages of <code>pyo3-build-cfg</code> flags</a></h3>
<p>The <code>#[cfg]</code> flags added by <code>pyo3-build-cfg</code> can be combined with all of Rust's logic in the <code>#[cfg]</code> attribute to create very precise conditional code generation. The following are some common patterns implemented using these flags:</p>
<pre><code>#[cfg(Py_3_7)]
</code></pre>
<p>This <code>#[cfg]</code> marks code that will only be present on Python 3.7 and upwards. There are similar options <code>Py_3_8</code>, <code>Py_3_9</code>, <code>Py_3_10</code> and so on for each minor version.</p>
<pre><code>#[cfg(not(Py_3_7))]
</code></pre>
<p>This <code>#[cfg]</code> marks code that will only be present on Python versions before (but not including) Python 3.7.</p>
<pre><code>#[cfg(not(Py_LIMITED_API))]
</code></pre>
<p>This <code>#[cfg]</code> marks code that is only available when building for the unlimited Python API (i.e. PyO3's <code>abi3</code> feature is not enabled). This might be useful if you want to ship your extension module as an <code>abi3</code> wheel and also allow users to compile it from source to make use of optimizations only possible with the unlimited API.</p>
<pre><code>#[cfg(any(Py_3_9, not(Py_LIMITED_API)))]
</code></pre>
<p>This <code>#[cfg]</code> marks code which is available when running Python 3.9 or newer, or when using the unlimited API with an older Python version. Patterns like this are commonly seen on Python APIs which were added to the limited Python API in a specific minor version.</p>
<pre><code>#[cfg(PyPy)]
</code></pre>
<p>This <code>#[cfg]</code> marks code which is running on PyPy.</p>
<h2 id="checking-the-python-version-at-runtime"><a class="header" href="#checking-the-python-version-at-runtime">Checking the Python version at runtime</a></h2>
<p>When building with PyO3's <code>abi3</code> feature, your extension module will be compiled against a specific <a href="building_and_distribution/../building_and_distribution.html#minimum-python-version-for-abi3">minimum version</a> of Python, but may be running on newer Python versions.</p>
<p>For example with PyO3's <code>abi3-py38</code> feature, your extension will be compiled as if it were for Python 3.8. If you were using <code>pyo3-build-config</code>, <code>#[cfg(Py_3_8)]</code> would be present. Your user could freely install and run your abi3 extension on Python 3.9.</p>
<p>There's no way to detect your user doing that at compile time, so instead you need to fall back to runtime checks.</p>
<p>PyO3 provides the APIs <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.Python.html#method.version"><code>Python::version()</code></a> and <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.Python.html#method.version_info"><code>Python::version_info()</code></a> to query the running Python version. This allows you to do the following, for example:</p>
<pre><code class="language-rust ignore">if py.version_info() &gt;= (3, 9) {
   // run this code only if Python 3.9 or up
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-pyo3-ecosystem"><a class="header" href="#the-pyo3-ecosystem">The PyO3 Ecosystem</a></h1>
<p>This portion of the guide is dedicated to crates which are external to the main PyO3 project and provide additional functionality you might find useful.</p>
<p>Because these projects evolve independently of the PyO3 repository the content of these articles may fall out of date over time; please file issues on the PyO3 Github to alert maintainers when this is the case.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>It is desirable if both the Python and Rust parts of the application end up
logging using the same configuration into the same place.</p>
<p>This section of the guide briefly discusses how to connect the two languages'
logging ecosystems together. The recommended way for Python extension modules is
to configure Rust's logger to send log messages to Python using the <code>pyo3-log</code>
crate. For users who want to do the opposite and send Python log messages to
Rust, see the note at the end of this guide.</p>
<h2 id="using-pyo3-log-to-send-rust-log-messages-to-python"><a class="header" href="#using-pyo3-log-to-send-rust-log-messages-to-python">Using <code>pyo3-log</code> to send Rust log messages to Python</a></h2>
<p>The <a href="https://crates.io/crates/pyo3-log">pyo3-log</a> crate allows sending the messages from the Rust side to Python's
<a href="https://docs.python.org/3/library/logging.html">logging</a> system. This is mostly suitable for writing native extensions for
Python programs.</p>
<p>Use <a href="https://docs.rs/pyo3-log/*/pyo3_log/fn.init.html"><code>pyo3_log::init</code></a> to install the logger in its default configuration.
It's also possible to tweak its configuration (mostly to tune its performance).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use log::info;
use pyo3::prelude::*;

#[pyfunction]
fn log_something() {
    // This will use the logger installed in `my_module` to send the `info`
    // message to the Python logging facilities.
    info!(&quot;Something!&quot;);
}

#[pymodule]
fn my_module(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    // A good place to install the Rust -&gt; Python logger.
    pyo3_log::init();

    m.add_function(wrap_pyfunction!(log_something))?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Then it is up to the Python side to actually output the messages somewhere.</p>
<pre><code class="language-python">import logging
import my_module

FORMAT = '%(levelname)s %(name)s %(asctime)-15s %(filename)s:%(lineno)d %(message)s'
logging.basicConfig(format=FORMAT)
logging.getLogger().setLevel(logging.INFO)
my_module.log_something()
</code></pre>
<p>It is important to initialize the Python loggers first, before calling any Rust
functions that may log. This limitation can be worked around if it is not
possible to satisfy, read the documentation about <a href="https://docs.rs/pyo3-log/*/pyo3_log/#performance-filtering-and-caching">caching</a>.</p>
<h2 id="the-python-to-rust-direction"><a class="header" href="#the-python-to-rust-direction">The Python to Rust direction</a></h2>
<p>To best of our knowledge nobody implemented the reverse direction yet, though it
should be possible. If interested, the <code>pyo3</code> community would be happy to
provide guidance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async--await"><a class="header" href="#async--await">Async / Await</a></h1>
<p>If you are working with a Python library that makes use of async functions or wish to provide
Python bindings for an async Rust library, <a href="https://github.com/awestlake87/pyo3-asyncio"><code>pyo3-asyncio</code></a>
likely has the tools you need. It provides conversions between async functions in both Python and
Rust and was designed with first-class support for popular Rust runtimes such as
<a href="https://tokio.rs/"><code>tokio</code></a> and <a href="https://async.rs/"><code>async-std</code></a>. In addition, all async Python
code runs on the default <code>asyncio</code> event loop, so <code>pyo3-asyncio</code> should work just fine with existing
Python libraries.</p>
<p>In the following sections, we'll give a general overview of <code>pyo3-asyncio</code> explaining how to call
async Python functions with PyO3, how to call async Rust functions from Python, and how to configure
your codebase to manage the runtimes of both.</p>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>Here are some examples to get you started right away! A more detailed breakdown
of the concepts in these examples can be found in the following sections.</p>
<h3 id="rust-applications"><a class="header" href="#rust-applications">Rust Applications</a></h3>
<p>Here we initialize the runtime, import Python's <code>asyncio</code> library and run the given future to completion using Python's default <code>EventLoop</code> and <code>async-std</code>. Inside the future, we convert <code>asyncio</code> sleep into a Rust future and await it.</p>
<pre><code class="language-toml"># Cargo.toml dependencies
[dependencies]
pyo3 = { version = &quot;0.14&quot; }
pyo3-asyncio = { version = &quot;0.14&quot;, features = [&quot;attributes&quot;, &quot;async-std-runtime&quot;] }
async-std = &quot;1.9&quot;
</code></pre>
<pre><pre class="playground"><code class="language-rust">//! main.rs

use pyo3::prelude::*;

#[pyo3_asyncio::async_std::main]
async fn main() -&gt; PyResult&lt;()&gt; {
    let fut = Python::with_gil(|py| {
        let asyncio = py.import(&quot;asyncio&quot;)?;
        // convert asyncio.sleep into a Rust Future
        pyo3_asyncio::async_std::into_future(asyncio.call_method1(&quot;sleep&quot;, (1.into_py(py),))?)
    })?;

    fut.await?;

    Ok(())
}
</code></pre></pre>
<p>The same application can be written to use <code>tokio</code> instead using the <code>#[pyo3_asyncio::tokio::main]</code>
attribute.</p>
<pre><code class="language-toml"># Cargo.toml dependencies
[dependencies]
pyo3 = { version = &quot;0.14&quot; }
pyo3-asyncio = { version = &quot;0.14&quot;, features = [&quot;attributes&quot;, &quot;tokio-runtime&quot;] }
tokio = &quot;1.4&quot;
</code></pre>
<pre><pre class="playground"><code class="language-rust">//! main.rs

use pyo3::prelude::*;

#[pyo3_asyncio::tokio::main]
async fn main() -&gt; PyResult&lt;()&gt; {
    let fut = Python::with_gil(|py| {
        let asyncio = py.import(&quot;asyncio&quot;)?;
        // convert asyncio.sleep into a Rust Future
        pyo3_asyncio::tokio::into_future(asyncio.call_method1(&quot;sleep&quot;, (1.into_py(py),))?)
    })?;

    fut.await?;

    Ok(())
}
</code></pre></pre>
<p>More details on the usage of this library can be found in the <a href="https://awestlake87.github.io/pyo3-asyncio/master/doc">API docs</a> and the primer below.</p>
<h3 id="pyo3-native-rust-modules"><a class="header" href="#pyo3-native-rust-modules">PyO3 Native Rust Modules</a></h3>
<p>PyO3 Asyncio can also be used to write native modules with async functions.</p>
<p>Add the <code>[lib]</code> section to <code>Cargo.toml</code> to make your library a <code>cdylib</code> that Python can import.</p>
<pre><code class="language-toml">[lib]
name = &quot;my_async_module&quot;
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>Make your project depend on <code>pyo3</code> with the <code>extension-module</code> feature enabled and select your
<code>pyo3-asyncio</code> runtime:</p>
<p>For <code>async-std</code>:</p>
<pre><code class="language-toml">[dependencies]
pyo3 = { version = &quot;0.14&quot;, features = [&quot;extension-module&quot;] }
pyo3-asyncio = { version = &quot;0.14&quot;, features = [&quot;async-std-runtime&quot;] }
async-std = &quot;1.9&quot;
</code></pre>
<p>For <code>tokio</code>:</p>
<pre><code class="language-toml">[dependencies]
pyo3 = { version = &quot;0.14&quot;, features = [&quot;extension-module&quot;] }
pyo3-asyncio = { version = &quot;0.14&quot;, features = [&quot;tokio-runtime&quot;] }
tokio = &quot;1.4&quot;
</code></pre>
<p>Export an async function that makes use of <code>async-std</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! lib.rs

use pyo3::{prelude::*, wrap_pyfunction};

#[pyfunction]
fn rust_sleep(py: Python) -&gt; PyResult&lt;&amp;PyAny&gt; {
    pyo3_asyncio::async_std::future_into_py(py, async {
        async_std::task::sleep(std::time::Duration::from_secs(1)).await;
        Ok(Python::with_gil(|py| py.None()))
    })
}

#[pymodule]
fn my_async_module(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(rust_sleep, m)?)?;

    Ok(())
}

<span class="boring">}
</span></code></pre></pre>
<p>If you want to use <code>tokio</code> instead, here's what your module should look like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! lib.rs

use pyo3::{prelude::*, wrap_pyfunction};

#[pyfunction]
fn rust_sleep(py: Python) -&gt; PyResult&lt;&amp;PyAny&gt; {
    pyo3_asyncio::tokio::future_into_py(py, async {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        Ok(Python::with_gil(|py| py.None()))
    })
}

#[pymodule]
fn my_async_module(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(rust_sleep, m)?)?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>You can build your module with maturin (see the <a href="https://pyo3.rs/main/#using-rust-from-python">Using Rust in Python</a> section in the PyO3 guide for setup instructions). After that you should be able to run the Python REPL to try it out.</p>
<pre><code class="language-bash">maturin develop &amp;&amp; python3
ðŸ”— Found pyo3 bindings
ðŸ Found CPython 3.8 at python3
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
Python 3.8.5 (default, Jan 27 2021, 15:41:15)
[GCC 9.3.0] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import asyncio
&gt;&gt;&gt;
&gt;&gt;&gt; from my_async_module import rust_sleep
&gt;&gt;&gt;
&gt;&gt;&gt; async def main():
&gt;&gt;&gt;     await rust_sleep()
&gt;&gt;&gt;
&gt;&gt;&gt; # should sleep for 1s
&gt;&gt;&gt; asyncio.run(main())
&gt;&gt;&gt;
</code></pre>
<h2 id="awaiting-an-async-python-function-in-rust"><a class="header" href="#awaiting-an-async-python-function-in-rust">Awaiting an Async Python Function in Rust</a></h2>
<p>Let's take a look at a dead simple async Python function:</p>
<pre><code class="language-python"># Sleep for 1 second
async def py_sleep():
    await asyncio.sleep(1)
</code></pre>
<p><strong>Async functions in Python are simply functions that return a <code>coroutine</code> object</strong>. For our purposes,
we really don't need to know much about these <code>coroutine</code> objects. The key factor here is that calling
an <code>async</code> function is <em>just like calling a regular function</em>, the only difference is that we have
to do something special with the object that it returns.</p>
<p>Normally in Python, that something special is the <code>await</code> keyword, but in order to await this
coroutine in Rust, we first need to convert it into Rust's version of a <code>coroutine</code>: a <code>Future</code>.
That's where <code>pyo3-asyncio</code> comes in.
<a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/fn.into_future.html"><code>pyo3_asyncio::into_future</code></a>
performs this conversion for us.</p>
<p>The following example uses <code>into_future</code> to call the <code>py_sleep</code> function shown above and then await the
coroutine object returned from the call:</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

#[pyo3_asyncio::tokio::main]
async fn main() -&gt; PyResult&lt;()&gt; {
    let future = Python::with_gil(|py| -&gt; PyResult&lt;_&gt; {
        // import the module containing the py_sleep function
        let example = py.import(&quot;example&quot;)?;

        // calling the py_sleep method like a normal function
        // returns a coroutine
        let coroutine = example.call_method0(&quot;py_sleep&quot;)?;

        // convert the coroutine into a Rust future using the
        // tokio runtime
        pyo3_asyncio::tokio::into_future(coroutine)
    })?;

    // await the future
    future.await?;

    Ok(())
}
</code></pre></pre>
<p>Alternatively, the below example shows how to write a <code>#[pyfunction]</code> which uses <code>into_future</code> to receive and await
a coroutine argument:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pyfunction]
fn await_coro(coro: &amp;PyAny) -&gt; PyResult&lt;()&gt; {
    // convert the coroutine into a Rust future using the
    // async_std runtime
    let f = pyo3_asyncio::async_std::into_future(coro)?;

    pyo3_asyncio::async_std::run_until_complete(coro.py(), async move {
        // await the future
        f.await?;
        Ok(())
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This could be called from Python as:</p>
<pre><code class="language-python">import asyncio

async def py_sleep():
    asyncio.sleep(1)

await_coro(py_sleep())
</code></pre>
<p>If for you wanted to pass a callable function to the <code>#[pyfunction]</code> instead, (i.e. the last line becomes <code>await_coro(py_sleep))</code>, then the above example needs to be tweaked to first call the callable to get the coroutine:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pyfunction]
fn await_coro(callable: &amp;PyAny) -&gt; PyResult&lt;()&gt; {
    // get the coroutine by calling the callable
    let coro = callable.call0()?;

    // convert the coroutine into a Rust future using the
    // async_std runtime
    let f = pyo3_asyncio::async_std::into_future(coro)?;

    pyo3_asyncio::async_std::run_until_complete(coro.py(), async move {
        // await the future
        f.await?;
        Ok(())
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This can be particularly helpful where you need to repeatedly create and await a coroutine. Trying to await the same coroutine multiple times will raise an error:</p>
<pre><code class="language-python">RuntimeError: cannot reuse already awaited coroutine
</code></pre>
<blockquote>
<p>If you're interested in learning more about <code>coroutines</code> and <code>awaitables</code> in general, check out the
<a href="https://docs.python.org/3/library/asyncio-task.html">Python 3 <code>asyncio</code> docs</a> for more information.</p>
</blockquote>
<h2 id="awaiting-a-rust-future-in-python"><a class="header" href="#awaiting-a-rust-future-in-python">Awaiting a Rust Future in Python</a></h2>
<p>Here we have the same async function as before written in Rust using the
<a href="https://async.rs/"><code>async-std</code></a> runtime:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Sleep for 1 second
async fn rust_sleep() {
    async_std::task::sleep(std::time::Duration::from_secs(1)).await;
}
<span class="boring">}
</span></code></pre></pre>
<p>Similar to Python, Rust's async functions also return a special object called a
<code>Future</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let future = rust_sleep();
<span class="boring">}
</span></code></pre></pre>
<p>We can convert this <code>Future</code> object into Python to make it <code>awaitable</code>. This tells Python that you
can use the <code>await</code> keyword with it. In order to do this, we'll call
<a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.future_into_py.html"><code>pyo3_asyncio::async_std::future_into_py</code></a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

async fn rust_sleep() {
    async_std::task::sleep(std::time::Duration::from_secs(1)).await;
}

#[pyfunction]
fn call_rust_sleep(py: Python) -&gt; PyResult&lt;&amp;PyAny&gt; {
    pyo3_asyncio::async_std::future_into_py(py, async move {
        rust_sleep().await;
        Ok(Python::with_gil(|py| py.None()))
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>In Python, we can call this pyo3 function just like any other async function:</p>
<pre><code class="language-python">from example import call_rust_sleep

async def rust_sleep():
    await call_rust_sleep()
</code></pre>
<h2 id="managing-event-loops"><a class="header" href="#managing-event-loops">Managing Event Loops</a></h2>
<p>Python's event loop requires some special treatment, especially regarding the main thread. Some of
Python's <code>asyncio</code> features, like proper signal handling, require control over the main thread, which
doesn't always play well with Rust.</p>
<p>Luckily, Rust's event loops are pretty flexible and don't <em>need</em> control over the main thread, so in
<code>pyo3-asyncio</code>, we decided the best way to handle Rust/Python interop was to just surrender the main
thread to Python and run Rust's event loops in the background. Unfortunately, since most event loop
implementations <em>prefer</em> control over the main thread, this can still make some things awkward.</p>
<h3 id="pyo3-asyncio-initialization"><a class="header" href="#pyo3-asyncio-initialization">PyO3 Asyncio Initialization</a></h3>
<p>Because Python needs to control the main thread, we can't use the convenient proc macros from Rust
runtimes to handle the <code>main</code> function or <code>#[test]</code> functions. Instead, the initialization for PyO3 has to be done from the <code>main</code> function and the main
thread must block on <a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/fn.run_forever.html"><code>pyo3_asyncio::run_forever</code></a> or <a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.run_until_complete.html"><code>pyo3_asyncio::async_std::run_until_complete</code></a>.</p>
<p>Because we have to block on one of those functions, we can't use <a href="https://docs.rs/async-std/latest/async_std/attr.main.html"><code>#[async_std::main]</code></a> or <a href="https://docs.rs/tokio/1.1.0/tokio/attr.main.html"><code>#[tokio::main]</code></a>
since it's not a good idea to make long blocking calls during an async function.</p>
<blockquote>
<p>Internally, these <code>#[main]</code> proc macros are expanded to something like this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // your async main fn
    async fn _main_impl() { /* ... */ }
    Runtime::new().block_on(_main_impl());
}
</code></pre></pre>
<p>Making a long blocking call inside the <code>Future</code> that's being driven by <code>block_on</code> prevents that
thread from doing anything else and can spell trouble for some runtimes (also this will actually
deadlock a single-threaded runtime!). Many runtimes have some sort of <code>spawn_blocking</code> mechanism
that can avoid this problem, but again that's not something we can use here since we need it to
block on the <em>main</em> thread.</p>
</blockquote>
<p>For this reason, <code>pyo3-asyncio</code> provides its own set of proc macros to provide you with this
initialization. These macros are intended to mirror the initialization of <code>async-std</code> and <code>tokio</code>
while also satisfying the Python runtime's needs.</p>
<p>Here's a full example of PyO3 initialization with the <code>async-std</code> runtime:</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

#[pyo3_asyncio::async_std::main]
async fn main() -&gt; PyResult&lt;()&gt; {
    // PyO3 is initialized - Ready to go

    let fut = Python::with_gil(|py| -&gt; PyResult&lt;_&gt; {
        let asyncio = py.import(&quot;asyncio&quot;)?;

        // convert asyncio.sleep into a Rust Future
        pyo3_asyncio::async_std::into_future(
            asyncio.call_method1(&quot;sleep&quot;, (1.into_py(py),))?
        )
    })?;

    fut.await?;

    Ok(())
}
</code></pre></pre>
<h3 id="a-note-about-asynciorun"><a class="header" href="#a-note-about-asynciorun">A Note About <code>asyncio.run</code></a></h3>
<p>In Python 3.7+, the recommended way to run a top-level coroutine with <code>asyncio</code>
is with <code>asyncio.run</code>. In <code>v0.13</code> we recommended against using this function due to initialization issues, but in <code>v0.14</code> it's perfectly valid to use this function... with a caveat.</p>
<p>Since our Rust &lt;--&gt; Python conversions require a reference to the Python event loop, this poses a problem. Imagine we have a PyO3 Asyncio module that defines
a <code>rust_sleep</code> function like in previous examples. You might rightfully assume that you can call pass this directly into <code>asyncio.run</code> like this:</p>
<pre><code class="language-python">import asyncio

from my_async_module import rust_sleep

asyncio.run(rust_sleep())
</code></pre>
<p>You might be surprised to find out that this throws an error:</p>
<pre><code class="language-bash">Traceback (most recent call last):
  File &quot;example.py&quot;, line 5, in &lt;module&gt;
    asyncio.run(rust_sleep())
RuntimeError: no running event loop
</code></pre>
<p>What's happening here is that we are calling <code>rust_sleep</code> <em>before</em> the future is
actually running on the event loop created by <code>asyncio.run</code>. This is counter-intuitive, but expected behaviour, and unfortunately there doesn't seem to be a good way of solving this problem within PyO3 Asyncio itself.</p>
<p>However, we can make this example work with a simple workaround:</p>
<pre><code class="language-python">import asyncio

from my_async_module import rust_sleep

# Calling main will just construct the coroutine that later calls rust_sleep.
# - This ensures that rust_sleep will be called when the event loop is running,
#   not before.
async def main():
    await rust_sleep()

# Run the main() coroutine at the top-level instead
asyncio.run(main())
</code></pre>
<h3 id="non-standard-python-event-loops"><a class="header" href="#non-standard-python-event-loops">Non-standard Python Event Loops</a></h3>
<p>Python allows you to use alternatives to the default <code>asyncio</code> event loop. One
popular alternative is <code>uvloop</code>. In <code>v0.13</code> using non-standard event loops was
a bit of an ordeal, but in <code>v0.14</code> it's trivial.</p>
<h4 id="using-uvloop-in-a-pyo3-asyncio-native-extensions"><a class="header" href="#using-uvloop-in-a-pyo3-asyncio-native-extensions">Using <code>uvloop</code> in a PyO3 Asyncio Native Extensions</a></h4>
<pre><code class="language-toml"># Cargo.toml

[lib]
name = &quot;my_async_module&quot;
crate-type = [&quot;cdylib&quot;]

[dependencies]
pyo3 = { version = &quot;0.14&quot;, features = [&quot;extension-module&quot;] }
pyo3-asyncio = { version = &quot;0.14&quot;, features = [&quot;tokio-runtime&quot;] }
async-std = &quot;1.9&quot;
tokio = &quot;1.4&quot;
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! lib.rs

use pyo3::{prelude::*, wrap_pyfunction};

#[pyfunction]
fn rust_sleep(py: Python) -&gt; PyResult&lt;&amp;PyAny&gt; {
    pyo3_asyncio::tokio::future_into_py(py, async {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        Ok(Python::with_gil(|py| py.None()))
    })
}

#[pymodule]
fn my_async_module(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(rust_sleep, m)?)?;

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-bash">$ maturin develop &amp;&amp; python3
ðŸ”— Found pyo3 bindings
ðŸ Found CPython 3.8 at python3
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
Python 3.8.8 (default, Apr 13 2021, 19:58:26)
[GCC 7.3.0] :: Anaconda, Inc. on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import asyncio
&gt;&gt;&gt; import uvloop
&gt;&gt;&gt;
&gt;&gt;&gt; import my_async_module
&gt;&gt;&gt;
&gt;&gt;&gt; uvloop.install()
&gt;&gt;&gt;
&gt;&gt;&gt; async def main():
...     await my_async_module.rust_sleep()
...
&gt;&gt;&gt; asyncio.run(main())
&gt;&gt;&gt;
</code></pre>
<h4 id="using-uvloop-in-rust-applications"><a class="header" href="#using-uvloop-in-rust-applications">Using <code>uvloop</code> in Rust Applications</a></h4>
<p>Using <code>uvloop</code> in Rust applications is a bit trickier, but it's still possible
with relatively few modifications.</p>
<p>Unfortunately, we can't make use of the <code>#[pyo3_asyncio::&lt;runtime&gt;::main]</code> attribute with non-standard event loops. This is because the <code>#[pyo3_asyncio::&lt;runtime&gt;::main]</code> proc macro has to interact with the Python
event loop before we can install the <code>uvloop</code> policy.</p>
<pre><code class="language-toml">[dependencies]
async-std = &quot;1.9&quot;
pyo3 = &quot;0.14&quot;
pyo3-asyncio = { version = &quot;0.14&quot;, features = [&quot;async-std-runtime&quot;] }
</code></pre>
<pre><pre class="playground"><code class="language-rust">//! main.rs

use pyo3::{prelude::*, types::PyType};

fn main() -&gt; PyResult&lt;()&gt; {
    pyo3::prepare_freethreaded_python();

    Python::with_gil(|py| {
        let uvloop = py.import(&quot;uvloop&quot;)?;
        uvloop.call_method0(&quot;install&quot;)?;

        // store a reference for the assertion
        let uvloop = PyObject::from(uvloop);

        pyo3_asyncio::async_std::run(py, async move {
            // verify that we are on a uvloop.Loop
            Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
                assert!(uvloop
                    .as_ref(py)
                    .getattr(&quot;Loop&quot;)?
                    .downcast::&lt;PyType&gt;()
                    .unwrap()
                    .is_instance(pyo3_asyncio::async_std::get_current_loop(py)?)?);
                Ok(())
            })?;

            async_std::task::sleep(std::time::Duration::from_secs(1)).await;

            Ok(())
        })
    })
}
</code></pre></pre>
<h2 id="additional-information"><a class="header" href="#additional-information">Additional Information</a></h2>
<ul>
<li>Managing event loop references can be tricky with pyo3-asyncio. See <a href="https://docs.rs/pyo3-asyncio/#event-loop-references">Event Loop References</a> in the API docs to get a better intuition for how event loop references are managed in this library.</li>
<li>Testing pyo3-asyncio libraries and applications requires a custom test harness since Python requires control over the main thread. You can find a testing guide in the <a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/testing">API docs for the <code>testing</code> module</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions--troubleshooting"><a class="header" href="#frequently-asked-questions--troubleshooting">Frequently Asked Questions / Troubleshooting</a></h1>
<h2 id="im-experiencing-deadlocks-using-pyo3-with-lazy_static-or-once_cell"><a class="header" href="#im-experiencing-deadlocks-using-pyo3-with-lazy_static-or-once_cell">I'm experiencing deadlocks using PyO3 with lazy_static or once_cell!</a></h2>
<p><code>lazy_static</code> and <code>once_cell::sync</code> both use locks to ensure that initialization is performed only by a single thread. Because the Python GIL is an additional lock this can lead to deadlocks in the following way:</p>
<ol>
<li>A thread (thread A) which has acquired the Python GIL starts initialization of a <code>lazy_static</code> value.</li>
<li>The initialization code calls some Python API which temporarily releases the GIL e.g. <code>Python::import</code>.</li>
<li>Another thread (thread B) acquires the Python GIL and attempts to access the same <code>lazy_static</code> value.</li>
<li>Thread B is blocked, because it waits for <code>lazy_static</code>'s initialization to lock to release.</li>
<li>Thread A is blocked, because it waits to re-aquire the GIL which thread B still holds.</li>
<li>Deadlock.</li>
</ol>
<p>PyO3 provides a struct <a href="https://docs.rs/pyo3/0.14.4/pyo3/once_cell/struct.GILOnceCell.html"><code>GILOnceCell</code></a> which works equivalently to <code>OnceCell</code> but relies solely on the Python GIL for thread safety. This means it can be used in place of <code>lazy_static</code> or <code>once_cell</code> where you are experiencing the deadlock described above. See the documentation for <a href="https://docs.rs/pyo3/0.14.4/pyo3/once_cell/struct.GILOnceCell.html"><code>GILOnceCell</code></a> for an example how to use it.</p>
<h2 id="i-cant-run-cargo-test-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-_pyexc_systemerror"><a class="header" href="#i-cant-run-cargo-test-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-_pyexc_systemerror">I can't run <code>cargo test</code>: I'm having linker issues like &quot;Symbol not found&quot; or &quot;Undefined reference to _PyExc_SystemError&quot;!</a></h2>
<p>Currently, <a href="https://github.com/PyO3/pyo3/issues/340">#340</a> causes <code>cargo test</code> to fail with linking errors when the <code>extension-module</code> feature is activated. For now you can work around this by making the <code>extension-module</code> feature optional and running the tests with <code>cargo test --no-default-features</code>:</p>
<pre><code class="language-toml">[dependencies.pyo3]
version = &quot;version = &quot;0.14.4&quot;&quot;

[features]
extension-module = [&quot;pyo3/extension-module&quot;]
default = [&quot;extension-module&quot;]
</code></pre>
<h2 id="i-cant-run-cargo-test-my-crate-cannot-be-found-for-tests-in-tests-directory"><a class="header" href="#i-cant-run-cargo-test-my-crate-cannot-be-found-for-tests-in-tests-directory">I can't run <code>cargo test</code>: my crate cannot be found for tests in <code>tests/</code> directory!</a></h2>
<p>The Rust book suggests to <a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests">put integration tests inside a <code>tests/</code> directory</a>.</p>
<p>For a PyO3 <code>extension-module</code> project where the <code>crate-type</code> is set to <code>&quot;cdylib&quot;</code> in your <code>Cargo.toml</code>,
the compiler won't be able to find your crate and will display errors such as <code>E0432</code> or <code>E0463</code>:</p>
<pre><code class="language-text">error[E0432]: unresolved import `my_crate`
 --&gt; tests/test_my_crate.rs:1:5
  |
1 | use my_crate;
  |     ^^^^^^^^^^^^ no external crate `my_crate`
</code></pre>
<p>The best solution is to make your crate types include both <code>rlib</code> and <code>cdylib</code>:</p>
<pre><code class="language-toml"># Cargo.toml
[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]
</code></pre>
<h2 id="ctrl-c-doesnt-do-anything-while-my-rust-code-is-executing"><a class="header" href="#ctrl-c-doesnt-do-anything-while-my-rust-code-is-executing">Ctrl-C doesn't do anything while my Rust code is executing!</a></h2>
<p>This is because Ctrl-C raises a SIGINT signal, which is handled by the calling Python process by simply setting a flag to action upon later. This flag isn't checked while Rust code called from Python is executing, only once control returns to the Python interpreter.</p>
<p>You can give the Python interpreter a chance to process the signal properly by calling <code>Python::check_signals</code>. It's good practice to call this function regularly if you have a long-running Rust function so that your users can cancel it.</p>
<h2 id="pyo3get-clones-my-field"><a class="header" href="#pyo3get-clones-my-field"><code>#[pyo3(get)]</code> clones my field!</a></h2>
<p>You may have a nested struct similar to this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
#[derive(Clone)]
struct Inner { /* fields omitted */ }

#[pyclass]
struct Outer {
    #[pyo3(get)]
    inner: Inner,
}

#[pymethods]
impl Outer {
    #[new]
    fn __new__() -&gt; Self {
        Self { inner: Inner {} }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>When Python code accesses <code>Outer</code>'s field, PyO3 will return a new object on every access (note that their addresses are different):</p>
<pre><code class="language-python">outer = Outer()

a = outer.inner
b = outer.inner

assert a is b, f&quot;a: {a}\nb: {b}&quot;
</code></pre>
<pre><code class="language-text">AssertionError: a: &lt;builtins.Inner object at 0x00000238FFB9C7B0&gt;
b: &lt;builtins.Inner object at 0x00000238FFB9C830&gt;
</code></pre>
<p>This can be especially confusing if the field is mutable, as getting the field and then mutating it won't persist - you'll just get a fresh clone of the original on the next access. Unfortunately Python and Rust don't agree about ownership - if PyO3 gave out references to (possibly) temporary Rust objects to Python code, Python code could then keep that reference alive indefinitely. Therefore returning Rust objects requires cloning.</p>
<p>If you don't want that cloning to happen, a workaround is to allocate the field on the Python heap and store a reference to that, by using <a href="https://docs.rs/pyo3/0.14.4/pyo3/struct.Py.html"><code>Py&lt;...&gt;</code></a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
#[derive(Clone)]
struct Inner { /* fields omitted */ }

#[pyclass]
struct Outer {
    #[pyo3(get)]
    inner: Py&lt;Inner&gt;,
}

#[pymethods]
impl Outer {
    #[new]
    fn __new__(py: Python) -&gt; PyResult&lt;Self&gt; {
        Ok(Self {
            inner: Py::new(py, Inner {})?,
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This time <code>a</code> and <code>b</code> <em>are</em> the same object:</p>
<pre><code class="language-python">outer = Outer()

a = outer.inner
b = outer.inner

assert a is b, f&quot;a: {a}\nb: {b}&quot;
print(f&quot;a: {a}\nb: {b}&quot;)
</code></pre>
<pre><code class="language-text">a: &lt;builtins.Inner object at 0x0000020044FCC670&gt;
b: &lt;builtins.Inner object at 0x0000020044FCC670&gt;
</code></pre>
<p>The downside to this approach is that any Rust code working on the <code>Outer</code> struct now has to acquire the GIL to do anything with its field.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-older-pyo3-versions"><a class="header" href="#migrating-from-older-pyo3-versions">Migrating from older PyO3 versions</a></h1>
<p>This guide can help you upgrade code through breaking changes from one PyO3 version to the next.
For a detailed list of all changes, see the <a href="changelog.html">CHANGELOG</a>.</p>
<h2 id="from-013-to-014"><a class="header" href="#from-013-to-014">from 0.13.* to 0.14</a></h2>
<h3 id="auto-initialize-feature-is-now-opt-in"><a class="header" href="#auto-initialize-feature-is-now-opt-in"><code>auto-initialize</code> feature is now opt-in</a></h3>
<p>For projects embedding Python in Rust, PyO3 no longer automatically initalizes a Python interpreter on the first call to <code>Python::with_gil</code> (or <code>Python::acquire_gil</code>) unless the <a href="features.html#auto-initalize"><code>auto-initalize</code> feature</a> is enabled.</p>
<h3 id="new-multiple-pymethods-feature"><a class="header" href="#new-multiple-pymethods-feature">New <code>multiple-pymethods</code> feature</a></h3>
<p><code>#[pymethods]</code> have been reworked with a simpler default implementation which removes the dependency on the <code>inventory</code> crate. This reduces dependencies and compile times for the majority of users.</p>
<p>The limitation of the new default implementation is that it cannot support multiple <code>#[pymethods]</code> blocks for the same <code>#[pyclass]</code>. If you need this functionality, you must enable the <code>multiple-pymethods</code> feature which will switch <code>#[pymethods]</code> to the inventory-based implementation.</p>
<h3 id="deprecated-pyproto-methods"><a class="header" href="#deprecated-pyproto-methods">Deprecated <code>#[pyproto]</code> methods</a></h3>
<p>Some protocol (aka <code>__dunder__</code>) methods such as <code>__bytes__</code> and <code>__format__</code> have been possible to implement two ways in PyO3 for some time: via a <code>#[pyproto]</code> (e.g. <code>PyBasicProtocol</code> for the methods listed here), or by writing them directly in <code>#[pymethods]</code>. This is only true for a handful of the <code>#[pyproto]</code> methods (for technical reasons to do with the way PyO3 currently interacts with the Python C-API).</p>
<p>In the interest of having onle one way to do things, the <code>#[pyproto]</code> forms of these methods have been deprecated.</p>
<p>To migrate just move the affected methods from a <code>#[pyproto]</code> to a <code>#[pymethods]</code> block.</p>
<p>Before:</p>
<pre><code class="language-rust ignore">use pyo3::prelude::*;
use pyo3::class::basic::PyBasicProtocol;

#[pyclass]
struct MyClass { }

#[pyproto]
impl PyBasicProtocol for MyClass {
    fn __bytes__(&amp;self) -&gt; &amp;'static [u8] {
        b&quot;hello, world&quot;
    }
}
</code></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass]
struct MyClass { }

#[pymethods]
impl MyClass {
    fn __bytes__(&amp;self) -&gt; &amp;'static [u8] {
        b&quot;hello, world&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="from-012-to-013"><a class="header" href="#from-012-to-013">from 0.12.* to 0.13</a></h2>
<h3 id="minimum-rust-version-increased-to-rust-145"><a class="header" href="#minimum-rust-version-increased-to-rust-145">Minimum Rust version increased to Rust 1.45</a></h3>
<p>PyO3 <code>0.13</code> makes use of new Rust language features stabilised between Rust 1.40 and Rust 1.45. If you are using a Rust compiler older than Rust 1.45, you will need to update your toolchain to be able to continue using PyO3.</p>
<h3 id="runtime-changes-to-support-the-cpython-limited-api"><a class="header" href="#runtime-changes-to-support-the-cpython-limited-api">Runtime changes to support the CPython limited API</a></h3>
<p>In PyO3 <code>0.13</code> support was added for compiling against the CPython limited API. This had a number of implications for <em>all</em> PyO3 users, described here.</p>
<p>The largest of these is that all types created from PyO3 are what CPython calls &quot;heap&quot; types. The specific implications of this are:</p>
<ul>
<li>If you wish to subclass one of these types <em>from Rust</em> you must mark it <code>#[pyclass(subclass)]</code>, as you would if you wished to allow subclassing it from Python code.</li>
<li>Type objects are now mutable - Python code can set attributes on them.</li>
<li><code>__module__</code> on types without <code>#[pyclass(module=&quot;mymodule&quot;)]</code> no longer returns <code>builtins</code>, it now raises <code>AttributeError</code>.</li>
</ul>
<h2 id="from-011-to-012"><a class="header" href="#from-011-to-012">from 0.11.* to 0.12</a></h2>
<h3 id="pyerr-has-been-reworked"><a class="header" href="#pyerr-has-been-reworked"><code>PyErr</code> has been reworked</a></h3>
<p>In PyO3 <code>0.12</code> the <code>PyErr</code> type has been re-implemented to be significantly more compatible with
the standard Rust error handling ecosystem. Specificially <code>PyErr</code> now implements
<code>Error + Send + Sync</code>, which are the standard traits used for error types.</p>
<p>While this has necessitated the removal of a number of APIs, the resulting <code>PyErr</code> type should now
be much more easier to work with. The following sections list the changes in detail and how to
migrate to the new APIs.</p>
<h4 id="pyerrnew-and-pyerrfrom_type-now-require-send--sync-for-their-argument"><a class="header" href="#pyerrnew-and-pyerrfrom_type-now-require-send--sync-for-their-argument"><code>PyErr::new</code> and <code>PyErr::from_type</code> now require <code>Send + Sync</code> for their argument</a></h4>
<p>For most uses no change will be needed. If you are trying to construct <code>PyErr</code> from a value that is
not <code>Send + Sync</code>, you will need to first create the Python object and then use
<code>PyErr::from_instance</code>.</p>
<p>Similarly, any types which implemented <code>PyErrArguments</code> will now need to be <code>Send + Sync</code>.</p>
<h4 id="pyerrs-contents-are-now-private"><a class="header" href="#pyerrs-contents-are-now-private"><code>PyErr</code>'s contents are now private</a></h4>
<p>It is no longer possible to access the fields <code>.ptype</code>, <code>.pvalue</code> and <code>.ptraceback</code> of a <code>PyErr</code>.
You should instead now use the new methods <code>PyErr::ptype()</code>, <code>PyErr::pvalue()</code> and <code>PyErr::ptraceback()</code>.</p>
<h4 id="pyerrvalue-and-pyerrfrom_value-have-been-removed"><a class="header" href="#pyerrvalue-and-pyerrfrom_value-have-been-removed"><code>PyErrValue</code> and <code>PyErr::from_value</code> have been removed</a></h4>
<p>As these were part the internals of <code>PyErr</code> which have been reworked, these APIs no longer exist.</p>
<p>If you used this API, it is recommended to use <code>PyException::new_err</code> (see <a href="migration.html#exception-types-have-been-reworked">the section on
Exception types</a>).</p>
<h4 id="intopyresultt-for-pyerr-has-been-removed"><a class="header" href="#intopyresultt-for-pyerr-has-been-removed"><code>Into&lt;PyResult&lt;T&gt;&gt;</code> for <code>PyErr</code> has been removed</a></h4>
<p>This implementation was redundant. Just construct the <code>Result::Err</code> variant directly.</p>
<p>Before:</p>
<pre><code class="language-rust ignore">let result: PyResult&lt;()&gt; = PyErr::new::&lt;TypeError, _&gt;(&quot;error message&quot;).into();
</code></pre>
<p>After (also using the new reworked exception types; see the following section):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::{PyErr, PyResult, exceptions::PyTypeError};
</span>let result: PyResult&lt;()&gt; = Err(PyTypeError::new_err(&quot;error message&quot;));
<span class="boring">}
</span></code></pre></pre>
<h3 id="exception-types-have-been-reworked"><a class="header" href="#exception-types-have-been-reworked">Exception types have been reworked</a></h3>
<p>Previously exception types were zero-sized marker types purely used to construct <code>PyErr</code>. In PyO3
0.12, these types have been replaced with full definitions and are usable in the same way as <code>PyAny</code>, <code>PyDict</code> etc. This
makes it possible to interact with Python exception objects.</p>
<p>The new types also have names starting with the &quot;Py&quot; prefix. For example, before:</p>
<pre><code class="language-rust ignore">let err: PyErr = TypeError::py_err(&quot;error message&quot;);
</code></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::{PyErr, PyResult, Python, type_object::PyTypeObject};
</span><span class="boring">use pyo3::exceptions::{PyBaseException, PyTypeError};
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let err: PyErr = PyTypeError::new_err(&quot;error message&quot;);

// Uses Display for PyErr, new for PyO3 0.12
assert_eq!(err.to_string(), &quot;TypeError: error message&quot;);

// Now possible to interact with exception instances, new for PyO3 0.12
let instance: &amp;PyBaseException = err.instance(py);
assert_eq!(instance.getattr(&quot;__class__&quot;)?, PyTypeError::type_object(py).as_ref());
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="frompy-has-been-removed"><a class="header" href="#frompy-has-been-removed"><code>FromPy</code> has been removed</a></h3>
<p>To simplify the PyO3 conversion traits, the <code>FromPy</code> trait has been removed. Previously there were
two ways to define the to-Python conversion for a type:
<code>FromPy&lt;T&gt; for PyObject</code> and <code>IntoPy&lt;PyObject&gt; for T</code>.</p>
<p>Now there is only one way to define the conversion, <code>IntoPy</code>, so downstream crates may need to
adjust accordingly.</p>
<p>Before:</p>
<pre><code class="language-rust ignore"><span class="boring">use pyo3::prelude::*;
</span>struct MyPyObjectWrapper(PyObject);

impl FromPy&lt;MyPyObjectWrapper&gt; for PyObject {
    fn from_py(other: MyPyObjectWrapper, _py: Python) -&gt; Self {
        other.0
    }
}
</code></pre>
<p>After</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>struct MyPyObjectWrapper(PyObject);

impl IntoPy&lt;PyObject&gt; for MyPyObjectWrapper {
    fn into_py(self, _py: Python) -&gt; PyObject {
        self.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Similarly, code which was using the <code>FromPy</code> trait can be trivially rewritten to use <code>IntoPy</code>.</p>
<p>Before:</p>
<pre><code class="language-rust ignore"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">Python::with_gil(|py| {
</span>let obj = PyObject::from_py(1.234, py);
<span class="boring">})
</span></code></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">Python::with_gil(|py| {
</span>let obj: PyObject = 1.234.into_py(py);
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="pyobject-is-now-a-type-alias-of-pypyany"><a class="header" href="#pyobject-is-now-a-type-alias-of-pypyany"><code>PyObject</code> is now a type alias of <code>Py&lt;PyAny&gt;</code></a></h3>
<p>This should change very little from a usage perspective. If you implemented traits for both
<code>PyObject</code> and <code>Py&lt;T&gt;</code>, you may find you can just remove the <code>PyObject</code> implementation.</p>
<h3 id="aspyref-has-been-removed"><a class="header" href="#aspyref-has-been-removed"><code>AsPyRef</code> has been removed</a></h3>
<p>As <code>PyObject</code> has been changed to be just a type alias, the only remaining implementor of <code>AsPyRef</code>
was <code>Py&lt;T&gt;</code>. This removed the need for a trait, so the <code>AsPyRef::as_ref</code> method has been moved to
<code>Py::as_ref</code>.</p>
<p>This should require no code changes except removing <code>use pyo3::AsPyRef</code> for code which did not use
<code>pyo3::prelude::*</code>.</p>
<p>Before:</p>
<pre><code class="language-rust ignore">use pyo3::{AsPyRef, Py, types::PyList};
<span class="boring">pyo3::Python::with_gil(|py| {
</span>let list_py: Py&lt;PyList&gt; = PyList::empty(py).into();
let list_ref: &amp;PyList = list_py.as_ref(py);
<span class="boring">})
</span></code></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::{Py, types::PyList};
<span class="boring">pyo3::Python::with_gil(|py| {
</span>let list_py: Py&lt;PyList&gt; = PyList::empty(py).into();
let list_ref: &amp;PyList = list_py.as_ref(py);
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="from-010-to-011"><a class="header" href="#from-010-to-011">from 0.10.* to 0.11</a></h2>
<h3 id="stable-rust"><a class="header" href="#stable-rust">Stable Rust</a></h3>
<p>PyO3 now supports the stable Rust toolchain. The minimum required version is 1.39.0.</p>
<h3 id="pyclass-structs-must-now-be-send-or-unsendable"><a class="header" href="#pyclass-structs-must-now-be-send-or-unsendable"><code>#[pyclass]</code> structs must now be <code>Send</code> or <code>unsendable</code></a></h3>
<p>Because <code>#[pyclass]</code> structs can be sent between threads by the Python interpreter, they must implement
<code>Send</code> or declared as <code>unsendable</code> (by <code>#[pyclass(unsendable)]</code>).
Note that <code>unsendable</code> is added in PyO3 <code>0.11.1</code> and <code>Send</code> is always required in PyO3 <code>0.11.0</code>.</p>
<p>This may &quot;break&quot; some code which previously was accepted, even though it could be unsound.
There can be two fixes:</p>
<ol>
<li>
<p>If you think that your <code>#[pyclass]</code> actually must be <code>Send</code>able, then let's implement <code>Send</code>.
A common, safer way is using thread-safe types. E.g., <code>Arc</code> instead of <code>Rc</code>, <code>Mutex</code> instead of
<code>RefCell</code>, and <code>Box&lt;dyn Send + T&gt;</code> instead of <code>Box&lt;dyn T&gt;</code>.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use std::rc::Rc;
use std::cell::RefCell;

#[pyclass]
struct NotThreadSafe {
    shared_bools: Rc&lt;RefCell&lt;Vec&lt;bool&gt;&gt;&gt;,
    closure: Box&lt;dyn Fn()&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use std::sync::{Arc, Mutex};

#[pyclass]
struct ThreadSafe {
    shared_bools: Arc&lt;Mutex&lt;Vec&lt;bool&gt;&gt;&gt;,
    closure: Box&lt;dyn Fn() + Send&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>In situations where you cannot change your <code>#[pyclass]</code> to automatically implement <code>Send</code>
(e.g., when it contains a raw pointer), you can use <code>unsafe impl Send</code>.
In such cases, care should be taken to ensure the struct is actually thread safe.
See <a href="https://doc.rust-lang.org/nomicon/send-and-sync.html">the Rustnomicon</a> for more.</p>
</li>
<li>
<p>If you think that your <code>#[pyclass]</code> should not be accessed by another thread, you can use
<code>unsendable</code> flag. A class marked with <code>unsendable</code> panics when accessed by another thread,
making it thread-safe to expose an unsendable object to the Python interpreter.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass]
struct Unsendable {
    pointers: Vec&lt;*mut std::os::raw::c_char&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass(unsendable)]
struct Unsendable {
    pointers: Vec&lt;*mut std::os::raw::c_char&gt;,
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ol>
<h3 id="all-pyobject-and-pyt-methods-now-take-python-as-an-argument"><a class="header" href="#all-pyobject-and-pyt-methods-now-take-python-as-an-argument">All <code>PyObject</code> and <code>Py&lt;T&gt;</code> methods now take <code>Python</code> as an argument</a></h3>
<p>Previously, a few methods such as <code>Object::get_refcnt</code> did not take <code>Python</code> as an argument (to
ensure that the Python GIL was held by the current thread). Technically, this was not sound.
To migrate, just pass a <code>py</code> argument to any calls to these methods.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pyo3::Python::with_gil(|py| {
</span>py.None().get_refcnt();
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pyo3::Python::with_gil(|py| {
</span>py.None().get_refcnt(py);
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="from-09-to-010"><a class="header" href="#from-09-to-010">from 0.9.* to 0.10</a></h2>
<h3 id="objectprotocol-is-removed"><a class="header" href="#objectprotocol-is-removed"><code>ObjectProtocol</code> is removed</a></h3>
<p>All methods are moved to <a href="https://docs.rs/pyo3/0.14.4/pyo3/types/struct.PyAny.html"><code>PyAny</code></a>.
And since now all native types (e.g., <code>PyList</code>) implements <code>Deref&lt;Target=PyAny&gt;</code>,
all you need to do is remove <code>ObjectProtocol</code> from your code.
Or if you use <code>ObjectProtocol</code> by <code>use pyo3::prelude::*</code>, you have to do nothing.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::ObjectProtocol;

<span class="boring">pyo3::Python::with_gil(|py| {
</span>let obj = py.eval(&quot;lambda: 'Hi :)'&quot;, None, None).unwrap();
let hi: &amp;pyo3::types::PyString = obj.call0().unwrap().downcast().unwrap();
assert_eq!(hi.len().unwrap(), 5);
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pyo3::Python::with_gil(|py| {
</span>let obj = py.eval(&quot;lambda: 'Hi :)'&quot;, None, None).unwrap();
let hi: &amp;pyo3::types::PyString = obj.call0().unwrap().downcast().unwrap();
assert_eq!(hi.len().unwrap(), 5);
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="no-featurespecialization-in-user-code"><a class="header" href="#no-featurespecialization-in-user-code">No <code>#![feature(specialization)]</code> in user code</a></h3>
<p>While PyO3 itself still requires specialization and nightly Rust,
now you don't have to use <code>#![feature(specialization)]</code> in your crate.</p>
<h2 id="from-08-to-09"><a class="header" href="#from-08-to-09">from 0.8.* to 0.9</a></h2>
<h3 id="new-interface"><a class="header" href="#new-interface"><code>#[new]</code> interface</a></h3>
<p><a href="https://docs.rs/pyo3/0.8.5/pyo3/type_object/struct.PyRawObject.html"><code>PyRawObject</code></a>
is now removed and our syntax for constructors has changed.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
   #[new]
   fn new(obj: &amp;PyRawObject) {
       obj.init(MyClass { })
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
   #[new]
   fn new() -&gt; Self {
       MyClass {}
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Basically you can return <code>Self</code> or <code>Result&lt;Self&gt;</code> directly.
For more, see <a href="class.html#constructor">the constructor section</a> of this guide.</p>
<h3 id="pycell"><a class="header" href="#pycell">PyCell</a></h3>
<p>PyO3 0.9 introduces <a href="https://docs.rs/pyo3/0.14.4/pyo3/pycell/struct.PyCell.html"><code>PyCell</code></a>, which is a <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>-like object wrapper
for ensuring Rust's rules regarding aliasing of references are upheld.
For more detail, see the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#the-rules-of-references">Rust Book's section on Rust's rules of references</a></p>
<p>For <code>#[pymethods]</code> or <code>#[pyfunction]</code>s, your existing code should continue to work without any change.
Python exceptions will automatically be raised when your functions are used in a way which breaks Rust's
rules of references.</p>
<p>Here is an example.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct Names {
    names: Vec&lt;String&gt;
}

#[pymethods]
impl Names {
    #[new]
    fn new() -&gt; Self {
        Names { names: vec![] }
    }
    fn merge(&amp;mut self, other: &amp;mut Names) {
        self.names.append(&amp;mut other.names)
    }
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let names = PyCell::new(py, Names::new()).unwrap();
</span><span class="boring">    pyo3::py_run!(py, names, r&quot;
</span><span class="boring">    try:
</span><span class="boring">       names.merge(names)
</span><span class="boring">       assert False, 'Unreachable'
</span><span class="boring">    except RuntimeError as e:
</span><span class="boring">       assert str(e) == 'Already borrowed'
</span><span class="boring">    &quot;);
</span><span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p><code>Names</code> has a <code>merge</code> method, which takes <code>&amp;mut self</code> and another argument of type <code>&amp;mut Self</code>.
Given this <code>#[pyclass]</code>, calling <code>names.merge(names)</code> in Python raises
a <a href="https://docs.rs/pyo3/0.14.4/pyo3/pycell/struct.PyBorrowMutError.html"><code>PyBorrowMutError</code></a> exception, since it requires two mutable borrows of <code>names</code>.</p>
<p>However, for <code>#[pyproto]</code> and some functions, you need to manually fix the code.</p>
<h4 id="object-creation"><a class="header" href="#object-creation">Object creation</a></h4>
<p>In 0.8 object creation was done with <code>PyRef::new</code> and <code>PyRefMut::new</code>.
In 0.9 these have both been removed.
To upgrade code, please use
<a href="https://docs.rs/pyo3/0.14.4/pyo3/pycell/struct.PyCell.html#method.new"><code>PyCell::new</code></a> instead.
If you need <a href="https://docs.rs/pyo3/0.14.4/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> or <a href="https://docs.rs/pyo3/0.14.4/pyo3/pycell/struct.PyRef.html"><code>PyRefMut</code></a>, just call <code>.borrow()</code> or <code>.borrow_mut()</code>
on the newly-created <code>PyCell</code>.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span><span class="boring">Python::with_gil(|py| {
</span>let obj_ref = PyRef::new(py, MyClass {}).unwrap();
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span><span class="boring">Python::with_gil(|py| {
</span>let obj = PyCell::new(py, MyClass {}).unwrap();
let obj_ref = obj.borrow();
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<h4 id="object-extraction"><a class="header" href="#object-extraction">Object extraction</a></h4>
<p>For <code>PyClass</code> types <code>T</code>, <code>&amp;T</code> and <code>&amp;mut T</code> no longer have <a href="https://docs.rs/pyo3/0.14.4/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> implementations.
Instead you should extract <code>PyRef&lt;T&gt;</code> or <code>PyRefMut&lt;T&gt;</code>, respectively.
If <code>T</code> implements <code>Clone</code>, you can extract <code>T</code> itself.
In addition, you can also extract <code>&amp;PyCell&lt;T&gt;</code>, though you rarely need it.</p>
<p>Before:</p>
<pre><code class="language-ignore">let obj: &amp;PyAny = create_obj();
let obj_ref: &amp;MyClass = obj.extract().unwrap();
let obj_ref_mut: &amp;mut MyClass = obj.extract().unwrap();
</code></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::IntoPyDict;
</span><span class="boring">#[pyclass] #[derive(Clone)] struct MyClass {}
</span><span class="boring">#[pymethods] impl MyClass { #[new]fn new() -&gt; Self { MyClass {} }}
</span><span class="boring">Python::with_gil(|py| {
</span><span class="boring">let typeobj = py.get_type::&lt;MyClass&gt;();
</span><span class="boring">let d = [(&quot;c&quot;, typeobj)].into_py_dict(py);
</span><span class="boring">let create_obj = || py.eval(&quot;c()&quot;, None, Some(d)).unwrap();
</span>let obj: &amp;PyAny = create_obj();
let obj_cell: &amp;PyCell&lt;MyClass&gt; = obj.extract().unwrap();
let obj_cloned: MyClass = obj.extract().unwrap(); // extracted by cloning the object
{
    let obj_ref: PyRef&lt;MyClass&gt; = obj.extract().unwrap();
    // we need to drop obj_ref before we can extract a PyRefMut due to Rust's rules of references
}
let obj_ref_mut: PyRefMut&lt;MyClass&gt; = obj.extract().unwrap();
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<h4 id="pyproto"><a class="header" href="#pyproto"><code>#[pyproto]</code></a></h4>
<p>Most of the arguments to methods in <code>#[pyproto]</code> impls require a
<a href="https://docs.rs/pyo3/0.14.4/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> implementation.
So if your protocol methods take <code>&amp;T</code> or <code>&amp;mut T</code> (where <code>T: PyClass</code>),
please use <a href="https://docs.rs/pyo3/0.14.4/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> or <a href="https://docs.rs/pyo3/0.14.4/pyo3/pycell/struct.PyRef.html"><code>PyRefMut</code></a> instead.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::class::PySequenceProtocol;
</span>#[pyclass]
struct ByteSequence {
    elements: Vec&lt;u8&gt;,
}
#[pyproto]
impl PySequenceProtocol for ByteSequence {
    fn __concat__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        let mut elements = self.elements.clone();
        elements.extend_from_slice(&amp;other.elements);
        Ok(Self { elements })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::class::PySequenceProtocol;
</span>#[pyclass]
struct ByteSequence {
    elements: Vec&lt;u8&gt;,
}
#[pyproto]
impl PySequenceProtocol for ByteSequence {
    fn __concat__(&amp;self, other: PyRef&lt;'p, Self&gt;) -&gt; PyResult&lt;Self&gt; {
        let mut elements = self.elements.clone();
        elements.extend_from_slice(&amp;other.elements);
        Ok(Self { elements })
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pyo3-and-rust-cpython"><a class="header" href="#pyo3-and-rust-cpython">PyO3 and rust-cpython</a></h1>
<p>PyO3 began as fork of <a href="https://github.com/dgrunwald/rust-cpython">rust-cpython</a> when rust-cpython wasn't maintained. Over time PyO3 has become fundamentally different from rust-cpython.</p>
<h2 id="macros-2"><a class="header" href="#macros-2">Macros</a></h2>
<p>While rust-cpython has a <code>macro_rules!</code> based dsl for declaring modules and classes, PyO3 uses proc macros. PyO3 also doesn't change your struct and functions so you can still use them as normal Rust functions.</p>
<p><strong>rust-cpython</strong></p>
<pre><code class="language-rust ignore">py_class!(class MyClass |py| {
    data number: i32;
    def __new__(_cls, arg: i32) -&gt; PyResult&lt;MyClass&gt; {
        MyClass::create_instance(py, arg)
    }
    def half(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.number(py) / 2)
    }
});
</code></pre>
<p><strong>pyo3</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass]
struct MyClass {
   num: u32,
}

#[pymethods]
impl MyClass {
    #[new]
    fn new(num: u32) -&gt; Self {
        MyClass { num }
    }

    fn half(&amp;self) -&gt; PyResult&lt;u32&gt; {
        Ok(self.num / 2)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="ownership-and-lifetimes"><a class="header" href="#ownership-and-lifetimes">Ownership and lifetimes</a></h2>
<p>While in rust-cpython you always own python objects, PyO3 allows efficient <em>borrowed objects</em>
and most APIs are available with references.</p>
<p>Here is an example of the PyList API:</p>
<p><strong>rust-cpython</strong></p>
<pre><code class="language-rust ignore">impl PyList {

   fn new(py: Python) -&gt; PyList {...}

   fn get_item(&amp;self, py: Python, index: isize) -&gt; PyObject {...}
}
</code></pre>
<p><strong>pyo3</strong></p>
<pre><code class="language-rust ignore">impl PyList {

   fn new(py: Python) -&gt; &amp;PyList {...}

   fn get_item(&amp;self, index: isize) -&gt; &amp;PyAny {...}
}
</code></pre>
<p>In PyO3, all object references are bounded by the GIL lifetime.
So the owned Python object is not required, and it is safe to have functions like <code>fn py&lt;'p&gt;(&amp;'p self) -&gt; Python&lt;'p&gt; {}</code>.</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h2>
<p>rust-cpython requires a <code>Python</code> parameter for constructing a <code>PyErr</code>, so error handling ergonomics is pretty bad. It is not possible to use <code>?</code> with Rust errors.</p>
<p>PyO3 on other hand does not require <code>Python</code> for constructing a <code>PyErr</code>, it is only required if you want to raise an exception in Python with the <code>PyErr::restore()</code> method. Due to various <code>std::convert::From&lt;E&gt; for PyErr</code> implementations for Rust standard error types <code>E</code>, propagating <code>?</code> is supported automatically.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-in-python-a-rust-function-with-trait-bounds"><a class="header" href="#using-in-python-a-rust-function-with-trait-bounds">Using in Python a Rust function with trait bounds</a></h1>
<p>PyO3 allows for easy conversion from Rust to Python for certain functions and classes (see the <a href="conversions/tables.html">conversion table</a>.
However, it is not always straightforward to convert Rust code that requires a given trait implementation as an argument.</p>
<p>This tutorial explains how to convert a Rust function that takes a trait as argument for use in Python with classes implementing the same methods as the trait.</p>
<p>Why is this useful?</p>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<ul>
<li>Make your Rust code available to Python users</li>
<li>Code complex algorithms in Rust with the help of the borrow checker</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<ul>
<li>Not as fast as native Rust (type conversion has to be performed and one part of the code runs in Python)</li>
<li>You need to adapt your code to expose it</li>
</ul>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let's work with the following basic example of an implementation of a optimization solver operating on a given model.</p>
<p>Let's say we have a function <code>solve</code> that operates on a model and mutates its state.
The argument of the function can be any model that implements the <code>Model</code> trait :</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Model {
  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
  fn compute(&amp;mut self);
  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
}

pub fn solve&lt;T: Model&gt;(model: &amp;mut T) {
  println!(&quot;Magic solver that mutates the model into a resolved state&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's assume we have the following constraints:</p>
<ul>
<li>We cannot change that code as it runs on many Rust models.</li>
<li>We also have many Python models that cannot be solved as this solver is not available in that language.
Rewriting it in Python would be cumbersome and error-prone, as everything is already available in Rust.</li>
</ul>
<p>How could we expose this solver to Python thanks to PyO3 ?</p>
<h2 id="implementation-of-the-trait-bounds-for-the-python-class"><a class="header" href="#implementation-of-the-trait-bounds-for-the-python-class">Implementation of the trait bounds for the Python class</a></h2>
<p>If a Python class implements the same three methods as the <code>Model</code> trait, it seems logical it could be adapted to use the solver.
However, it is not possible to pass a <code>PyObject</code> to it as it does not implement the Rust trait (even if the Python model has the required methods).</p>
<p>In order to implement the trait, we must write a wrapper around the calls in Rust to the Python model.
The method signatures must be the same as the trait, keeping in mind that the Rust trait cannot be changed for the purpose of making the code available in Python.</p>
<p>The Python model we want to expose is the following one, which already contains all the required methods:</p>
<pre><code class="language-python">class Model:
    def set_variables(self, inputs):
        self.inputs = inputs
    def compute(self):
        self.results = [elt**2 - 3 for elt in self.inputs]
    def get_results(self):
        return self.results
</code></pre>
<p>The following wrapper will call the Python model from Rust, using a struct to hold the model as a <code>PyAny</code> object:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::types::PyAny;

<span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span>
struct UserModel {
    model: Py&lt;PyAny&gt;,
}

impl Model for UserModel {
    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
        println!(&quot;Rust calling Python to set the variables&quot;);
        Python::with_gil(|py| {
            let values: Vec&lt;f64&gt; = var.clone();
            let list: PyObject = values.into_py(py);
            let py_model = self.model.as_ref(py);
            py_model
                .call_method(&quot;set_variables&quot;, (list,), None)
                .unwrap();
        })
    }

    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Rust calling Python to get the results&quot;);
        Python::with_gil(|py| {
            self.model
                .as_ref(py)
                .call_method(&quot;get_results&quot;, (), None)
                .unwrap()
                .extract()
                .unwrap()
        })
    }

    fn compute(&amp;mut self) {
        println!(&quot;Rust calling Python to perform the computation&quot;);
        Python::with_gil(|py| {
            self.model
                .as_ref(py)
                .call_method(&quot;compute&quot;, (), None)
                .unwrap();
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now that this bit is implemented, let's expose the model wrapper to Python.
Let's add the PyO3 annotations and add a constructor:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyAny;
</span>
#[pyclass]
struct UserModel {
    model: Py&lt;PyAny&gt;,
}

#[pymodule]
fn trait_exposure(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;UserModel&gt;()?;
    Ok(())
}

#[pymethods]
impl UserModel {
    #[new]
    pub fn new(model: Py&lt;PyAny&gt;) -&gt; Self {
        UserModel { model }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we add the PyO3 annotations to the trait implementation:</p>
<pre><code class="language-rust ignore">#[pymethods]
impl Model for UserModel {
  // the previous trait implementation
}
</code></pre>
<p>However, the previous code will not compile. The compilation error is the following one:
<code>error: #[pymethods] cannot be used on trait impl blocks</code></p>
<p>That's a bummer!
However, we can write a second wrapper around these functions to call them directly.
This wrapper will also perform the type conversions between Python and Rust.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyAny;
</span><span class="boring">
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct UserModel {
</span><span class="boring">    model: Py&lt;PyAny&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Model for UserModel {
</span><span class="boring"> fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
</span><span class="boring">     println!(&quot;Rust calling Python to set the variables&quot;);
</span><span class="boring">     Python::with_gil(|py| {
</span><span class="boring">         let values: Vec&lt;f64&gt; = var.clone();
</span><span class="boring">         let list: PyObject = values.into_py(py);
</span><span class="boring">         let py_model = self.model.as_ref(py);
</span><span class="boring">         py_model
</span><span class="boring">             .call_method(&quot;set_variables&quot;, (list,), None)
</span><span class="boring">             .unwrap();
</span><span class="boring">     })
</span><span class="boring"> }
</span><span class="boring">
</span><span class="boring"> fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
</span><span class="boring">     println!(&quot;Rust calling Python to get the results&quot;);
</span><span class="boring">     Python::with_gil(|py| {
</span><span class="boring">         self.model
</span><span class="boring">             .as_ref(py)
</span><span class="boring">             .call_method(&quot;get_results&quot;, (), None)
</span><span class="boring">             .unwrap()
</span><span class="boring">             .extract()
</span><span class="boring">             .unwrap()
</span><span class="boring">     })
</span><span class="boring"> }
</span><span class="boring">
</span><span class="boring"> fn compute(&amp;mut self) {
</span><span class="boring">     println!(&quot;Rust calling Python to perform the computation&quot;);
</span><span class="boring">     Python::with_gil(|py| {
</span><span class="boring">         self.model
</span><span class="boring">             .as_ref(py)
</span><span class="boring">             .call_method(&quot;compute&quot;, (), None)
</span><span class="boring">             .unwrap();
</span><span class="boring">     })
</span><span class="boring">
</span><span class="boring"> }
</span><span class="boring">}
</span>
#[pymethods]
impl UserModel {
    pub fn set_variables(&amp;mut self, var: Vec&lt;f64&gt;) {
        println!(&quot;Set variables from Python calling Rust&quot;);
        Model::set_variables(self, &amp;var)
    }

    pub fn get_results(&amp;mut self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Get results from Python calling Rust&quot;);
        Model::get_results(self)
    }

    pub fn compute(&amp;mut self) {
        println!(&quot;Compute from Python calling Rust&quot;);
        Model::compute(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This wrapper handles the type conversion between the PyO3 requirements and the trait.
In order to meet PyO3 requirements, this wrapper must:</p>
<ul>
<li>return an object of type <code>PyResult</code></li>
<li>use only values, not references in the method signatures</li>
</ul>
<p>Let's run the file python file:</p>
<pre><code class="language-python">class Model:
    def set_variables(self, inputs):
        self.inputs = inputs
    def compute(self):
        self.results = [elt**2 - 3 for elt in self.inputs]
    def get_results(self):
        return self.results

if __name__==&quot;__main__&quot;:
  import trait_exposure

  myModel = Model()
  my_rust_model = trait_exposure.UserModel(myModel)
  my_rust_model.set_variables([2.0])
  print(&quot;Print value from Python: &quot;, myModel.inputs)
  my_rust_model.compute()
  print(&quot;Print value from Python through Rust: &quot;, my_rust_model.get_results())
  print(&quot;Print value directly from Python: &quot;, myModel.get_results())
</code></pre>
<p>This outputs:</p>
<pre><code class="language-block">Set variables from Python calling Rust
Set variables from Rust calling Python
Print value from Python:  [2.0]
Compute from Python calling Rust
Compute from Rust calling Python
Get results from Python calling Rust
Get results from Rust calling Python
Print value from Python through Rust:  [1.0]
Print value directly from Python:  [1.0]
</code></pre>
<p>We have now successfully exposed a Rust model that implements the <code>Model</code> trait to Python!</p>
<p>We will now expose the <code>solve</code> function, but before, let's talk about types errors.</p>
<h2 id="type-errors-in-python"><a class="header" href="#type-errors-in-python">Type errors in Python</a></h2>
<p>What happens if you have type errors when using Python and how can you improve the error messages?</p>
<h3 id="wrong-types-in-python-function-arguments"><a class="header" href="#wrong-types-in-python-function-arguments">Wrong types in Python function arguments</a></h3>
<p>Let's assume in the first case that you will use in your Python file <code>my_rust_model.set_variables(2.0)</code> instead of <code>my_rust_model.set_variables([2.0])</code>.</p>
<p>The Rust signature expects a vector, which corresponds to a list in Python.
What happens if instead of a vector, we pass a single value ?</p>
<p>At the execution of Python, we get :</p>
<pre><code class="language-block">File &quot;main.py&quot;, line 15, in &lt;module&gt;
   my_rust_model.set_variables(2)
TypeError
</code></pre>
<p>It is a type error and Python points to it, so it's easy to identify and solve.</p>
<h3 id="wrong-types-in-python-method-signatures"><a class="header" href="#wrong-types-in-python-method-signatures">Wrong types in Python method signatures</a></h3>
<p>Let's assume now that the return type of one of the methods of our Model class is wrong, for example the <code>get_results</code> method that is expected to return a <code>Vec&lt;f64&gt;</code> in Rust, a list in Python.</p>
<pre><code class="language-python">class Model:
    def set_variables(self, inputs):
        self.inputs = inputs
    def compute(self):
        self.results = [elt**2 -3 for elt in self.inputs]
    def get_results(self):
        return self.results[0]
        #return self.results &lt;-- this is the expected output
</code></pre>
<p>This call results in the following panic:</p>
<pre><code class="language-block">pyo3_runtime.PanicException: called `Result::unwrap()` on an `Err` value: PyErr { type: Py(0x10dcf79f0, PhantomData) }
</code></pre>
<p>This error code is not helpful for a Python user that does not know anything about Rust, or someone that does not know PyO3 was used to interface the Rust code.</p>
<p>However, as we are responsible for making the Rust code available to Python, we can do something about it.</p>
<p>The issue is that we called <code>unwrap</code> anywhere we could, and therefore any panic from PyO3 will be directly forwarded to the end user.</p>
<p>Let's modify the code performing the type conversion to give a helpful error message to the Python user:</p>
<p>We used in our <code>get_results</code> method the following call that performs the type conversion:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyAny;
</span><span class="boring">
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct UserModel {
</span><span class="boring">    model: Py&lt;PyAny&gt;,
</span><span class="boring">}
</span>
impl Model for UserModel {
    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Rust calling Python to get the results&quot;);
        Python::with_gil(|py| {
            self.model
                .as_ref(py)
                .call_method(&quot;get_results&quot;, (), None)
                .unwrap()
                .extract()
                .unwrap()
        })
    }
<span class="boring">    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
</span><span class="boring">        println!(&quot;Rust calling Python to set the variables&quot;);
</span><span class="boring">        Python::with_gil(|py| {
</span><span class="boring">            let values: Vec&lt;f64&gt; = var.clone();
</span><span class="boring">            let list: PyObject = values.into_py(py);
</span><span class="boring">            let py_model = self.model.as_ref(py);
</span><span class="boring">            py_model
</span><span class="boring">                .call_method(&quot;set_variables&quot;, (list,), None)
</span><span class="boring">                .unwrap();
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn compute(&amp;mut self) {
</span><span class="boring">        println!(&quot;Rust calling Python to perform the computation&quot;);
</span><span class="boring">        Python::with_gil(|py| {
</span><span class="boring">            self.model
</span><span class="boring">                .as_ref(py)
</span><span class="boring">                .call_method(&quot;compute&quot;, (), None)
</span><span class="boring">                .unwrap();
</span><span class="boring">        })
</span><span class="boring">    }
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>Let's break it down in order to perform better error handling:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyAny;
</span><span class="boring">
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct UserModel {
</span><span class="boring">    model: Py&lt;PyAny&gt;,
</span><span class="boring">}
</span>
impl Model for UserModel {
    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Get results from Rust calling Python&quot;);
        Python::with_gil(|py| {
            let py_result: &amp;PyAny = self
                .model
                .as_ref(py)
                .call_method(&quot;get_results&quot;, (), None)
                .unwrap();

            if py_result.get_type().name().unwrap() != &quot;list&quot; {
                panic!(&quot;Expected a list for the get_results() method signature, got {}&quot;, py_result.get_type().name().unwrap());
            }
            py_result.extract()
        })
        .unwrap()
    }
<span class="boring">    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
</span><span class="boring">        println!(&quot;Rust calling Python to set the variables&quot;);
</span><span class="boring">        Python::with_gil(|py| {
</span><span class="boring">            let values: Vec&lt;f64&gt; = var.clone();
</span><span class="boring">            let list: PyObject = values.into_py(py);
</span><span class="boring">            let py_model = self.model.as_ref(py);
</span><span class="boring">            py_model
</span><span class="boring">                .call_method(&quot;set_variables&quot;, (list,), None)
</span><span class="boring">                .unwrap();
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn compute(&amp;mut self) {
</span><span class="boring">        println!(&quot;Rust calling Python to perform the computation&quot;);
</span><span class="boring">        Python::with_gil(|py| {
</span><span class="boring">            self.model
</span><span class="boring">                .as_ref(py)
</span><span class="boring">                .call_method(&quot;compute&quot;, (), None)
</span><span class="boring">                .unwrap();
</span><span class="boring">        })
</span><span class="boring">    }
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>By doing so, you catch the result of the Python computation and check its type in order to be able to deliver a better error message before performing the unwrapping.</p>
<p>Of course, it does not cover all the possible wrong outputs:
the user could return a list of strings instead of a list of floats.
In this case, a runtime panic would still occur due to PyO3, but with an error message much more difficult to decipher for non-rust user.</p>
<p>It is up to the developer exposing the rust code to decide how much effort to invest into Python type error handling and improved error messages.</p>
<h2 id="the-final-code"><a class="header" href="#the-final-code">The final code</a></h2>
<p>Now let's expose the <code>solve()</code> function to make it available from Python.</p>
<p>It is not possible to directly expose the <code>solve</code> function to Python, as the type conversion cannot be performed.
It requires an object implementing the <code>Model</code> trait as input.</p>
<p>However, the <code>UserModel</code> already implements this trait.
Because of this, we can write a function wrapper that takes the <code>UserModel</code>--which has already been exposed to Python--as an argument in order to call the core function <code>solve</code>.</p>
<p>It is also required to make the struct public.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::types::PyAny;

pub trait Model {
    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;);
    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
    fn compute(&amp;mut self);
}

pub fn solve&lt;T: Model&gt;(model: &amp;mut T) {
  println!(&quot;Magic solver that mutates the model into a resolved state&quot;);
}

#[pyfunction]
#[pyo3(name = &quot;solve&quot;)]
pub fn solve_wrapper(model: &amp;mut UserModel) {
    solve(model);
}

#[pyclass]
pub struct UserModel {
    model: Py&lt;PyAny&gt;,
}

#[pymodule]
fn trait_exposure(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;UserModel&gt;()?;
    m.add_function(wrap_pyfunction!(solve_wrapper, m)?)?;
    Ok(())
}

#[pymethods]
impl UserModel {
    #[new]
    pub fn new(model: Py&lt;PyAny&gt;) -&gt; Self {
        UserModel { model }
    }

    pub fn set_variables(&amp;mut self, var: Vec&lt;f64&gt;) {
        println!(&quot;Set variables from Python calling Rust&quot;);
        Model::set_variables(self, &amp;var)
    }

    pub fn get_results(&amp;mut self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Get results from Python calling Rust&quot;);
        Model::get_results(self)
    }

    pub fn compute(&amp;mut self) {
        Model::compute(self)
    }
}

impl Model for UserModel {
    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
        println!(&quot;Rust calling Python to set the variables&quot;);
        Python::with_gil(|py| {
            let values: Vec&lt;f64&gt; = var.clone();
            let list: PyObject = values.into_py(py);
            let py_model = self.model.as_ref(py);
            py_model
                .call_method(&quot;set_variables&quot;, (list,), None)
                .unwrap();
        })
    }

    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Get results from Rust calling Python&quot;);
        Python::with_gil(|py| {
            let py_result: &amp;PyAny = self
                .model
                .as_ref(py)
                .call_method(&quot;get_results&quot;, (), None)
                .unwrap();

            if py_result.get_type().name().unwrap() != &quot;list&quot; {
                panic!(&quot;Expected a list for the get_results() method signature, got {}&quot;, py_result.get_type().name().unwrap());
            }
            py_result.extract()
        })
        .unwrap()
    }

    fn compute(&amp;mut self) {
        println!(&quot;Rust calling Python to perform the computation&quot;);
        Python::with_gil(|py| {
            self.model
                .as_ref(py)
                .call_method(&quot;compute&quot;, (), None)
                .unwrap();
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>All notable changes to this project will be documented in this file. For help with updating to new
PyO3 versions, please see the <a href="https://pyo3.rs/latest/migration.html">migration guide</a>.</p>
<p>The format is based on <a href="http://keepachangelog.com/en/1.0.0/">Keep a Changelog</a>
and this project adheres to <a href="http://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.</p>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0143v01440144a---2021-08-29"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0143v01440144a---2021-08-29"><a href="https://github.com/pyo3/pyo3/compare/v0.14.3...v0.14.4">0.14.4</a> - 2021-08-29</a></h2>
<h3 id="changed"><a class="header" href="#changed">Changed</a></h3>
<ul>
<li>Mark <code>PyString::data</code> as <code>unsafe</code> and disable it and some supporting PyUnicode FFI APIs (which depend on a C bitfield) on big-endian targets. <a href="https://github.com/PyO3/pyo3/pull/1834">#1834</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0142v01430143a---2021-08-22"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0142v01430143a---2021-08-22"><a href="https://github.com/pyo3/pyo3/compare/v0.14.2...v0.14.3">0.14.3</a> - 2021-08-22</a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<ul>
<li>Add <code>PyString::data()</code> to access the raw bytes stored in a Python string. <a href="https://github.com/PyO3/pyo3/issues/1794">#1794</a></li>
</ul>
<h3 id="fixed"><a class="header" href="#fixed">Fixed</a></h3>
<ul>
<li>Raise <code>AttributeError</code> to avoid panic when calling <code>del</code> on a <code>#[setter]</code> defined class property. <a href="https://github.com/PyO3/pyo3/issues/1779">#1779</a></li>
<li>Restrict FFI definitions <code>PyGILState_Check</code> and <code>Py_tracefunc</code> to the unlimited API. <a href="https://github.com/PyO3/pyo3/pull/1787">#1787</a></li>
<li>Add missing <code>_type</code> field to <code>PyStatus</code> struct definition. <a href="https://github.com/PyO3/pyo3/pull/1791">#1791</a></li>
<li>Reduce lower bound <code>num-complex</code> optional dependency to support interop with <code>rust-numpy</code> and <code>ndarray</code> when building with the MSRV of 1.41 <a href="https://github.com/PyO3/pyo3/pull/1799">#1799</a></li>
<li>Fix memory leak in <code>Python::run_code</code>. <a href="https://github.com/PyO3/pyo3/pull/1806">#1806</a></li>
<li>Fix memory leak in <code>PyModule::from_code</code>. <a href="https://github.com/PyO3/pyo3/pull/1810">#1810</a></li>
<li>Remove use of <code>pyo3::</code> in <code>pyo3::types::datetime</code> which broke builds using <code>-Z avoid-dev-deps</code> <a href="https://github.com/PyO3/pyo3/issues/1811">#1811</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0141v01420142a---2021-08-09"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0141v01420142a---2021-08-09"><a href="https://github.com/pyo3/pyo3/compare/v0.14.1...v0.14.2">0.14.2</a> - 2021-08-09</a></h2>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<ul>
<li>Add <code>indexmap</code> feature to add <code>ToPyObject</code>, <code>IntoPy</code> and <code>FromPyObject</code> implementations for <code>indexmap::IndexMap</code>. <a href="https://github.com/PyO3/pyo3/pull/1728">#1728</a></li>
<li>Add <code>pyo3_build_config::add_extension_module_link_args()</code> to use in build scripts to set linker arguments (for macOS). <a href="https://github.com/PyO3/pyo3/pull/1755">#1755</a></li>
<li>Add <code>Python::with_gil_unchecked()</code> unsafe variation of <code>Python::with_gil()</code> to allow obtaining a <code>Python</code> in scenarios where <code>Python::with_gil()</code> would fail. <a href="https://github.com/PyO3/pyo3/pull/1769">#1769</a></li>
</ul>
<h3 id="changed-1"><a class="header" href="#changed-1">Changed</a></h3>
<ul>
<li><code>PyErr::new</code> no longer acquires the Python GIL internally. <a href="https://github.com/PyO3/pyo3/pull/1724">#1724</a></li>
<li>Reverted PyO3 0.14.0's use of <code>cargo:rustc-cdylib-link-arg</code> in its build script, as Cargo unintentionally allowed crates to pass linker args to downstream crates in this way. Projects supporting macOS may need to restore <code>.cargo/config.toml</code> files. <a href="https://github.com/PyO3/pyo3/pull/1755">#1755</a></li>
</ul>
<h3 id="fixed-1"><a class="header" href="#fixed-1">Fixed</a></h3>
<ul>
<li>Fix regression in 0.14.0 rejecting usage of <code>#[doc(hidden)]</code> on structs and functions annotated with PyO3 macros. <a href="https://github.com/PyO3/pyo3/pull/1722">#1722</a></li>
<li>Fix regression in 0.14.0 leading to incorrect code coverage being computed for <code>#[pyfunction]</code>s. <a href="https://github.com/PyO3/pyo3/pull/1726">#1726</a></li>
<li>Fix incorrect FFI definition of <code>Py_Buffer</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/1737">#1737</a></li>
<li>Fix incorrect calculation of <code>dictoffset</code> on 32-bit Windows. <a href="https://github.com/PyO3/pyo3/pull/1475">#1475</a></li>
<li>Fix regression in 0.13.2 leading to linking to incorrect Python library on Windows &quot;gnu&quot; targets. <a href="https://github.com/PyO3/pyo3/pull/1759">#1759</a></li>
<li>Fix compiler warning: deny trailing semicolons in expression macro. <a href="https://github.com/PyO3/pyo3/pull/1762">#1762</a></li>
<li>Fix incorrect FFI definition of <code>Py_DecodeLocale</code>. The 2nd argument is now <code>*mut Py_ssize_t</code> instead of <code>Py_ssize_t</code>. <a href="https://github.com/PyO3/pyo3/pull/1766">#1766</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0140v01410141a---2021-07-04"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0140v01410141a---2021-07-04"><a href="https://github.com/pyo3/pyo3/compare/v0.14.0...v0.14.1">0.14.1</a> - 2021-07-04</a></h2>
<h3 id="added-2"><a class="header" href="#added-2">Added</a></h3>
<ul>
<li>Implement <code>IntoPy&lt;PyObject&gt;</code> for <code>&amp;PathBuf</code> and <code>&amp;OsString</code>. <a href="https://github.com/PyO3/pyo3/pull/1712">#1712</a></li>
</ul>
<h3 id="fixed-2"><a class="header" href="#fixed-2">Fixed</a></h3>
<ul>
<li>Fix crashes on PyPy due to incorrect definitions of <code>PyList_SET_ITEM</code>. <a href="https://github.com/PyO3/pyo3/pull/1713">#1713</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0132v01400140a---2021-07-03"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0132v01400140a---2021-07-03"><a href="https://github.com/pyo3/pyo3/compare/v0.13.2...v0.14.0">0.14.0</a> - 2021-07-03</a></h2>
<h3 id="packaging"><a class="header" href="#packaging">Packaging</a></h3>
<ul>
<li>Update <code>num-bigint</code> optional dependency to 0.4. <a href="https://github.com/PyO3/pyo3/pull/1481">#1481</a></li>
<li>Update <code>num-complex</code> optional dependency to 0.4. <a href="https://github.com/PyO3/pyo3/pull/1482">#1482</a></li>
<li>Extend <code>hashbrown</code> optional dependency supported versions to include 0.11. <a href="https://github.com/PyO3/pyo3/pull/1496">#1496</a></li>
<li>Support PyPy 3.7. <a href="https://github.com/PyO3/pyo3/pull/1538">#1538</a></li>
</ul>
<h3 id="added-3"><a class="header" href="#added-3">Added</a></h3>
<ul>
<li>Extend conversions for <code>[T; N]</code> to all <code>N</code> using const generics (on Rust 1.51 and up). <a href="https://github.com/PyO3/pyo3/pull/1128">#1128</a></li>
<li>Add conversions between <code>OsStr</code>/ <code>OsString</code> and Python strings. <a href="https://github.com/PyO3/pyo3/pull/1379">#1379</a></li>
<li>Add conversions between <code>Path</code>/ <code>PathBuf</code> and Python strings (and <code>pathlib.Path</code> objects). <a href="https://github.com/PyO3/pyo3/pull/1379">#1379</a> <a href="https://github.com/PyO3/pyo3/pull/1654">#1654</a></li>
<li>Add a new set of <code>#[pyo3(...)]</code> attributes to control various PyO3 macro functionality:
<ul>
<li><code>#[pyo3(from_py_with = &quot;...&quot;)]</code> function arguments and struct fields to override the default from-Python conversion. <a href="https://github.com/PyO3/pyo3/pull/1411">#1411</a></li>
<li><code>#[pyo3(name = &quot;...&quot;)]</code> for setting Python names. <a href="https://github.com/PyO3/pyo3/pull/1567">#1567</a></li>
<li><code>#[pyo3(text_signature = &quot;...&quot;)]</code> for setting text signature. <a href="https://github.com/PyO3/pyo3/pull/1658">#1658</a></li>
</ul>
</li>
<li>Add FFI definition <code>PyCFunction_CheckExact</code> for Python 3.9 and later. <a href="https://github.com/PyO3/pyo3/pull/1425">#1425</a></li>
<li>Add FFI definition <code>Py_IS_TYPE</code>. <a href="https://github.com/PyO3/pyo3/pull/1429">#1429</a></li>
<li>Add FFI definition <code>_Py_InitializeMain</code>. <a href="https://github.com/PyO3/pyo3/pull/1473">#1473</a></li>
<li>Add FFI definitions from <code>cpython/import.h</code>.<a href="https://github.com/PyO3/pyo3/pull/1475">#1475</a></li>
<li>Add tuple and unit struct support for <code>#[pyclass]</code> macro. <a href="https://github.com/PyO3/pyo3/pull/1504">#1504</a></li>
<li>Add FFI definition <code>PyDateTime_TimeZone_UTC</code>. <a href="https://github.com/PyO3/pyo3/pull/1572">#1572</a></li>
<li>Add support for <code>#[pyclass(extends=Exception)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1591">#1591</a></li>
<li>Add <code>PyErr::cause</code> and <code>PyErr::set_cause</code>. <a href="https://github.com/PyO3/pyo3/pull/1679">#1679</a></li>
<li>Add FFI definitions from <code>cpython/pystate.h</code>. <a href="https://github.com/PyO3/pyo3/pull/1687/">#1687</a></li>
<li>Add <code>wrap_pyfunction!</code> macro to <code>pyo3::prelude</code>. <a href="https://github.com/PyO3/pyo3/pull/1695">#1695</a></li>
</ul>
<h3 id="changed-2"><a class="header" href="#changed-2">Changed</a></h3>
<ul>
<li>Allow only one <code>#[pymethods]</code> block per <code>#[pyclass]</code> by default, to remove the dependency on <code>inventory</code>. Add a <code>multiple-pymethods</code> feature to opt-in the original behavior and dependency on <code>inventory</code>. <a href="https://github.com/PyO3/pyo3/pull/1457">#1457</a></li>
<li>Change <code>PyTimeAccess::get_fold</code> to return a <code>bool</code> instead of a <code>u8</code>. <a href="https://github.com/PyO3/pyo3/pull/1397">#1397</a></li>
<li>Deprecate FFI definition <code>PyCFunction_Call</code> for Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/1425">#1425</a></li>
<li>Deprecate FFI definition <code>PyModule_GetFilename</code>. <a href="https://github.com/PyO3/pyo3/pull/1425">#1425</a></li>
<li>The <code>auto-initialize</code> feature is no longer enabled by default. <a href="https://github.com/PyO3/pyo3/pull/1443">#1443</a></li>
<li>Change <code>PyCFunction::new()</code> and <code>PyCFunction::new_with_keywords()</code> to take <code>&amp;'static str</code> arguments rather than implicitly copying (and leaking) them. <a href="https://github.com/PyO3/pyo3/pull/1450">#1450</a></li>
<li>Deprecate <code>PyModule::call</code>, <code>PyModule::call0</code>, <code>PyModule::call1</code> and <code>PyModule::get</code>. <a href="https://github.com/PyO3/pyo3/pull/1492">#1492</a></li>
<li>Add length information to <code>PyBufferError</code>s raised from <code>PyBuffer::copy_to_slice</code> and <code>PyBuffer::copy_from_slice</code>. <a href="https://github.com/PyO3/pyo3/pull/1534">#1534</a></li>
<li>Automatically set <code>-undefined</code> and <code>dynamic_lookup</code> linker arguments on macOS with the <code>extension-module</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1539">#1539</a></li>
<li>Deprecate <code>#[pyproto]</code> methods which are easier to implement as <code>#[pymethods]</code>: <a href="https://github.com/PyO3/pyo3/pull/1560">#1560</a>
<ul>
<li><code>PyBasicProtocol::__bytes__</code> and <code>PyBasicProtocol::__format__</code></li>
<li><code>PyContextProtocol::__enter__</code> and <code>PyContextProtocol::__exit__</code></li>
<li><code>PyDescrProtocol::__delete__</code> and <code>PyDescrProtocol::__set_name__</code></li>
<li><code>PyMappingProtocol::__reversed__</code></li>
<li><code>PyNumberProtocol::__complex__</code> and <code>PyNumberProtocol::__round__</code></li>
<li><code>PyAsyncProtocol::__aenter__</code> and <code>PyAsyncProtocol::__aexit__</code></li>
</ul>
</li>
<li>Deprecate several attributes in favor of the new <code>#[pyo3(...)]</code> options:
<ul>
<li><code>#[name = &quot;...&quot;]</code>, replaced by <code>#[pyo3(name = &quot;...&quot;)]</code> <a href="https://github.com/PyO3/pyo3/pull/1567">#1567</a></li>
<li><code>#[pyfn(m, &quot;name&quot;)]</code>, replaced by <code>#[pyfn(m)] #[pyo3(name = &quot;...&quot;)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1610">#1610</a></li>
<li><code>#[pymodule(name)]</code>, replaced by <code>#[pymodule] #[pyo3(name = &quot;...&quot;)]</code> <a href="https://github.com/PyO3/pyo3/pull/1650">#1650</a></li>
<li><code>#[text_signature = &quot;...&quot;]</code>, replaced by <code>#[pyo3(text_signature = &quot;...&quot;)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1658">#1658</a></li>
</ul>
</li>
<li>Reduce LLVM line counts to improve compilation times. <a href="https://github.com/PyO3/pyo3/pull/1604">#1604</a></li>
<li>No longer call <code>PyEval_InitThreads</code> in <code>#[pymodule]</code> init code. <a href="https://github.com/PyO3/pyo3/pull/1630">#1630</a></li>
<li>Use <code>METH_FASTCALL</code> argument passing convention, when possible, to improve <code>#[pyfunction]</code> and method performance.
<a href="https://github.com/PyO3/pyo3/pull/1619">#1619</a>, <a href="https://github.com/PyO3/pyo3/pull/1660">#1660</a></li>
<li>Filter sysconfigdata candidates by architecture when cross-compiling. <a href="https://github.com/PyO3/pyo3/pull/1626">#1626</a></li>
</ul>
<h3 id="removed"><a class="header" href="#removed">Removed</a></h3>
<ul>
<li>Remove deprecated exception names <code>BaseException</code> etc. <a href="https://github.com/PyO3/pyo3/pull/1426">#1426</a></li>
<li>Remove deprecated methods <code>Python::is_instance</code>, <code>Python::is_subclass</code>, <code>Python::release</code>, <code>Python::xdecref</code>, and <code>Py::from_owned_ptr_or_panic</code>. <a href="https://github.com/PyO3/pyo3/pull/1426">#1426</a></li>
<li>Remove many FFI definitions which never existed in the Python C-API:
<ul>
<li>(previously deprecated) <code>PyGetSetDef_INIT</code>, <code>PyGetSetDef_DICT</code>, <code>PyCoro_Check</code>, <code>PyCoroWrapper_Check</code>, and <code>PyAsyncGen_Check</code> <a href="https://github.com/PyO3/pyo3/pull/1426">#1426</a></li>
<li><code>PyMethodDef_INIT</code> <a href="https://github.com/PyO3/pyo3/pull/1426">#1426</a></li>
<li><code>PyTypeObject_INIT</code> <a href="https://github.com/PyO3/pyo3/pull/1429">#1429</a></li>
<li><code>PyObject_Check</code>, <code>PySuper_Check</code>, and <code>FreeFunc</code> <a href="https://github.com/PyO3/pyo3/pull/1438">#1438</a></li>
<li><code>PyModuleDef_INIT</code> <a href="https://github.com/PyO3/pyo3/pull/1630">#1630</a></li>
</ul>
</li>
<li>Remove pyclass implementation details from <code>PyTypeInfo</code>:
<ul>
<li><code>Type</code>, <code>DESCRIPTION</code>, and <code>FLAGS</code> <a href="https://github.com/PyO3/pyo3/pull/1456">#1456</a></li>
<li><code>BaseType</code>, <code>BaseLayout</code>, <code>Layout</code>, <code>Initializer</code> <a href="https://github.com/PyO3/pyo3/pull/1596">#1596</a></li>
</ul>
</li>
<li>Remove <code>PYO3_CROSS_INCLUDE_DIR</code> environment variable and the associated C header parsing functionality. <a href="https://github.com/PyO3/pyo3/pull/1521">#1521</a></li>
<li>Remove <code>raw_pycfunction!</code> macro. <a href="https://github.com/PyO3/pyo3/pull/1619">#1619</a></li>
<li>Remove <code>PyClassAlloc</code> trait. <a href="https://github.com/PyO3/pyo3/pull/1657">#1657</a></li>
<li>Remove <code>PyList::get_parked_item</code>. <a href="https://github.com/PyO3/pyo3/pull/1664">#1664</a></li>
</ul>
<h3 id="fixed-3"><a class="header" href="#fixed-3">Fixed</a></h3>
<ul>
<li>Remove FFI definition <code>PyCFunction_ClearFreeList</code> for Python 3.9 and later. <a href="https://github.com/PyO3/pyo3/pull/1425">#1425</a></li>
<li><code>PYO3_CROSS_LIB_DIR</code> enviroment variable no long required when compiling for x86-64 Python from macOS arm64 and reverse. <a href="https://github.com/PyO3/pyo3/pull/1428">#1428</a></li>
<li>Fix FFI definition <code>_PyEval_RequestCodeExtraIndex</code>, which took an argument of the wrong type. <a href="https://github.com/PyO3/pyo3/pull/1429">#1429</a></li>
<li>Fix FFI definition <code>PyIndex_Check</code> missing with the <code>abi3</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1436">#1436</a></li>
<li>Fix incorrect <code>TypeError</code> raised when keyword-only argument passed along with a positional argument in <code>*args</code>. <a href="https://github.com/PyO3/pyo3/pull/1440">#1440</a></li>
<li>Fix inability to use a named lifetime for <code>&amp;PyTuple</code> of <code>*args</code> in <code>#[pyfunction]</code>. <a href="https://github.com/PyO3/pyo3/pull/1440">#1440</a></li>
<li>Fix use of Python argument for <code>#[pymethods]</code> inside macro expansions. <a href="https://github.com/PyO3/pyo3/pull/1505">#1505</a></li>
<li>No longer include <code>__doc__</code> in <code>__all__</code> generated for <code>#[pymodule]</code>. <a href="https://github.com/PyO3/pyo3/pull/1509">#1509</a></li>
<li>Always use cross-compiling configuration if any of the <code>PYO3_CROSS</code> family of environment variables are set. <a href="https://github.com/PyO3/pyo3/pull/1514">#1514</a></li>
<li>Support <code>EnvironmentError</code>, <code>IOError</code>, and <code>WindowsError</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/1533">#1533</a></li>
<li>Fix unneccessary rebuilds when cycling between <code>cargo check</code> and <code>cargo clippy</code> in a Python virtualenv. <a href="https://github.com/PyO3/pyo3/pull/1557">#1557</a></li>
<li>Fix segfault when dereferencing <code>ffi::PyDateTimeAPI</code> without the GIL. <a href="https://github.com/PyO3/pyo3/pull/1563">#1563</a></li>
<li>Fix memory leak in <code>FromPyObject</code> implementations for <code>u128</code> and <code>i128</code>. <a href="https://github.com/PyO3/pyo3/pull/1638">#1638</a></li>
<li>Fix <code>#[pyclass(extends=PyDict)]</code> leaking the dict contents on drop. <a href="https://github.com/PyO3/pyo3/pull/1657">#1657</a></li>
<li>Fix segfault when calling <code>PyList::get_item</code> with negative indices. <a href="https://github.com/PyO3/pyo3/pull/1668">#1668</a></li>
<li>Fix FFI definitions of <code>PyEval_SetProfile</code>/<code>PyEval_SetTrace</code> to take <code>Option&lt;Py_tracefunc&gt;</code> parameters. <a href="https://github.com/PyO3/pyo3/pull/1692">#1692</a></li>
<li>Fix <code>ToPyObject</code> impl for <code>HashSet</code> to accept non-default hashers. <a href="https://github.com/PyO3/pyo3/pull/1702">#1702</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0131v01320132a---2021-02-12"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0131v01320132a---2021-02-12"><a href="https://github.com/pyo3/pyo3/compare/v0.13.1...v0.13.2">0.13.2</a> - 2021-02-12</a></h2>
<h3 id="packaging-1"><a class="header" href="#packaging-1">Packaging</a></h3>
<ul>
<li>Lower minimum supported Rust version to 1.41. <a href="https://github.com/PyO3/pyo3/pull/1421">#1421</a></li>
</ul>
<h3 id="added-4"><a class="header" href="#added-4">Added</a></h3>
<ul>
<li>Add unsafe API <code>with_embedded_python_interpreter</code> to initalize a Python interpreter, execute a closure, and finalize the interpreter. <a href="https://github.com/PyO3/pyo3/pull/1355">#1355</a></li>
<li>Add <code>serde</code> feature which provides implementations of <code>Serialize</code> and <code>Deserialize</code> for <code>Py&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1366">#1366</a></li>
<li>Add FFI definition <code>_PyCFunctionFastWithKeywords</code> on Python 3.7 and up. <a href="https://github.com/PyO3/pyo3/pull/1384">#1384</a></li>
<li>Add <code>PyDateTime::new_with_fold()</code> method. <a href="https://github.com/PyO3/pyo3/pull/1398">#1398</a></li>
<li>Add <code>size_hint</code> impls for <code>{PyDict,PyList,PySet,PyTuple}Iterator</code>s. <a href="https://github.com/PyO3/pyo3/pull/1699">#1699</a></li>
</ul>
<h3 id="changed-3"><a class="header" href="#changed-3">Changed</a></h3>
<ul>
<li><code>prepare_freethreaded_python</code> will no longer register an <code>atexit</code> handler to call <code>Py_Finalize</code>. This resolves a number of issues with incompatible C extensions causing crashes at finalization. <a href="https://github.com/PyO3/pyo3/pull/1355">#1355</a></li>
<li>Mark <code>PyLayout::py_init</code>, <code>PyClassDict::clear_dict</code>, and <code>opt_to_pyobj</code> safe, as they do not perform any unsafe operations. <a href="https://github.com/PyO3/pyo3/pull/1404">#1404</a></li>
</ul>
<h3 id="fixed-4"><a class="header" href="#fixed-4">Fixed</a></h3>
<ul>
<li>Fix support for using <code>r#raw_idents</code> as argument names in pyfunctions. <a href="https://github.com/PyO3/pyo3/pull/1383">#1383</a></li>
<li>Fix typo in FFI definition for <code>PyFunction_GetCode</code> (was incorrectly <code>PyFunction_Code</code>). <a href="https://github.com/PyO3/pyo3/pull/1387">#1387</a></li>
<li>Fix FFI definitions <code>PyMarshal_WriteObjectToString</code> and <code>PyMarshal_ReadObjectFromString</code> as available in limited API. <a href="https://github.com/PyO3/pyo3/pull/1387">#1387</a></li>
<li>Fix FFI definitions <code>PyListObject</code> and those from <code>funcobject.h</code> as requiring non-limited API. <a href="https://github.com/PyO3/pyo3/pull/1387">#1387</a></li>
<li>Fix unqualified <code>Result</code> usage in <code>pyobject_native_type_base</code>. <a href="https://github.com/PyO3/pyo3/pull/1402">#1402</a></li>
<li>Fix build on systems where the default Python encoding is not UTF-8. <a href="https://github.com/PyO3/pyo3/pull/1405">#1405</a></li>
<li>Fix build on mingw / MSYS2. <a href="https://github.com/PyO3/pyo3/pull/1423">#1423</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0130v01310131a---2021-01-10"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0130v01310131a---2021-01-10"><a href="https://github.com/pyo3/pyo3/compare/v0.13.0...v0.13.1">0.13.1</a> - 2021-01-10</a></h2>
<h3 id="added-5"><a class="header" href="#added-5">Added</a></h3>
<ul>
<li>Add support for <code>#[pyclass(dict)]</code> and <code>#[pyclass(weakref)]</code> with the <code>abi3</code> feature on Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/1342">#1342</a></li>
<li>Add FFI definitions <code>PyOS_BeforeFork</code>, <code>PyOS_AfterFork_Parent</code>, <code>PyOS_AfterFork_Child</code> for Python 3.7 and up. <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
<li>Add an <code>auto-initialize</code> feature to control whether PyO3 should automatically initialize an embedded Python interpreter. For compatibility this feature is enabled by default in PyO3 0.13.1, but is planned to become opt-in from PyO3 0.14.0. <a href="https://github.com/PyO3/pyo3/pull/1347">#1347</a></li>
<li>Add support for cross-compiling to Windows without needing <code>PYO3_CROSS_INCLUDE_DIR</code>. <a href="https://github.com/PyO3/pyo3/pull/1350">#1350</a></li>
</ul>
<h3 id="deprecated"><a class="header" href="#deprecated">Deprecated</a></h3>
<ul>
<li>Deprecate FFI definitions <code>PyEval_CallObjectWithKeywords</code>, <code>PyEval_CallObject</code>, <code>PyEval_CallFunction</code>, <code>PyEval_CallMethod</code> when building for Python 3.9. <a href="https://github.com/PyO3/pyo3/pull/1338">#1338</a></li>
<li>Deprecate FFI definitions <code>PyGetSetDef_DICT</code> and <code>PyGetSetDef_INIT</code> which have never been in the Python API. <a href="https://github.com/PyO3/pyo3/pull/1341">#1341</a></li>
<li>Deprecate FFI definitions <code>PyGen_NeedsFinalizing</code>, <code>PyImport_Cleanup</code> (removed in 3.9), and <code>PyOS_InitInterrupts</code> (3.10). <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
<li>Deprecate FFI definition <code>PyOS_AfterFork</code> for Python 3.7 and up. <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
<li>Deprecate FFI definitions <code>PyCoro_Check</code>, <code>PyAsyncGen_Check</code>, and <code>PyCoroWrapper_Check</code>, which have never been in the Python API (for the first two, it is possible to use <code>PyCoro_CheckExact</code> and <code>PyAsyncGen_CheckExact</code> instead; these are the actual functions provided by the Python API). <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
<li>Deprecate FFI definitions for <code>PyUnicode_FromUnicode</code>, <code>PyUnicode_AsUnicode</code> and <code>PyUnicode_AsUnicodeAndSize</code>, which will be removed from 3.12 and up due to <a href="https://www.python.org/dev/peps/pep-0623/">PEP 613</a>. <a href="https://github.com/PyO3/pyo3/pull/1370">#1370</a></li>
</ul>
<h3 id="removed-1"><a class="header" href="#removed-1">Removed</a></h3>
<ul>
<li>Remove FFI definition <code>PyFrame_ClearFreeList</code> when building for Python 3.9. <a href="https://github.com/PyO3/pyo3/pull/1341">#1341</a></li>
<li>Remove FFI definition <code>_PyDict_Contains</code> when building for Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/1341">#1341</a></li>
<li>Remove FFI definitions <code>PyGen_NeedsFinalizing</code> and <code>PyImport_Cleanup</code> (for 3.9 and up), and <code>PyOS_InitInterrupts</code> (3.10). <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
</ul>
<h3 id="fixed-5"><a class="header" href="#fixed-5">Fixed</a></h3>
<ul>
<li>Stop including <code>Py_TRACE_REFS</code> config setting automatically if <code>Py_DEBUG</code> is set on Python 3.8 and up. <a href="https://github.com/PyO3/pyo3/pull/1334">#1334</a></li>
<li>Remove <code>#[deny(warnings)]</code> attribute (and instead refuse warnings only in CI). <a href="https://github.com/PyO3/pyo3/pull/1340">#1340</a></li>
<li>Fix deprecation warning for missing <code>__module__</code> with <code>#[pyclass]</code>. <a href="https://github.com/PyO3/pyo3/pull/1343">#1343</a></li>
<li>Correct return type of <code>PyFrozenSet::empty</code> to <code>&amp;PyFrozenSet</code> (was incorrectly <code>&amp;PySet</code>). <a href="https://github.com/PyO3/pyo3/pull/1351">#1351</a></li>
<li>Fix missing <code>Py_INCREF</code> on heap type objects on Python versions before 3.8. <a href="https://github.com/PyO3/pyo3/pull/1365">#1365</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0124v01300130a---2020-12-22"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0124v01300130a---2020-12-22"><a href="https://github.com/pyo3/pyo3/compare/v0.12.4...v0.13.0">0.13.0</a> - 2020-12-22</a></h2>
<h3 id="packaging-2"><a class="header" href="#packaging-2">Packaging</a></h3>
<ul>
<li>Drop support for Python 3.5 (as it is now end-of-life). <a href="https://github.com/PyO3/pyo3/pull/1250">#1250</a></li>
<li>Bump minimum supported Rust version to 1.45. <a href="https://github.com/PyO3/pyo3/pull/1272">#1272</a></li>
<li>Bump indoc dependency to 1.0. <a href="https://github.com/PyO3/pyo3/pull/1272">#1272</a></li>
<li>Bump paste dependency to 1.0. <a href="https://github.com/PyO3/pyo3/pull/1272">#1272</a></li>
<li>Rename internal crates <code>pyo3cls</code> and <code>pyo3-derive-backend</code> to <code>pyo3-macros</code> and <code>pyo3-macros-backend</code> respectively. <a href="https://github.com/PyO3/pyo3/pull/1317">#1317</a></li>
</ul>
<h3 id="added-6"><a class="header" href="#added-6">Added</a></h3>
<ul>
<li>Add support for building for CPython limited API. Opting-in to the limited API enables a single extension wheel built with PyO3 to be installable on multiple Python versions. This required a few minor changes to runtime behaviour of of PyO3 <code>#[pyclass]</code> types. See the migration guide for full details. <a href="https://github.com/PyO3/pyo3/pull/1152">#1152</a>
<ul>
<li>Add feature flags <code>abi3-py36</code>, <code>abi3-py37</code>, <code>abi3-py38</code> etc. to set the minimum Python version when using the limited API. <a href="https://github.com/PyO3/pyo3/pull/1263">#1263</a></li>
</ul>
</li>
<li>Add argument names to <code>TypeError</code> messages generated by pymethod wrappers. <a href="https://github.com/PyO3/pyo3/pull/1212">#1212</a></li>
<li>Add FFI definitions for PEP 587 &quot;Python Initialization Configuration&quot;. <a href="https://github.com/PyO3/pyo3/pull/1247">#1247</a></li>
<li>Add FFI definitions for <code>PyEval_SetProfile</code> and <code>PyEval_SetTrace</code>. <a href="https://github.com/PyO3/pyo3/pull/1255">#1255</a></li>
<li>Add FFI definitions for context.h functions (<code>PyContext_New</code>, etc). <a href="https://github.com/PyO3/pyo3/pull/1259">#1259</a></li>
<li>Add <code>PyAny::is_instance()</code> method. <a href="https://github.com/PyO3/pyo3/pull/1276">#1276</a></li>
<li>Add support for conversion between <code>char</code> and <code>PyString</code>. <a href="https://github.com/PyO3/pyo3/pull/1282">#1282</a></li>
<li>Add FFI definitions for <code>PyBuffer_SizeFromFormat</code>, <code>PyObject_LengthHint</code>, <code>PyObject_CallNoArgs</code>, <code>PyObject_CallOneArg</code>, <code>PyObject_CallMethodNoArgs</code>, <code>PyObject_CallMethodOneArg</code>, <code>PyObject_VectorcallDict</code>, and <code>PyObject_VectorcallMethod</code>. <a href="https://github.com/PyO3/pyo3/pull/1287">#1287</a></li>
<li>Add conversions between <code>u128</code>/<code>i128</code> and <code>PyLong</code> for PyPy. <a href="https://github.com/PyO3/pyo3/pull/1310">#1310</a></li>
<li>Add <code>Python::version()</code> and <code>Python::version_info()</code> to get the running interpreter version. <a href="https://github.com/PyO3/pyo3/pull/1322">#1322</a></li>
<li>Add conversions for tuples of length 10, 11, and 12. <a href="https://github.com/PyO3/pyo3/pull/1454">#1454</a></li>
</ul>
<h3 id="changed-4"><a class="header" href="#changed-4">Changed</a></h3>
<ul>
<li>Change return type of <code>PyType::name()</code> from <code>Cow&lt;str&gt;</code> to <code>PyResult&lt;&amp;str&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1152">#1152</a></li>
<li><code>#[pyclass(subclass)]</code> is now required for subclassing from Rust (was previously just required for subclassing from Python). <a href="https://github.com/PyO3/pyo3/pull/1152">#1152</a></li>
<li>Change <code>PyIterator</code> to be consistent with other native types: it is now used as <code>&amp;PyIterator</code> instead of <code>PyIterator&lt;'a&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1176">#1176</a></li>
<li>Change formatting of <code>PyDowncastError</code> messages to be closer to Python's builtin error messages. <a href="https://github.com/PyO3/pyo3/pull/1212">#1212</a></li>
<li>Change <code>Debug</code> and <code>Display</code> impls for <code>PyException</code> to be consistent with <code>PyAny</code>. <a href="https://github.com/PyO3/pyo3/pull/1275">#1275</a></li>
<li>Change <code>Debug</code> impl of <code>PyErr</code> to output more helpful information (acquiring the GIL if necessary). <a href="https://github.com/PyO3/pyo3/pull/1275">#1275</a></li>
<li>Rename <code>PyTypeInfo::is_instance</code> and <code>PyTypeInfo::is_exact_instance</code> to <code>PyTypeInfo::is_type_of</code> and <code>PyTypeInfo::is_exact_type_of</code>. <a href="https://github.com/PyO3/pyo3/pull/1278">#1278</a></li>
<li>Optimize <code>PyAny::call0</code>, <code>Py::call0</code> and <code>PyAny::call_method0</code> and <code>Py::call_method0</code> on Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/1285">#1287</a></li>
<li>Require double-quotes for pyclass name argument e.g <code>#[pyclass(name = &quot;MyClass&quot;)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1303">#1303</a></li>
</ul>
<h3 id="deprecated-1"><a class="header" href="#deprecated-1">Deprecated</a></h3>
<ul>
<li>Deprecate <code>Python::is_instance</code>, <code>Python::is_subclass</code>, <code>Python::release</code>, and <code>Python::xdecref</code>. <a href="https://github.com/PyO3/pyo3/pull/1292">#1292</a></li>
</ul>
<h3 id="removed-2"><a class="header" href="#removed-2">Removed</a></h3>
<ul>
<li>Remove deprecated ffi definitions <code>PyUnicode_AsUnicodeCopy</code>, <code>PyUnicode_GetMax</code>, <code>_Py_CheckRecursionLimit</code>, <code>PyObject_AsCharBuffer</code>, <code>PyObject_AsReadBuffer</code>, <code>PyObject_CheckReadBuffer</code> and <code>PyObject_AsWriteBuffer</code>, which will be removed in Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/1217">#1217</a></li>
<li>Remove unused <code>python3</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1235">#1235</a></li>
</ul>
<h3 id="fixed-6"><a class="header" href="#fixed-6">Fixed</a></h3>
<ul>
<li>Fix missing field in <code>PyCodeObject</code> struct (<code>co_posonlyargcount</code>) - caused invalid access to other fields in Python &gt;3.7. <a href="https://github.com/PyO3/pyo3/pull/1260">#1260</a></li>
<li>Fix building for <code>x86_64-unknown-linux-musl</code> target from <code>x86_64-unknown-linux-gnu</code> host. <a href="https://github.com/PyO3/pyo3/pull/1267">#1267</a></li>
<li>Fix <code>#[text_signature]</code> interacting badly with rust <code>r#raw_identifiers</code>. <a href="https://github.com/PyO3/pyo3/pull/1286">#1286</a></li>
<li>Fix FFI definitions for <code>PyObject_Vectorcall</code> and <code>PyVectorcall_Call</code>. <a href="https://github.com/PyO3/pyo3/pull/1285">#1287</a></li>
<li>Fix building with Anaconda python inside a virtualenv. <a href="https://github.com/PyO3/pyo3/pull/1290">#1290</a></li>
<li>Fix definition of opaque FFI types. <a href="https://github.com/PyO3/pyo3/pull/1312">#1312</a></li>
<li>Fix using custom error type in pyclass <code>#[new]</code> methods. <a href="https://github.com/PyO3/pyo3/pull/1319">#1319</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0123v01240124a---2020-11-28"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0123v01240124a---2020-11-28"><a href="https://github.com/pyo3/pyo3/compare/v0.12.3...v0.12.4">0.12.4</a> - 2020-11-28</a></h2>
<h3 id="fixed-7"><a class="header" href="#fixed-7">Fixed</a></h3>
<ul>
<li>Fix reference count bug in implementation of <code>From&lt;Py&lt;T&gt;&gt;</code> for <code>PyObject</code>, a regression introduced in PyO3 0.12. <a href="https://github.com/PyO3/pyo3/pull/1297">#1297</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0122v01230123a---2020-10-12"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0122v01230123a---2020-10-12"><a href="https://github.com/pyo3/pyo3/compare/v0.12.2...v0.12.3">0.12.3</a> - 2020-10-12</a></h2>
<h3 id="fixed-8"><a class="header" href="#fixed-8">Fixed</a></h3>
<ul>
<li>Fix support for Rust versions 1.39 to 1.44, broken by an incorrect internal update to paste 1.0 which was done in PyO3 0.12.2. <a href="https://github.com/PyO3/pyo3/pull/1234">#1234</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0121v01220122a---2020-10-12"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0121v01220122a---2020-10-12"><a href="https://github.com/pyo3/pyo3/compare/v0.12.1...v0.12.2">0.12.2</a> - 2020-10-12</a></h2>
<h3 id="added-7"><a class="header" href="#added-7">Added</a></h3>
<ul>
<li>Add support for keyword-only arguments without default values in <code>#[pyfunction]</code>. <a href="https://github.com/PyO3/pyo3/pull/1209">#1209</a></li>
<li>Add <code>Python::check_signals()</code> as a safe a wrapper for <code>PyErr_CheckSignals()</code>. <a href="https://github.com/PyO3/pyo3/pull/1214">#1214</a></li>
</ul>
<h3 id="fixed-9"><a class="header" href="#fixed-9">Fixed</a></h3>
<ul>
<li>Fix invalid document for protocol methods. <a href="https://github.com/PyO3/pyo3/pull/1169">#1169</a></li>
<li>Hide docs of PyO3 private implementation details in <code>pyo3::class::methods</code>. <a href="https://github.com/PyO3/pyo3/pull/1169">#1169</a></li>
<li>Fix unnecessary rebuild on PATH changes when the python interpreter is provided by PYO3_PYTHON. <a href="https://github.com/PyO3/pyo3/pull/1231">#1231</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0120v01210121a---2020-09-16"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0120v01210121a---2020-09-16"><a href="https://github.com/pyo3/pyo3/compare/v0.12.0...v0.12.1">0.12.1</a> - 2020-09-16</a></h2>
<h3 id="fixed-10"><a class="header" href="#fixed-10">Fixed</a></h3>
<ul>
<li>Fix building for a 32-bit Python on 64-bit Windows with a 64-bit Rust toolchain. <a href="https://github.com/PyO3/pyo3/pull/1179">#1179</a></li>
<li>Fix building on platforms where <code>c_char</code> is <code>u8</code>. <a href="https://github.com/PyO3/pyo3/pull/1182">#1182</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0111v01200120a---2020-09-12"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0111v01200120a---2020-09-12"><a href="https://github.com/pyo3/pyo3/compare/v0.11.1...v0.12.0">0.12.0</a> - 2020-09-12</a></h2>
<h3 id="added-8"><a class="header" href="#added-8">Added</a></h3>
<ul>
<li>Add FFI definitions <code>Py_FinalizeEx</code>, <code>PyOS_getsig</code>, and <code>PyOS_setsig</code>. <a href="https://github.com/PyO3/pyo3/pull/1021">#1021</a></li>
<li>Add <code>PyString::to_str</code> for accessing <code>PyString</code> as <code>&amp;str</code>. <a href="https://github.com/PyO3/pyo3/pull/1023">#1023</a></li>
<li>Add <code>Python::with_gil</code> for executing a closure with the Python GIL. <a href="https://github.com/PyO3/pyo3/pull/1037">#1037</a></li>
<li>Add type information to failures in <code>PyAny::downcast()</code>. <a href="https://github.com/PyO3/pyo3/pull/1050">#1050</a></li>
<li>Implement <code>Debug</code> for <code>PyIterator</code>. <a href="https://github.com/PyO3/pyo3/pull/1051">#1051</a></li>
<li>Add <code>PyBytes::new_with</code> and <code>PyByteArray::new_with</code> for initialising <code>bytes</code> and <code>bytearray</code> objects using a closure. <a href="https://github.com/PyO3/pyo3/pull/1074">#1074</a></li>
<li>Add <code>#[derive(FromPyObject)]</code> macro for enums and structs. <a href="https://github.com/PyO3/pyo3/pull/1065">#1065</a></li>
<li>Add <code>Py::as_ref</code> and <code>Py::into_ref</code> for converting <code>Py&lt;T&gt;</code> to <code>&amp;T</code>. <a href="https://github.com/PyO3/pyo3/pull/1098">#1098</a></li>
<li>Add ability to return <code>Result</code> types other than <code>PyResult</code> from <code>#[pyfunction]</code>, <code>#[pymethod]</code> and <code>#[pyproto]</code> functions. <a href="https://github.com/PyO3/pyo3/pull/1118">#1106</a>.</li>
<li>Implement <code>ToPyObject</code>, <code>IntoPy</code>, and <code>FromPyObject</code> for <a href="https://crates.io/crates/hashbrown">hashbrown</a>'s <code>HashMap</code> and <code>HashSet</code> types (requires the <code>hashbrown</code> feature). <a href="https://github.com/PyO3/pyo3/pull/1114">#1114</a></li>
<li>Add <code>#[pyfunction(pass_module)]</code> and <code>#[pyfn(pass_module)]</code> to pass the module object as the first function argument. <a href="https://github.com/PyO3/pyo3/pull/1143">#1143</a></li>
<li>Add <code>PyModule::add_function</code> and <code>PyModule::add_submodule</code> as typed alternatives to <code>PyModule::add_wrapped</code>. <a href="https://github.com/PyO3/pyo3/pull/1143">#1143</a></li>
<li>Add native <code>PyCFunction</code> and <code>PyFunction</code> types. <a href="https://github.com/PyO3/pyo3/pull/1163">#1163</a></li>
</ul>
<h3 id="changed-5"><a class="header" href="#changed-5">Changed</a></h3>
<ul>
<li>Rework exception types: <a href="https://github.com/PyO3/pyo3/pull/1024">#1024</a> <a href="https://github.com/PyO3/pyo3/pull/1115">#1115</a>
<ul>
<li>Rename exception types from e.g. <code>RuntimeError</code> to <code>PyRuntimeError</code>. The old names continue to exist but are deprecated.</li>
<li>Exception objects are now accessible as <code>&amp;T</code> or <code>Py&lt;T&gt;</code>, just like other Python-native types.</li>
<li>Rename <code>PyException::py_err()</code> to <code>PyException::new_err()</code>.</li>
<li>Rename <code>PyUnicodeDecodeErr::new_err()</code> to <code>PyUnicodeDecodeErr::new()</code>.</li>
<li>Remove <code>PyStopIteration::stop_iteration()</code>.</li>
</ul>
</li>
<li>Require <code>T: Send</code> for the return value <code>T</code> of <code>Python::allow_threads</code>. <a href="https://github.com/PyO3/pyo3/pull/1036">#1036</a></li>
<li>Rename <code>PYTHON_SYS_EXECUTABLE</code> to <code>PYO3_PYTHON</code>. The old name will continue to work (undocumented) but will be removed in a future release. <a href="https://github.com/PyO3/pyo3/pull/1039">#1039</a></li>
<li>Remove <code>unsafe</code> from signature of <code>PyType::as_type_ptr</code>. <a href="https://github.com/PyO3/pyo3/pull/1047">#1047</a></li>
<li>Change return type of <code>PyIterator::from_object</code> to <code>PyResult&lt;PyIterator&gt;</code> (was <code>Result&lt;PyIterator, PyDowncastError&gt;</code>). <a href="https://github.com/PyO3/pyo3/pull/1051">#1051</a></li>
<li><code>IntoPy</code> is no longer implied by <code>FromPy</code>. <a href="https://github.com/PyO3/pyo3/pull/1063">#1063</a></li>
<li>Change <code>PyObject</code> to be a type alias for <code>Py&lt;PyAny&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1063">#1063</a></li>
<li>Rework <code>PyErr</code> to be compatible with the <code>std::error::Error</code> trait: <a href="https://github.com/PyO3/pyo3/pull/1067">#1067</a> <a href="https://github.com/PyO3/pyo3/pull/1115">#1115</a>
<ul>
<li>Implement <code>Display</code>, <code>Error</code>, <code>Send</code> and <code>Sync</code> for <code>PyErr</code> and <code>PyErrArguments</code>.</li>
<li>Add <code>PyErr::instance()</code> for accessing <code>PyErr</code> as <code>&amp;PyBaseException</code>.</li>
<li><code>PyErr</code>'s fields are now an implementation detail. The equivalent values can be accessed with <code>PyErr::ptype()</code>, <code>PyErr::pvalue()</code> and <code>PyErr::ptraceback()</code>.</li>
<li>Change receiver of <code>PyErr::print()</code> and <code>PyErr::print_and_set_sys_last_vars()</code> to <code>&amp;self</code> (was <code>self</code>).</li>
<li>Remove <code>PyErrValue</code>, <code>PyErr::from_value</code>, <code>PyErr::into_normalized()</code>, and <code>PyErr::normalize()</code>.</li>
<li>Remove <code>PyException::into()</code>.</li>
<li>Remove <code>Into&lt;PyResult&lt;T&gt;&gt;</code> for <code>PyErr</code> and <code>PyException</code>.</li>
</ul>
</li>
<li>Change methods generated by <code>#[pyproto]</code> to return <code>NotImplemented</code> if Python should try a reversed operation. #<a href="https://github.com/PyO3/pyo3/pull/1072">1072</a></li>
<li>Change argument to <code>PyModule::add</code> to <code>impl IntoPy&lt;PyObject&gt;</code> (was <code>impl ToPyObject</code>). #<a href="https://github.com/PyO3/pyo3/pull/1124">1124</a></li>
</ul>
<h3 id="removed-3"><a class="header" href="#removed-3">Removed</a></h3>
<ul>
<li>Remove many exception and <code>PyErr</code> APIs; see the &quot;changed&quot; section above. <a href="https://github.com/PyO3/pyo3/pull/1024">#1024</a> <a href="https://github.com/PyO3/pyo3/pull/1067">#1067</a> <a href="https://github.com/PyO3/pyo3/pull/1115">#1115</a></li>
<li>Remove <code>PyString::to_string</code> (use new <code>PyString::to_str</code>). <a href="https://github.com/PyO3/pyo3/pull/1023">#1023</a></li>
<li>Remove <code>PyString::as_bytes</code>. <a href="https://github.com/PyO3/pyo3/pull/1023">#1023</a></li>
<li>Remove <code>Python::register_any</code>. <a href="https://github.com/PyO3/pyo3/pull/1023">#1023</a></li>
<li>Remove <code>GILGuard::acquire</code> from the public API. Use <code>Python::acquire_gil</code> or <code>Python::with_gil</code>. <a href="https://github.com/PyO3/pyo3/pull/1036">#1036</a></li>
<li>Remove the <code>FromPy</code> trait. <a href="https://github.com/PyO3/pyo3/pull/1063">#1063</a></li>
<li>Remove the <code>AsPyRef</code> trait. <a href="https://github.com/PyO3/pyo3/pull/1098">#1098</a></li>
</ul>
<h3 id="fixed-11"><a class="header" href="#fixed-11">Fixed</a></h3>
<ul>
<li>Correct FFI definitions <code>Py_SetProgramName</code> and <code>Py_SetPythonHome</code> to take <code>*const</code> arguments (was <code>*mut</code>). <a href="https://github.com/PyO3/pyo3/pull/1021">#1021</a></li>
<li>Fix <code>FromPyObject</code> for <code>num_bigint::BigInt</code> for Python objects with an <code>__index__</code> method. <a href="https://github.com/PyO3/pyo3/pull/1027">#1027</a></li>
<li>Correct FFI definition <code>_PyLong_AsByteArray</code> to take <code>*mut c_uchar</code> argument (was <code>*const c_uchar</code>). <a href="https://github.com/PyO3/pyo3/pull/1029">#1029</a></li>
<li>Fix segfault with <code>#[pyclass(dict, unsendable)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1058">#1058</a> <a href="https://github.com/PyO3/pyo3/pull/1059">#1059</a></li>
<li>Fix using <code>&amp;Self</code> as an argument type for functions in a <code>#[pymethods]</code> block. <a href="https://github.com/PyO3/pyo3/pull/1071">#1071</a></li>
<li>Fix best-effort build against PyPy 3.6. <a href="https://github.com/PyO3/pyo3/pull/1092">#1092</a></li>
<li>Fix many cases of lifetime elision in <code>#[pyproto]</code> implementations. <a href="https://github.com/PyO3/pyo3/pull/1093">#1093</a></li>
<li>Fix detection of Python build configuration when cross-compiling. <a href="https://github.com/PyO3/pyo3/pull/1095">#1095</a></li>
<li>Always link against libpython on android with the <code>extension-module</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1095">#1095</a></li>
<li>Fix the <code>+</code> operator not trying <code>__radd__</code> when both <code>__add__</code> and <code>__radd__</code> are defined in <code>PyNumberProtocol</code> (and similar for all other reversible operators). <a href="https://github.com/PyO3/pyo3/pull/1107">#1107</a></li>
<li>Fix building with Anaconda python. <a href="https://github.com/PyO3/pyo3/pull/1175">#1175</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0110v01110111a---2020-06-30"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0110v01110111a---2020-06-30"><a href="https://github.com/pyo3/pyo3/compare/v0.11.0...v0.11.1">0.11.1</a> - 2020-06-30</a></h2>
<h3 id="added-9"><a class="header" href="#added-9">Added</a></h3>
<ul>
<li><code>#[pyclass(unsendable)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1009">#1009</a></li>
</ul>
<h3 id="changed-6"><a class="header" href="#changed-6">Changed</a></h3>
<ul>
<li>Update <code>parking_lot</code> dependency to <code>0.11</code>. <a href="https://github.com/PyO3/pyo3/pull/1010">#1010</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0101v01100110a---2020-06-28"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0101v01100110a---2020-06-28"><a href="https://github.com/pyo3/pyo3/compare/v0.10.1...v0.11.0">0.11.0</a> - 2020-06-28</a></h2>
<h3 id="added-10"><a class="header" href="#added-10">Added</a></h3>
<ul>
<li>Support stable versions of Rust (&gt;=1.39). <a href="https://github.com/PyO3/pyo3/pull/969">#969</a></li>
<li>Add FFI definition <code>PyObject_AsFileDescriptor</code>. <a href="https://github.com/PyO3/pyo3/pull/938">#938</a></li>
<li>Add <code>PyByteArray::data</code>, <code>PyByteArray::as_bytes</code>, and <code>PyByteArray::as_bytes_mut</code>. <a href="https://github.com/PyO3/pyo3/pull/967">#967</a></li>
<li>Add <code>GILOnceCell</code> to use in situations where <code>lazy_static</code> or <code>once_cell</code> can deadlock. <a href="https://github.com/PyO3/pyo3/pull/975">#975</a></li>
<li>Add <code>Py::borrow</code>, <code>Py::borrow_mut</code>, <code>Py::try_borrow</code>, and <code>Py::try_borrow_mut</code> for accessing <code>#[pyclass]</code> values. <a href="https://github.com/PyO3/pyo3/pull/976">#976</a></li>
<li>Add <code>IterNextOutput</code> and <code>IterANextOutput</code> for returning from <code>__next__</code> / <code>__anext__</code>. <a href="https://github.com/PyO3/pyo3/pull/997">#997</a></li>
</ul>
<h3 id="changed-7"><a class="header" href="#changed-7">Changed</a></h3>
<ul>
<li>Simplify internals of <code>#[pyo3(get)]</code> attribute. (Remove the hidden API <code>GetPropertyValue</code>.) <a href="https://github.com/PyO3/pyo3/pull/934">#934</a></li>
<li>Call <code>Py_Finalize</code> at exit to flush buffers, etc. <a href="https://github.com/PyO3/pyo3/pull/943">#943</a></li>
<li>Add type parameter to PyBuffer. #<a href="https://github.com/PyO3/pyo3/pull/951">951</a></li>
<li>Require <code>Send</code> bound for <code>#[pyclass]</code>. <a href="https://github.com/PyO3/pyo3/pull/966">#966</a></li>
<li>Add <code>Python</code> argument to most methods on <code>PyObject</code> and <code>Py&lt;T&gt;</code> to ensure GIL safety. <a href="https://github.com/PyO3/pyo3/pull/970">#970</a></li>
<li>Change signature of <code>PyTypeObject::type_object()</code> - now takes <code>Python</code> argument and returns <code>&amp;PyType</code>. <a href="https://github.com/PyO3/pyo3/pull/970">#970</a></li>
<li>Change return type of <code>PyTuple::slice()</code> and <code>PyTuple::split_from()</code> from <code>Py&lt;PyTuple&gt;</code> to <code>&amp;PyTuple</code>. <a href="https://github.com/PyO3/pyo3/pull/970">#970</a></li>
<li>Change return type of <code>PyTuple::as_slice</code> to <code>&amp;[&amp;PyAny]</code>. <a href="https://github.com/PyO3/pyo3/pull/971">#971</a></li>
<li>Rename <code>PyTypeInfo::type_object</code> to <code>type_object_raw</code>, and add <code>Python</code> argument. <a href="https://github.com/PyO3/pyo3/pull/975">#975</a></li>
<li>Update <code>num-complex</code> optional dependendency from <code>0.2</code> to <code>0.3</code>. <a href="https://github.com/PyO3/pyo3/pull/977">#977</a></li>
<li>Update <code>num-bigint</code> optional dependendency from <code>0.2</code> to <code>0.3</code>. <a href="https://github.com/PyO3/pyo3/pull/978">#978</a></li>
<li><code>#[pyproto]</code> is re-implemented without specialization. <a href="https://github.com/PyO3/pyo3/pull/961">#961</a></li>
<li><code>PyClassAlloc::alloc</code> is renamed to <code>PyClassAlloc::new</code>. <a href="https://github.com/PyO3/pyo3/pull/990">#990</a></li>
<li><code>#[pyproto]</code> methods can now have return value <code>T</code> or <code>PyResult&lt;T&gt;</code> (previously only <code>PyResult&lt;T&gt;</code> was supported). <a href="https://github.com/PyO3/pyo3/pull/996">#996</a></li>
<li><code>#[pyproto]</code> methods can now skip annotating the return type if it is <code>()</code>. <a href="https://github.com/PyO3/pyo3/pull/998">#998</a></li>
</ul>
<h3 id="removed-4"><a class="header" href="#removed-4">Removed</a></h3>
<ul>
<li>Remove <code>ManagedPyRef</code> (unused, and needs specialization) <a href="https://github.com/PyO3/pyo3/pull/930">#930</a></li>
</ul>
<h3 id="fixed-12"><a class="header" href="#fixed-12">Fixed</a></h3>
<ul>
<li>Fix passing explicit <code>None</code> to <code>Option&lt;T&gt;</code> argument <code>#[pyfunction]</code> with a default value. <a href="https://github.com/PyO3/pyo3/pull/936">#936</a></li>
<li>Fix <code>PyClass.__new__</code>'s not respecting subclasses when inherited by a Python class. <a href="https://github.com/PyO3/pyo3/pull/990">#990</a></li>
<li>Fix returning <code>Option&lt;T&gt;</code> from <code>#[pyproto]</code> methods. <a href="https://github.com/PyO3/pyo3/pull/996">#996</a></li>
<li>Fix accepting <code>PyRef&lt;Self&gt;</code> and <code>PyRefMut&lt;Self&gt;</code> to <code>#[getter]</code> and <code>#[setter]</code> methods. <a href="https://github.com/PyO3/pyo3/pull/999">#999</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0100v01010101a---2020-05-14"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0100v01010101a---2020-05-14"><a href="https://github.com/pyo3/pyo3/compare/v0.10.0...v0.10.1">0.10.1</a> - 2020-05-14</a></h2>
<h3 id="fixed-13"><a class="header" href="#fixed-13">Fixed</a></h3>
<ul>
<li>Fix deadlock in <code>Python::acquire_gil()</code> after dropping a <code>PyObject</code> or <code>Py&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/924">#924</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev092v01000100a---2020-05-13"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev092v01000100a---2020-05-13"><a href="https://github.com/pyo3/pyo3/compare/v0.9.2...v0.10.0">0.10.0</a> - 2020-05-13</a></h2>
<h3 id="added-11"><a class="header" href="#added-11">Added</a></h3>
<ul>
<li>Add FFI definition <code>_PyDict_NewPresized</code>. <a href="https://github.com/PyO3/pyo3/pull/849">#849</a></li>
<li>Implement <code>IntoPy&lt;PyObject&gt;</code> for <code>HashSet</code> and <code>BTreeSet</code>. <a href="https://github.com/PyO3/pyo3/pull/864">#864</a></li>
<li>Add <code>PyAny::dir</code> method. <a href="https://github.com/PyO3/pyo3/pull/886">#886</a></li>
<li>Gate macros behind a <code>macros</code> feature (enabled by default). <a href="https://github.com/PyO3/pyo3/pull/897">#897</a></li>
<li>Add ability to define class attributes using <code>#[classattr]</code> on functions in <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/905">#905</a></li>
<li>Implement <code>Clone</code> for <code>PyObject</code> and <code>Py&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/908">#908</a></li>
<li>Implement <code>Deref&lt;Target = PyAny&gt;</code> for all builtin types. (<code>PyList</code>, <code>PyTuple</code>, <code>PyDict</code> etc.) <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Implement <code>Deref&lt;Target = PyAny&gt;</code> for <code>PyCell&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Add <code>#[classattr]</code> support for associated constants in <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/914">#914</a></li>
</ul>
<h3 id="changed-8"><a class="header" href="#changed-8">Changed</a></h3>
<ul>
<li>Panics will now be raised as a Python <code>PanicException</code>. <a href="https://github.com/PyO3/pyo3/pull/797">#797</a></li>
<li>Change <code>PyObject</code> and <code>Py&lt;T&gt;</code> reference counts to decrement immediately upon drop when the GIL is held. <a href="https://github.com/PyO3/pyo3/pull/851">#851</a></li>
<li>Allow <code>PyIterProtocol</code> methods to use either <code>PyRef</code> or <code>PyRefMut</code> as the receiver type. <a href="https://github.com/PyO3/pyo3/pull/856">#856</a></li>
<li>Change the implementation of <code>FromPyObject</code> for <code>Py&lt;T&gt;</code> to apply to a wider range of <code>T</code>, including all <code>T: PyClass</code>. <a href="https://github.com/PyO3/pyo3/pull/880">#880</a></li>
<li>Move all methods from the <code>ObjectProtocol</code> trait to the <code>PyAny</code> struct. <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Remove need for <code>#![feature(specialization)]</code> in crates depending on PyO3. <a href="https://github.com/PyO3/pyo3/pull/917">#917</a></li>
</ul>
<h3 id="removed-5"><a class="header" href="#removed-5">Removed</a></h3>
<ul>
<li>Remove <code>PyMethodsProtocol</code> trait. <a href="https://github.com/PyO3/pyo3/pull/889">#889</a></li>
<li>Remove <code>num-traits</code> dependency. <a href="https://github.com/PyO3/pyo3/pull/895">#895</a></li>
<li>Remove <code>ObjectProtocol</code> trait. <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Remove <code>PyAny::None</code>. Users should use <code>Python::None</code> instead. <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Remove all <code>*ProtocolImpl</code> traits. <a href="https://github.com/PyO3/pyo3/pull/917">#917</a></li>
</ul>
<h3 id="fixed-14"><a class="header" href="#fixed-14">Fixed</a></h3>
<ul>
<li>Fix support for <code>__radd__</code> and other <code>__r*__</code> methods as implementations for Python mathematical operators. <a href="https://github.com/PyO3/pyo3/pull/839">#839</a></li>
<li>Fix panics during garbage collection when traversing objects that were already mutably borrowed. <a href="https://github.com/PyO3/pyo3/pull/855">#855</a></li>
<li>Prevent <code>&amp;'static</code> references to Python objects as arguments to <code>#[pyfunction]</code> and <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/869">#869</a></li>
<li>Fix lifetime safety bug with <code>AsPyRef::as_ref</code>. <a href="https://github.com/PyO3/pyo3/pull/876">#876</a></li>
<li>Fix <code>#[pyo3(get)]</code> attribute on <code>Py&lt;T&gt;</code> fields. <a href="https://github.com/PyO3/pyo3/pull/880">#880</a></li>
<li>Fix segmentation faults caused by functions such as <code>PyList::get_item</code> returning borrowed objects when it was not safe to do so. <a href="https://github.com/PyO3/pyo3/pull/890">#890</a></li>
<li>Fix segmentation faults caused by nested <code>Python::acquire_gil</code> calls creating dangling references. <a href="https://github.com/PyO3/pyo3/pull/893">#893</a></li>
<li>Fix segmentatation faults when a panic occurs during a call to <code>Python::allow_threads</code>. <a href="https://github.com/PyO3/pyo3/pull/912">#912</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev091v092092a---2020-04-09"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev091v092092a---2020-04-09"><a href="https://github.com/pyo3/pyo3/compare/v0.9.1...v0.9.2">0.9.2</a> - 2020-04-09</a></h2>
<h3 id="added-12"><a class="header" href="#added-12">Added</a></h3>
<ul>
<li><code>FromPyObject</code> implementations for <code>HashSet</code> and <code>BTreeSet</code>. <a href="https://github.com/PyO3/pyo3/pull/842">#842</a></li>
</ul>
<h3 id="fixed-15"><a class="header" href="#fixed-15">Fixed</a></h3>
<ul>
<li>Correctly detect 32bit architecture. <a href="https://github.com/PyO3/pyo3/pull/830">#830</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev090v091091a---2020-03-23"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev090v091091a---2020-03-23"><a href="https://github.com/pyo3/pyo3/compare/v0.9.0...v0.9.1">0.9.1</a> - 2020-03-23</a></h2>
<h3 id="fixed-16"><a class="header" href="#fixed-16">Fixed</a></h3>
<ul>
<li>Error messages for <code>#[pyclass]</code>. <a href="https://github.com/PyO3/pyo3/pull/826">#826</a></li>
<li><code>FromPyObject</code> implementation for <code>PySequence</code>. <a href="https://github.com/PyO3/pyo3/pull/827">#827</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev085v090090a---2020-03-19"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev085v090090a---2020-03-19"><a href="https://github.com/pyo3/pyo3/compare/v0.8.5...v0.9.0">0.9.0</a> - 2020-03-19</a></h2>
<h3 id="added-13"><a class="header" href="#added-13">Added</a></h3>
<ul>
<li><code>PyCell</code>, which has RefCell-like features. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>PyClass</code>, <code>PyLayout</code>, <code>PyClassInitializer</code>. <a href="https://github.com/PyO3/pyo3/pull/683">#683</a></li>
<li>Implemented <code>IntoIterator</code> for <code>PySet</code> and <code>PyFrozenSet</code>. <a href="https://github.com/PyO3/pyo3/pull/716">#716</a></li>
<li><code>FromPyObject</code> is now automatically implemented for <code>T: Clone</code> pyclasses. <a href="https://github.com/PyO3/pyo3/pull/730">#730</a></li>
<li><code>#[pyo3(get)]</code> and <code>#[pyo3(set)]</code> will now use the Rust doc-comment from the field for the Python property. <a href="https://github.com/PyO3/pyo3/pull/755">#755</a></li>
<li><code>#[setter]</code> functions may now take an argument of <code>Pyo3::Python</code>. <a href="https://github.com/PyO3/pyo3/pull/760">#760</a></li>
<li><code>PyTypeInfo::BaseLayout</code> and <code>PyClass::BaseNativeType</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>PyDowncastImpl</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li>Implement <code>FromPyObject</code> and <code>IntoPy&lt;PyObject&gt;</code> traits for arrays (up to 32). <a href="https://github.com/PyO3/pyo3/pull/778">#778</a></li>
<li><code>migration.md</code> and <code>types.md</code> in the guide. <a href="https://github.com/PyO3/pyo3/pull/795">#795</a>, #<a href="https://github.com/PyO3/pyo3/pull/802">802</a></li>
<li><code>ffi::{_PyBytes_Resize, _PyDict_Next, _PyDict_Contains, _PyDict_GetDictPtr}</code>. #<a href="https://github.com/PyO3/pyo3/pull/820">820</a></li>
</ul>
<h3 id="changed-9"><a class="header" href="#changed-9">Changed</a></h3>
<ul>
<li><code>#[new]</code> does not take <code>PyRawObject</code> and can return <code>Self</code>. <a href="https://github.com/PyO3/pyo3/pull/683">#683</a></li>
<li>The blanket implementations for <code>FromPyObject</code> for <code>&amp;T</code> and <code>&amp;mut T</code> are no longer specializable. Implement <code>PyTryFrom</code> for your type to control the behavior of <code>FromPyObject::extract()</code> for your types. <a href="https://github.com/PyO3/pyo3/pull/713">#713</a></li>
<li>The implementation for <code>IntoPy&lt;U&gt; for T</code> where <code>U: FromPy&lt;T&gt;</code> is no longer specializable. Control the behavior of this via the implementation of <code>FromPy</code>. <a href="https://github.com/PyO3/pyo3/pull/713">#713</a></li>
<li>Use <code>parking_lot::Mutex</code> instead of <code>spin::Mutex</code>. <a href="https://github.com/PyO3/pyo3/pull/734">#734</a></li>
<li>Bumped minimum Rust version to <code>1.42.0-nightly 2020-01-21</code>. <a href="https://github.com/PyO3/pyo3/pull/761">#761</a></li>
<li><code>PyRef</code> and <code>PyRefMut</code> are renewed for <code>PyCell</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li>Some new FFI functions for Python 3.8. <a href="https://github.com/PyO3/pyo3/pull/784">#784</a></li>
<li><code>PyAny</code> is now on the top level module and prelude. <a href="https://github.com/PyO3/pyo3/pull/816">#816</a></li>
</ul>
<h3 id="removed-6"><a class="header" href="#removed-6">Removed</a></h3>
<ul>
<li><code>PyRawObject</code>. <a href="https://github.com/PyO3/pyo3/pull/683">#683</a></li>
<li><code>PyNoArgsFunction</code>. <a href="https://github.com/PyO3/pyo3/pull/741">#741</a></li>
<li><code>initialize_type()</code>. To set the module name for a <code>#[pyclass]</code>, use the <code>module</code> argument to the macro. #<a href="https://github.com/PyO3/pyo3/pull/751">751</a></li>
<li><code>AsPyRef::as_mut/with/with_mut/into_py/into_mut_py</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>PyTryFrom::try_from_mut/try_from_mut_exact/try_from_mut_unchecked</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>Python::mut_from_owned_ptr/mut_from_borrowed_ptr</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>ObjectProtocol::get_base/get_mut_base</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
</ul>
<h3 id="fixed-17"><a class="header" href="#fixed-17">Fixed</a></h3>
<ul>
<li>Fixed unsoundness of subclassing. <a href="https://github.com/PyO3/pyo3/pull/683">#683</a>.</li>
<li>Clear error indicator when the exception is handled on the Rust side. <a href="https://github.com/PyO3/pyo3/pull/719">#719</a></li>
<li>Usage of raw identifiers with <code>#[pyo3(set)]</code>. <a href="https://github.com/PyO3/pyo3/pull/745">#745</a></li>
<li>Usage of <code>PyObject</code> with <code>#[pyo3(get)]</code>. <a href="https://github.com/PyO3/pyo3/pull/760">#760</a></li>
<li><code>#[pymethods]</code> used in conjunction with <code>#[cfg]</code>. #<a href="https://github.com/PyO3/pyo3/pull/769">769</a></li>
<li><code>&quot;*&quot;</code> in a <code>#[pyfunction()]</code> argument list incorrectly accepting any number of positional arguments (use <code>args = &quot;*&quot;</code> when this behaviour is desired). #<a href="https://github.com/PyO3/pyo3/pull/792">792</a></li>
<li><code>PyModule::dict</code>. #<a href="https://github.com/PyO3/pyo3/pull/809">809</a></li>
<li>Fix the case where <code>DESCRIPTION</code> is not null-terminated. #<a href="https://github.com/PyO3/pyo3/pull/822">822</a></li>
</ul>
<h2 id="085---2020-01-05"><a class="header" href="#085---2020-01-05">[0.8.5] - 2020-01-05</a></h2>
<h3 id="added-14"><a class="header" href="#added-14">Added</a></h3>
<ul>
<li>Implemented <code>FromPyObject</code> for <code>HashMap</code> and <code>BTreeMap</code></li>
<li>Support for <code>#[name = &quot;foo&quot;]</code> attribute for <code>#[pyfunction]</code> and in <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/692">#692</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev084v085084a---2019-12-14"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev084v085084a---2019-12-14"><a href="https://github.com/pyo3/pyo3/compare/v0.8.4...v0.8.5">0.8.4</a> - 2019-12-14</a></h2>
<h3 id="added-15"><a class="header" href="#added-15">Added</a></h3>
<ul>
<li>Support for <code>#[text_signature]</code> attribute. <a href="https://github.com/PyO3/pyo3/pull/675">#675</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev082v083083a---2019-11-23"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev082v083083a---2019-11-23"><a href="https://github.com/pyo3/pyo3/compare/v0.8.2...v0.8.3">0.8.3</a> - 2019-11-23</a></h2>
<h3 id="removed-7"><a class="header" href="#removed-7">Removed</a></h3>
<ul>
<li><code>#[init]</code> is removed. <a href="https://github.com/PyO3/pyo3/pull/658">#658</a></li>
</ul>
<h3 id="fixed-18"><a class="header" href="#fixed-18">Fixed</a></h3>
<ul>
<li>Now all <code>&amp;Py~</code> types have <code>!Send</code> bound. <a href="https://github.com/PyO3/pyo3/pull/655">#655</a></li>
<li>Fix a compile error raised by the stabilization of <code>!</code> type. <a href="https://github.com/PyO3/pyo3/issues/672">#672</a>.</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev081v082082a---2019-10-27"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev081v082082a---2019-10-27"><a href="https://github.com/pyo3/pyo3/compare/v0.8.1...v0.8.2">0.8.2</a> - 2019-10-27</a></h2>
<h3 id="added-16"><a class="header" href="#added-16">Added</a></h3>
<ul>
<li>FFI compatibility for PEP 590 Vectorcall. <a href="https://github.com/PyO3/pyo3/pull/641">#641</a></li>
</ul>
<h3 id="fixed-19"><a class="header" href="#fixed-19">Fixed</a></h3>
<ul>
<li>Fix PySequenceProtocol::set_item. <a href="https://github.com/PyO3/pyo3/pull/624">#624</a></li>
<li>Fix a corner case of BigInt::FromPyObject. <a href="https://github.com/PyO3/pyo3/pull/630">#630</a></li>
<li>Fix index errors in parameter conversion. <a href="https://github.com/PyO3/pyo3/pull/631">#631</a></li>
<li>Fix handling of invalid utf-8 sequences in <code>PyString::as_bytes</code>. <a href="https://github.com/PyO3/pyo3/pull/639">#639</a>
and <code>PyString::to_string_lossy</code> <a href="https://github.com/PyO3/pyo3/pull/642">#642</a>.</li>
<li>Remove <code>__contains__</code> and <code>__iter__</code> from PyMappingProtocol. <a href="https://github.com/PyO3/pyo3/pull/644">#644</a></li>
<li>Fix proc-macro definition of PySetAttrProtocol. <a href="https://github.com/PyO3/pyo3/pull/645">#645</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev080v081081a---2019-10-08"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev080v081081a---2019-10-08"><a href="https://github.com/pyo3/pyo3/compare/v0.8.0...v0.8.1">0.8.1</a> - 2019-10-08</a></h2>
<h3 id="added-17"><a class="header" href="#added-17">Added</a></h3>
<ul>
<li>Conversion between <a href="https://github.com/rust-num/num-bigint">num-bigint</a> and Python int. <a href="https://github.com/PyO3/pyo3/pull/608">#608</a></li>
</ul>
<h3 id="fixed-20"><a class="header" href="#fixed-20">Fixed</a></h3>
<ul>
<li>Make sure the right Python interpreter is used in OSX builds. <a href="https://github.com/PyO3/pyo3/pull/604">#604</a></li>
<li>Patch specialization being broken by Rust 1.40. <a href="https://github.com/PyO3/pyo3/issues/614">#614</a></li>
<li>Fix a segfault around PyErr. <a href="https://github.com/PyO3/pyo3/pull/597">#597</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev070v080080a---2019-09-16"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev070v080080a---2019-09-16"><a href="https://github.com/pyo3/pyo3/compare/v0.7.0...v0.8.0">0.8.0</a> - 2019-09-16</a></h2>
<h3 id="added-18"><a class="header" href="#added-18">Added</a></h3>
<ul>
<li><code>module</code> argument to <code>pyclass</code> macro. <a href="https://github.com/PyO3/pyo3/pull/499">#499</a></li>
<li><code>py_run!</code> macro <a href="https://github.com/PyO3/pyo3/pull/512">#512</a></li>
<li>Use existing fields and methods before calling custom <strong>getattr</strong>. <a href="https://github.com/PyO3/pyo3/pull/505">#505</a></li>
<li><code>PyBytes</code> can now be indexed just like <code>Vec&lt;u8&gt;</code></li>
<li>Implement <code>IntoPy&lt;PyObject&gt;</code> for <code>PyRef</code> and <code>PyRefMut</code>.</li>
</ul>
<h3 id="changed-10"><a class="header" href="#changed-10">Changed</a></h3>
<ul>
<li>Implementing the Using the <code>gc</code> parameter for <code>pyclass</code> (e.g. <code>#[pyclass(gc)]</code>) without implementing the <code>class::PyGCProtocol</code> trait is now a compile-time error. Failing to implement this trait could lead to segfaults. <a href="https://github.com/PyO3/pyo3/pull/532">#532</a></li>
<li><code>PyByteArray::data</code> has been replaced with <code>PyDataArray::to_vec</code> because returning a <code>&amp;[u8]</code> is unsound. (See <a href="https://github.com/PyO3/pyo3/issues/373#issuecomment-512332696">this comment</a> for a great write-up for why that was unsound)</li>
<li>Replace <code>mashup</code> with <code>paste</code>.</li>
<li><code>GILPool</code> gained a <code>Python</code> marker to prevent it from being misused to release Python objects without the GIL held.</li>
</ul>
<h3 id="removed-8"><a class="header" href="#removed-8">Removed</a></h3>
<ul>
<li><code>IntoPyObject</code> was replaced with <code>IntoPy&lt;PyObject&gt;</code></li>
<li><code>#[pyclass(subclass)]</code> is hidden a <code>unsound-subclass</code> feature because it's causing segmentation faults.</li>
</ul>
<h3 id="fixed-21"><a class="header" href="#fixed-21">Fixed</a></h3>
<ul>
<li>More readable error message for generics in pyclass <a href="https://github.com/PyO3/pyo3/pull/503">#503</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev060v070070a---2019-05-26"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev060v070070a---2019-05-26"><a href="https://github.com/pyo3/pyo3/compare/v0.6.0...v0.7.0">0.7.0</a> - 2019-05-26</a></h2>
<h3 id="added-19"><a class="header" href="#added-19">Added</a></h3>
<ul>
<li>PyPy support by omerbenamram in <a href="https://github.com/PyO3/pyo3/pull/393">#393</a></li>
<li>Have <code>PyModule</code> generate an index of its members (<code>__all__</code> list).</li>
<li>Allow <code>slf: PyRef&lt;T&gt;</code> for pyclass(#419)</li>
<li>Allow to use lifetime specifiers in <code>pymethods</code></li>
<li>Add <code>marshal</code> module. <a href="https://github.com/PyO3/pyo3/pull/460">#460</a></li>
</ul>
<h3 id="changed-11"><a class="header" href="#changed-11">Changed</a></h3>
<ul>
<li><code>Python::run</code> returns <code>PyResult&lt;()&gt;</code> instead of <code>PyResult&lt;&amp;PyAny&gt;</code>.</li>
<li>Methods decorated with <code>#[getter]</code> and <code>#[setter]</code> can now omit wrapping the
result type in <code>PyResult</code> if they don't raise exceptions.</li>
</ul>
<h3 id="fixed-22"><a class="header" href="#fixed-22">Fixed</a></h3>
<ul>
<li><code>type_object::PyTypeObject</code> has been marked unsafe because breaking the contract <code>type_object::PyTypeObject::init_type</code> can lead to UB.</li>
<li>Fixed automatic derive of <code>PySequenceProtocol</code> implementation in <a href="https://github.com/PyO3/pyo3/pull/423">#423</a>.</li>
<li>Capitalization &amp; better wording to README.md.</li>
<li>Docstrings of properties is now properly set using the doc of the <code>#[getter]</code> method.</li>
<li>Fixed issues with <code>pymethods</code> crashing on doc comments containing double quotes.</li>
<li><code>PySet::new</code> and <code>PyFrozenSet::new</code> now return <code>PyResult&lt;&amp;Py[Frozen]Set&gt;</code>; exceptions are raised if
the items are not hashable.</li>
<li>Fixed building using <code>venv</code> on Windows.</li>
<li><code>PyTuple::new</code> now returns <code>&amp;PyTuple</code> instead of <code>Py&lt;PyTuple&gt;</code>.</li>
<li>Fixed several issues with argument parsing; notable, the <code>*args</code> and <code>**kwargs</code>
tuple/dict now doesn't contain arguments that are otherwise assigned to parameters.</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev053v060060a---2019-03-28"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev053v060060a---2019-03-28"><a href="https://github.com/pyo3/pyo3/compare/v0.5.3...v0.6.0">0.6.0</a> - 2019-03-28</a></h2>
<h3 id="regressions"><a class="header" href="#regressions">Regressions</a></h3>
<ul>
<li>Currently, <a href="https://github.com/PyO3/pyo3/issues/341">#341</a> causes <code>cargo test</code> to fail with weird linking errors when the <code>extension-module</code> feature is activated. For now you can work around this by making the <code>extension-module</code> feature optional and running the tests with <code>cargo test --no-default-features</code>:</li>
</ul>
<pre><code class="language-toml">[dependencies.pyo3]
version = &quot;0.6.0&quot;

[features]
extension-module = [&quot;pyo3/extension-module&quot;]
default = [&quot;extension-module&quot;]
</code></pre>
<h3 id="added-20"><a class="header" href="#added-20">Added</a></h3>
<ul>
<li>Added a <code>wrap_pymodule!</code> macro similar to the existing <code>wrap_pyfunction!</code> macro. Only available on python 3</li>
<li>Added support for cross compiling (e.g. to arm v7) by mtp401 in <a href="https://github.com/PyO3/pyo3/pull/327">#327</a>. See the &quot;Cross Compiling&quot; section in the &quot;Building and Distribution&quot; chapter of the guide for more details.</li>
<li>The <code>PyRef</code> and <code>PyRefMut</code> types, which allow to differentiate between an instance of a rust struct on the rust heap and an instance that is embedded inside a python object. By kngwyu in <a href="https://github.com/PyO3/pyo3/pull/335">#335</a></li>
<li>Added <code>FromPy&lt;T&gt;</code> and <code>IntoPy&lt;T&gt;</code> which are equivalent to <code>From&lt;T&gt;</code> and <code>Into&lt;T&gt;</code> except that they require a gil token.</li>
<li>Added <code>ManagedPyRef</code>, which should eventually replace <code>ToBorrowedObject</code>.</li>
</ul>
<h3 id="changed-12"><a class="header" href="#changed-12">Changed</a></h3>
<ul>
<li>Renamed <code>PyObjectRef</code> to <code>PyAny</code> in #388</li>
<li>Renamed <code>add_function</code> to <code>add_wrapped</code> as it now also supports modules.</li>
<li>Renamed <code>#[pymodinit]</code> to <code>#[pymodule]</code></li>
<li><code>py.init(|| value)</code> becomes <code>Py::new(value)</code></li>
<li><code>py.init_ref(|| value)</code> becomes <code>PyRef::new(value)</code></li>
<li><code>py.init_mut(|| value)</code> becomes <code>PyRefMut::new(value)</code>.</li>
<li><code>PyRawObject::init</code> is now infallible, e.g. it returns <code>()</code> instead of <code>PyResult&lt;()&gt;</code>.</li>
<li>Renamed <code>py_exception!</code> to <code>create_exception!</code> and refactored the error macros.</li>
<li>Renamed <code>wrap_function!</code> to <code>wrap_pyfunction!</code></li>
<li>Renamed <code>#[prop(get, set)]</code> to <code>#[pyo3(get, set)]</code></li>
<li><code>#[pyfunction]</code> now supports the same arguments as <code>#[pyfn()]</code></li>
<li>Some macros now emit proper spanned errors instead of panics.</li>
<li>Migrated to the 2018 edition</li>
<li><code>crate::types::exceptions</code> moved to <code>crate::exceptions</code></li>
<li>Replace <code>IntoPyTuple</code> with <code>IntoPy&lt;Py&lt;PyTuple&gt;&gt;</code>.</li>
<li><code>IntoPyPointer</code> and <code>ToPyPointer</code> moved into the crate root.</li>
<li><code>class::CompareOp</code> moved into <code>class::basic::CompareOp</code></li>
<li>PyTypeObject is now a direct subtrait PyTypeCreate, removing the old cyclical implementation in <a href="https://github.com/PyO3/pyo3/pull/350">#350</a></li>
<li>Add <code>PyList::{sort, reverse}</code> by chr1sj0nes in <a href="https://github.com/PyO3/pyo3/pull/357">#357</a> and <a href="https://github.com/PyO3/pyo3/pull/358">#358</a></li>
<li>Renamed the <code>typeob</code> module to <code>type_object</code></li>
</ul>
<h3 id="removed-9"><a class="header" href="#removed-9">Removed</a></h3>
<ul>
<li><code>PyToken</code> was removed due to unsoundness (See <a href="https://github.com/PyO3/pyo3/issues/94">#94</a>).</li>
<li>Removed the unnecessary type parameter from <code>PyObjectAlloc</code></li>
<li><code>NoArgs</code>. Just use an empty tuple</li>
<li><code>PyObjectWithGIL</code>. <code>PyNativeType</code> is sufficient now that PyToken is removed.</li>
</ul>
<h3 id="fixed-23"><a class="header" href="#fixed-23">Fixed</a></h3>
<ul>
<li>A soudness hole where every instances of a <code>#[pyclass]</code> struct was considered to be part of a python object, even though you can create instances that are not part of the python heap. This was fixed through <code>PyRef</code> and <code>PyRefMut</code>.</li>
<li>Fix kwargs support in <a href="https://github.com/PyO3/pyo3/pull/328">#328</a>.</li>
<li>Add full support for <code>__dict__</code> in <a href="https://github.com/PyO3/pyo3/pull/403">#403</a>.</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev052v053053a---2019-01-04"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev052v053053a---2019-01-04"><a href="https://github.com/pyo3/pyo3/compare/v0.5.2...v0.5.3">0.5.3</a> - 2019-01-04</a></h2>
<h3 id="fixed-24"><a class="header" href="#fixed-24">Fixed</a></h3>
<ul>
<li>Fix memory leak in ArrayList by kngwyu <a href="https://github.com/PyO3/pyo3/pull/316">#316</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev050v052052a---2018-11-25"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev050v052052a---2018-11-25"><a href="https://github.com/pyo3/pyo3/compare/v0.5.0...v0.5.2">0.5.2</a> - 2018-11-25</a></h2>
<h3 id="fixed-25"><a class="header" href="#fixed-25">Fixed</a></h3>
<ul>
<li>Fix undeterministic segfaults when creating many objects by kngwyu in <a href="https://github.com/PyO3/pyo3/pull/281">#281</a></li>
</ul>
<h2 id="051---2018-11-24"><a class="header" href="#051---2018-11-24">[0.5.1] - 2018-11-24</a></h2>
<p>Yanked</p>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev041v050050a---2018-11-11"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev041v050050a---2018-11-11"><a href="https://github.com/pyo3/pyo3/compare/v0.4.1...v0.5.0">0.5.0</a> - 2018-11-11</a></h2>
<h3 id="added-21"><a class="header" href="#added-21">Added</a></h3>
<ul>
<li><code>#[pyclass]</code> objects can now be returned from rust functions</li>
<li><code>PyComplex</code> by kngwyu in <a href="https://github.com/PyO3/pyo3/pull/226">#226</a></li>
<li><code>PyDict::from_sequence()</code>, equivalent to <code>dict([(key, val), ...])</code></li>
<li>Bindings for the <code>datetime</code> standard library types: <code>PyDate</code>, <code>PyTime</code>, <code>PyDateTime</code>, <code>PyTzInfo</code>, <code>PyDelta</code> with associated <code>ffi</code> types, by pganssle <a href="https://github.com/PyO3/pyo3/pull/200">#200</a>.</li>
<li><code>PyString</code>, <code>PyUnicode</code>, and <code>PyBytes</code> now have an <code>as_bytes()</code> method that returns <code>&amp;[u8]</code>.</li>
<li><code>PyObjectProtocol::get_type_ptr()</code> by ijl in <a href="https://github.com/PyO3/pyo3/pull/242">#242</a></li>
</ul>
<h3 id="changed-13"><a class="header" href="#changed-13">Changed</a></h3>
<ul>
<li>Removes the types from the root module and the prelude. They now live in <code>pyo3::types</code> instead.</li>
<li>All exceptions are consturcted with <code>py_err</code> instead of <code>new</code>, as they return <code>PyErr</code> and not <code>Self</code>.</li>
<li><code>as_mut</code> and friends take and <code>&amp;mut self</code> instead of <code>&amp;self</code></li>
<li><code>ObjectProtocol::call</code> now takes an <code>Option&lt;&amp;PyDict&gt;</code> for the kwargs instead of an <code>IntoPyDictPointer</code>.</li>
<li><code>IntoPyDictPointer</code> was replace by <code>IntoPyDict</code> which doesn't convert <code>PyDict</code> itself anymore and returns a <code>PyDict</code> instead of <code>*mut PyObject</code>.</li>
<li><code>PyTuple::new</code> now takes an <code>IntoIterator</code> instead of a slice</li>
<li>Updated to syn 0.15</li>
<li>Splitted <code>PyTypeObject</code> into <code>PyTypeObject</code> without the create method and <code>PyTypeCreate</code> with requires <code>PyObjectAlloc&lt;Self&gt; + PyTypeInfo + Sized</code>.</li>
<li>Ran <code>cargo edition --fix</code> which prefixed path with <code>crate::</code> for rust 2018</li>
<li>Renamed <code>async</code> to <code>pyasync</code> as async will be a keyword in the 2018 edition.</li>
<li>Starting to use <code>NonNull&lt;*mut PyObject&gt;</code> for Py and PyObject by ijl <a href="https://github.com/PyO3/pyo3/pull/260">#260</a></li>
</ul>
<h3 id="removed-10"><a class="header" href="#removed-10">Removed</a></h3>
<ul>
<li>Removed most entries from the prelude. The new prelude is small and clear.</li>
<li>Slowly removing specialization uses</li>
<li><code>PyString</code>, <code>PyUnicode</code>, and <code>PyBytes</code> no longer have a <code>data()</code> method
(replaced by <code>as_bytes()</code>) and <code>PyStringData</code> has been removed.</li>
<li>The pyobject_extract macro</li>
</ul>
<h3 id="fixed-26"><a class="header" href="#fixed-26">Fixed</a></h3>
<ul>
<li>Added an explanation that the GIL can temporarily be released even while holding a GILGuard.</li>
<li>Lots of clippy errors</li>
<li>Fix segfault on calling an unknown method on a PyObject</li>
<li>Work around a <a href="https://github.com/rust-lang/rust/issues/55380">bug</a> in the rust compiler by kngwyu <a href="https://github.com/PyO3/pyo3/pull/252">#252</a></li>
<li>Fixed a segfault with subclassing pyo3 create classes and using <code>__class__</code> by kngwyu <a href="https://github.com/PyO3/pyo3/pull/263">#263</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev040v041041a---2018-08-20"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev040v041041a---2018-08-20"><a href="https://github.com/pyo3/pyo3/compare/v0.4.0...v0.4.1">0.4.1</a> - 2018-08-20</a></h2>
<h3 id="changed-14"><a class="header" href="#changed-14">Changed</a></h3>
<ul>
<li>PyTryFrom's error is always to <code>PyDowncastError</code></li>
</ul>
<h3 id="fixed-27"><a class="header" href="#fixed-27">Fixed</a></h3>
<ul>
<li>Fixed compilation on nightly since <code>use_extern_macros</code> was stabilized</li>
</ul>
<h3 id="removed-11"><a class="header" href="#removed-11">Removed</a></h3>
<ul>
<li>The pyobject_downcast macro</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev032v040040a---2018-07-30"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev032v040040a---2018-07-30"><a href="https://github.com/pyo3/pyo3/compare/v0.3.2...v0.4.0">0.4.0</a> - 2018-07-30</a></h2>
<h3 id="changed-15"><a class="header" href="#changed-15">Changed</a></h3>
<ul>
<li>Merged both examples into one</li>
<li>Rustfmt all the things :heavy_check_mark:</li>
<li>Switched to <a href="http://keepachangelog.com/en/1.0.0/">Keep a Changelog</a></li>
</ul>
<h3 id="removed-12"><a class="header" href="#removed-12">Removed</a></h3>
<ul>
<li>Conversions from tuples to PyDict due to <a href="https://github.com/rust-lang/rust/issues/52050">rust-lang/rust#52050</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev031v032032a---2018-07-22"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev031v032032a---2018-07-22"><a href="https://github.com/pyo3/pyo3/compare/v0.3.1...v0.3.2">0.3.2</a> - 2018-07-22</a></h2>
<h3 id="changed-16"><a class="header" href="#changed-16">Changed</a></h3>
<ul>
<li>Replaced <code>concat_idents</code> with mashup</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev030v031031a---2018-07-18"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev030v031031a---2018-07-18"><a href="https://github.com/pyo3/pyo3/compare/v0.3.0...v0.3.1">0.3.1</a> - 2018-07-18</a></h2>
<h3 id="fixed-28"><a class="header" href="#fixed-28">Fixed</a></h3>
<ul>
<li>Fixed scoping bug in pyobject_native_type that would break rust-numpy</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev027v030030a---2018-07-18"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev027v030030a---2018-07-18"><a href="https://github.com/pyo3/pyo3/compare/v0.2.7...v0.3.0">0.3.0</a> - 2018-07-18</a></h2>
<h3 id="added-22"><a class="header" href="#added-22">Added</a></h3>
<ul>
<li>A few internal macros became part of the public api (<a href="https://github.com/PyO3/pyo3/pull/155">#155</a>, <a href="https://github.com/PyO3/pyo3/pull/186">#186</a>)</li>
<li>Always clone in getters. This allows using the get-annotation on all Clone-Types</li>
</ul>
<h3 id="changed-17"><a class="header" href="#changed-17">Changed</a></h3>
<ul>
<li>Upgraded to syn 0.14 which means much better error messages :tada:</li>
<li>128 bit integer support by <a href="https://github.com/kngwyu">kngwyu</a> (<a href="https://github.com/PyO3/pyo3/pull/173">#137</a>)</li>
<li><code>proc_macro</code> has been stabilized on nightly (<a href="https://github.com/rust-lang/rust/pull/52081">rust-lang/rust#52081</a>). This means that we can remove the <code>proc_macro</code> feature, but now we need the <code>use_extern_macros</code> from the 2018 edition instead.</li>
<li>All proc macro are now prefixed with <code>py</code> and live in the prelude. This means you can use <code>#[pyclass]</code>, <code>#[pymethods]</code>, <code>#[pyproto]</code>, <code>#[pyfunction]</code> and <code>#[pymodinit]</code> directly, at least after a <code>use pyo3::prelude::*</code>. They were also moved into a module called <code>proc_macro</code>. You shouldn't use <code>#[pyo3::proc_macro::pyclass]</code> or other longer paths in attributes because <code>proc_macro_path_invoc</code> isn't going to be stabilized soon.</li>
<li>Renamed the <code>base</code> option in the <code>pyclass</code> macro to <code>extends</code>.</li>
<li><code>#[pymodinit]</code> uses the function name as module name, unless the name is overrriden with <code>#[pymodinit(name)]</code></li>
<li>The guide is now properly versioned.</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev026v027027a---2018-05-18"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev026v027027a---2018-05-18"><a href="https://github.com/pyo3/pyo3/compare/v0.2.6...v0.2.7">0.2.7</a> - 2018-05-18</a></h2>
<h3 id="fixed-29"><a class="header" href="#fixed-29">Fixed</a></h3>
<ul>
<li>Fix nightly breakage with proc_macro_path</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev025v026026a---2018-04-03"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev025v026026a---2018-04-03"><a href="https://github.com/pyo3/pyo3/compare/v0.2.5...v0.2.6">0.2.6</a> - 2018-04-03</a></h2>
<h3 id="fixed-30"><a class="header" href="#fixed-30">Fixed</a></h3>
<ul>
<li>Fix compatibility with TryFrom trait #137</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev024v025025a---2018-02-21"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev024v025025a---2018-02-21"><a href="https://github.com/pyo3/pyo3/compare/v0.2.4...v0.2.5">0.2.5</a> - 2018-02-21</a></h2>
<h3 id="added-23"><a class="header" href="#added-23">Added</a></h3>
<ul>
<li>CPython 3.7 support</li>
</ul>
<h3 id="fixed-31"><a class="header" href="#fixed-31">Fixed</a></h3>
<ul>
<li>Embedded CPython 3.7b1 crashes on initialization #110</li>
<li>Generated extension functions are weakly typed #108</li>
<li>call_method*() crashes when the method does not exist #113</li>
<li>Allow importing exceptions from nested modules #116</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev023v024024a---2018-01-19"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev023v024024a---2018-01-19"><a href="https://github.com/pyo3/pyo3/compare/v0.2.3...v0.2.4">0.2.4</a> - 2018-01-19</a></h2>
<h3 id="added-24"><a class="header" href="#added-24">Added</a></h3>
<ul>
<li>Allow to get mutable ref from PyObject #106</li>
<li>Drop <code>RefFromPyObject</code> trait</li>
<li>Add Python::register_any() method</li>
</ul>
<h3 id="fixed-32"><a class="header" href="#fixed-32">Fixed</a></h3>
<ul>
<li>Fix impl <code>FromPyObject</code> for <code>Py&lt;T&gt;</code></li>
<li>Mark method that work with raw pointers as unsafe #95</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev022v023023a---11-27-2017"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev022v023023a---11-27-2017"><a href="https://github.com/pyo3/pyo3/compare/v0.2.2...v0.2.3">0.2.3</a> - 11-27-2017</a></h2>
<h3 id="changed-18"><a class="header" href="#changed-18">Changed</a></h3>
<ul>
<li>Rustup to 1.23.0-nightly 2017-11-07</li>
</ul>
<h3 id="fixed-33"><a class="header" href="#fixed-33">Fixed</a></h3>
<ul>
<li>Proper <code>c_char</code> usage #93</li>
</ul>
<h3 id="removed-13"><a class="header" href="#removed-13">Removed</a></h3>
<ul>
<li>Remove use of now unneeded 'AsciiExt' trait</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev021v022022a---09-26-2017"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev021v022022a---09-26-2017"><a href="https://github.com/pyo3/pyo3/compare/v0.2.1...v0.2.2">0.2.2</a> - 09-26-2017</a></h2>
<h3 id="changed-19"><a class="header" href="#changed-19">Changed</a></h3>
<ul>
<li>Rustup to 1.22.0-nightly 2017-09-30</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev020v021021a---09-26-2017"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev020v021021a---09-26-2017"><a href="https://github.com/pyo3/pyo3/compare/v0.2.0...v0.2.1">0.2.1</a> - 09-26-2017</a></h2>
<h3 id="fixed-34"><a class="header" href="#fixed-34">Fixed</a></h3>
<ul>
<li>Fix rustc const_fn nightly breakage</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev010v020020a---08-12-2017"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev010v020020a---08-12-2017"><a href="https://github.com/pyo3/pyo3/compare/v0.1.0...v0.2.0">0.2.0</a> - 08-12-2017</a></h2>
<h3 id="added-25"><a class="header" href="#added-25">Added</a></h3>
<ul>
<li>Added inheritance support #15</li>
<li>Added weakref support #56</li>
<li>Added subclass support #64</li>
<li>Added <code>self.__dict__</code> supoort #68</li>
<li>Added <code>pyo3::prelude</code> module #70</li>
<li>Better <code>Iterator</code> support for PyTuple, PyList, PyDict #75</li>
<li>Introduce IntoPyDictPointer similar to IntoPyTuple #69</li>
</ul>
<h3 id="changed-20"><a class="header" href="#changed-20">Changed</a></h3>
<ul>
<li>Allow to add gc support without implementing PyGCProtocol #57</li>
<li>Refactor <code>PyErr</code> implementation. Drop <code>py</code> parameter from constructor.</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3tree010010a---07-23-2017"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3tree010010a---07-23-2017"><a href="https://github.com/PyO3/pyo3/tree/0.1.0">0.1.0</a> - 07-23-2017</a></h2>
<h3 id="added-26"><a class="header" href="#added-26">Added</a></h3>
<ul>
<li>Initial release</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
