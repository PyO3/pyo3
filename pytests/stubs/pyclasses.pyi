from _typeshed import Incomplete
from typing import Final, final

class AssertingBaseClass:
    """
    Demonstrates a base class which can operate on the relevant subclass in its constructor.
    """
    def __new__(cls, /, expected_type: type) -> AssertingBaseClass: ...

@final
class ClassWithDecorators:
    cls_attribute: Final[int]
    """
    A class attribute
    """
    def __new__(cls, /) -> ClassWithDecorators: ...
    @property
    def attr(self, /) -> int:
        """
        A getter
        """
    @attr.deleter
    def attr(self, /) -> None:
        """
        A deleter
        """
    @attr.setter
    def attr(self, /, value: int) -> None:
        """
        A setter
        """
    @classmethod
    def cls_method(cls, /) -> int:
        """
        A class method
        """
    @staticmethod
    def static_method() -> int:
        """
        A static method
        """

@final
class ClassWithDict:
    def __new__(cls, /) -> ClassWithDict: ...

@final
class ClassWithoutConstructor: ...

@final
class EmptyClass:
    def __len__(self, /) -> int: ...
    def __new__(cls, /) -> EmptyClass: ...
    def method(self, /) -> None: ...

@final
class Number:
    def __abs__(self, /) -> Number: ...
    def __add__(self, /, other: object) -> Number: ...
    def __and__(self, /, other: object) -> Number: ...
    def __complex__(self, /) -> complex: ...
    def __divmod__(self, /, other: object) -> tuple[Number, Number]: ...
    def __eq__(self, /, other: object) -> bool: ...
    def __float__(self, /) -> float: ...
    def __floordiv__(self, /, other: object) -> Number: ...
    def __ge__(self, /, other: object) -> bool: ...
    def __gt__(self, /, other: object) -> bool: ...
    def __hash__(self, /) -> int: ...
    def __int__(self, /) -> int: ...
    def __invert__(self, /) -> Number: ...
    def __le__(self, /, other: object) -> bool: ...
    def __lshift__(self, /, other: object) -> Number: ...
    def __lt__(self, /, other: object) -> bool: ...
    def __matmul__(self, /, other: object) -> Number: ...
    def __mod__(self, /, other: object) -> Number: ...
    def __mul__(self, /, other: object) -> Number: ...
    def __ne__(self, /, other: object) -> bool: ...
    def __neg__(self, /) -> Number: ...
    def __new__(cls, /, value: int) -> Number: ...
    def __or__(self, /, other: object) -> Number: ...
    def __pos__(self, /) -> Number: ...
    def __pow__(self, /, other: object, modulo: object) -> Number: ...
    def __repr__(self, /) -> str: ...
    def __rshift__(self, /, other: object) -> Number: ...
    def __str__(self, /) -> str: ...
    def __sub__(self, /, other: object) -> Number: ...
    def __truediv__(self, /, other: object) -> Number: ...
    def __xor__(self, /, other: object) -> Number: ...

@final
class PlainObject:
    @property
    def bar(self, /) -> int:
        """
        Bar
        """
    @bar.setter
    def bar(self, /, value: int) -> None:
        """
        Bar
        """
    @property
    def foo(self, /) -> str:
        """
        Foo
        """
    @foo.setter
    def foo(self, /, value: str) -> None:
        """
        Foo
        """

@final
class PyClassIter:
    """
    This is for demonstrating how to return a value from __next__
    """
    def __new__(cls, /) -> PyClassIter:
        """
        A constructor
        """
    def __next__(self, /) -> int: ...

@final
class PyClassThreadIter:
    def __new__(cls, /) -> PyClassThreadIter: ...
    def __next__(self, /) -> int: ...

@final
class SubClassWithInit(dict):
    def __init__(self, /, *args, **kwargs) -> None: ...
    def __new__(cls, /, *args, **kwargs) -> SubClassWithInit: ...

def map_a_class(
    cls: EmptyClass | tuple[EmptyClass, EmptyClass] | Incomplete,
) -> EmptyClass | tuple[EmptyClass, EmptyClass] | Incomplete: ...
