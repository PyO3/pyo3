<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Python classes - PyO3 user guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="PyO3 user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/tabs.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PyO3 user guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/PyO3/pyo3/tree/main/guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/PyO3/pyo3/edit/main/guide/src/class.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="python-classes"><a class="header" href="#python-classes">Python classes</a></h1>
<p>PyO3 exposes a group of attributes powered by Rust's proc macro system for defining Python classes as Rust structs.</p>
<p>The main attribute is <code>#[pyclass]</code>, which is placed upon a Rust <code>struct</code> or <code>enum</code> to generate a Python type for it. They will usually also have <em>one</em> <code>#[pymethods]</code>-annotated <code>impl</code> block for the struct, which is used to define Python methods and constants for the generated Python type. (If the <a href="features.html#multiple-pymethods"><code>multiple-pymethods</code></a> feature is enabled, each <code>#[pyclass]</code> is allowed to have multiple <code>#[pymethods]</code> blocks.) <code>#[pymethods]</code> may also have implementations for Python magic methods such as <code>__str__</code>.</p>
<p>This chapter will discuss the functionality and configuration these attributes offer. Below is a list of links to the relevant section of this chapter for each:</p>
<ul>
<li><a href="#defining-a-new-class"><code>#[pyclass]</code></a>
<ul>
<li><a href="#object-properties-using-pyo3get-set"><code>#[pyo3(get, set)]</code></a></li>
</ul>
</li>
<li><a href="#instance-methods"><code>#[pymethods]</code></a>
<ul>
<li><a href="#constructor"><code>#[new]</code></a></li>
<li><a href="#object-properties-using-getter-and-setter"><code>#[getter]</code></a></li>
<li><a href="#object-properties-using-getter-and-setter"><code>#[setter]</code></a></li>
<li><a href="#static-methods"><code>#[staticmethod]</code></a></li>
<li><a href="#class-methods"><code>#[classmethod]</code></a></li>
<li><a href="#class-attributes"><code>#[classattr]</code></a></li>
<li><a href="#method-arguments"><code>#[args]</code></a></li>
</ul>
</li>
<li><a href="class/protocols.html">Magic methods and slots</a></li>
<li><a href="#classes-as-function-arguments">Classes as function arguments</a></li>
</ul>
<h2 id="defining-a-new-class"><a class="header" href="#defining-a-new-class">Defining a new class</a></h2>
<p>To define a custom Python class, add the <code>#[pyclass]</code> attribute to a Rust struct or enum.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

#[pyclass]
struct MyClass {
    inner: i32,
}

// A "tuple" struct
#[pyclass]
struct Number(i32);

// PyO3 supports unit-only enums (which contain only unit variants)
// These simple enums behave similarly to Python's enumerations (enum.Enum)
#[pyclass(eq, eq_int)]
#[derive(PartialEq)]
enum MyEnum {
    Variant,
    OtherVariant = 30, // PyO3 supports custom discriminants.
}

// PyO3 supports custom discriminants in unit-only enums
#[pyclass(eq, eq_int)]
#[derive(PartialEq)]
enum HttpResponse {
    Ok = 200,
    NotFound = 404,
    Teapot = 418,
    // ...
}

// PyO3 also supports enums with Struct and Tuple variants
// These complex enums have slightly different behavior from the simple enums above
// They are meant to work with instance checks and match statement patterns
// The variants can be mixed and matched
// Struct variants have named fields while tuple enums generate generic names for fields in order _0, _1, _2, ...
// Apart from this both types are functionally identical
#[pyclass]
enum Shape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
    RegularPolygon(u32, f64),
    Nothing(),
}</code></pre>
<p>The above example generates implementations for <a href="https://docs.rs/pyo3/0.27.1/pyo3/type_object/trait.PyTypeInfo.html"><code>PyTypeInfo</code></a> and <a href="https://docs.rs/pyo3/0.27.1/pyo3/pyclass/trait.PyClass.html"><code>PyClass</code></a> for <code>MyClass</code>, <code>Number</code>, <code>MyEnum</code>, <code>HttpResponse</code>, and <code>Shape</code>. To see these generated implementations, refer to the <a href="#implementation-details">implementation details</a> at the end of this chapter.</p>
<h3 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h3>
<p>To integrate Rust types with Python, PyO3 needs to place some restrictions on the types which can be annotated with <code>#[pyclass]</code>. In particular, they must have no lifetime parameters, no generic parameters, and must be thread-safe. The reason for each of these is explained below.</p>
<h4 id="no-lifetime-parameters"><a class="header" href="#no-lifetime-parameters">No lifetime parameters</a></h4>
<p>Rust lifetimes are used by the Rust compiler to reason about a program's memory safety. They are a compile-time only concept; there is no way to access Rust lifetimes at runtime from a dynamic language like Python.</p>
<p>As soon as Rust data is exposed to Python, there is no guarantee that the Rust compiler can make on how long the data will live. Python is a reference-counted language and those references can be held for an arbitrarily long time which is untraceable by the Rust compiler. The only possible way to express this correctly is to require that any <code>#[pyclass]</code> does not borrow data for any lifetime shorter than the <code>'static</code> lifetime, i.e. the <code>#[pyclass]</code> cannot have any lifetime parameters.</p>
<p>When you need to share ownership of data between Python and Rust, instead of using borrowed references with lifetimes consider using reference-counted smart pointers such as <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> or <a href="https://docs.rs/pyo3/0.27.1/pyo3/struct.Py.html"><code>Py</code></a>.</p>
<h4 id="no-generic-parameters"><a class="header" href="#no-generic-parameters">No generic parameters</a></h4>
<p>A Rust <code>struct Foo&lt;T&gt;</code> with a generic parameter <code>T</code> generates new compiled implementations each time it is used with a different concrete type for <code>T</code>. These new implementations are generated by the compiler at each usage site. This is incompatible with wrapping <code>Foo</code> in Python, where there needs to be a single compiled implementation of <code>Foo</code> which is integrated with the Python interpreter.</p>
<p>Currently, the best alternative is to write a macro which expands to a new <code>#[pyclass]</code> for each instantiation you want:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

struct GenericClass&lt;T&gt; {
    data: T,
}

macro_rules! create_interface {
    ($name: ident, $type: ident) =&gt; {
        #[pyclass]
        pub struct $name {
            inner: GenericClass&lt;$type&gt;,
        }
        #[pymethods]
        impl $name {
            #[new]
            pub fn new(data: $type) -&gt; Self {
                Self {
                    inner: GenericClass { data: data },
                }
            }
        }
    };
}

create_interface!(IntClass, i64);
create_interface!(FloatClass, String);</code></pre>
<h4 id="must-be-thread-safe"><a class="header" href="#must-be-thread-safe">Must be thread-safe</a></h4>
<p>Python objects are freely shared between threads by the Python interpreter. This means that:</p>
<ul>
<li>Python objects may be created and destroyed by different Python threads; therefore <code>#[pyclass]</code> objects must be <code>Send</code>.</li>
<li>Python objects may be accessed by multiple Python threads simultaneously; therefore <code>#[pyclass]</code> objects must be <code>Sync</code>.</li>
</ul>
<p>For now, don't worry about these requirements; simple classes will already be thread-safe. There is a <a href="./class/thread-safety.html">detailed discussion on thread-safety</a> later in the guide.</p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<p>By default, it is not possible to create an instance of a custom class from Python code.
To declare a constructor, you need to define a method and annotate it with the <code>#[new]</code>
attribute. Only Python's <code>__new__</code> method can be specified, <code>__init__</code> is not available.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    #[new]
    fn new(value: i32) -&gt; Self {
        Number(value)
    }
}</code></pre>
<p>Alternatively, if your <code>new</code> method may fail you can return <code>PyResult&lt;Self&gt;</code>.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::exceptions::PyValueError;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Nonzero(i32);
</span><span class="boring">
</span>#[pymethods]
impl Nonzero {
    #[new]
    fn py_new(value: i32) -&gt; PyResult&lt;Self&gt; {
        if value == 0 {
            Err(PyValueError::new_err("cannot be zero"))
        } else {
            Ok(Nonzero(value))
        }
    }
}</code></pre>
<p>If you want to return an existing object (for example, because your <code>new</code>
method caches the values it returns), <code>new</code> can return <code>pyo3::Py&lt;Self&gt;</code>.</p>
<p>As you can see, the Rust method name is not important here; this way you can
still, use <code>new()</code> for a Rust-level constructor.</p>
<p>If no method marked with <code>#[new]</code> is declared, object instances can only be
created from Rust, but not from Python.</p>
<p>For arguments, see the <a href="#method-arguments"><code>Method arguments</code></a> section below.</p>
<h2 id="adding-the-class-to-a-module"><a class="header" href="#adding-the-class-to-a-module">Adding the class to a module</a></h2>
<p>The next step is to create the Python module and add our class to it:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">fn main() {}
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymodule]
mod my_module {
    #[pymodule_export]
    use super::Number;
}</code></pre>
<h2 id="bound-and-interior-mutability"><a class="header" href="#bound-and-interior-mutability">Bound<T> and interior mutability</a></h2>
<p>It is often useful to turn a <code>#[pyclass]</code> type <code>T</code> into a Python object and access it from Rust code. The <a href="https://docs.rs/pyo3/0.27.1/pyo3/struct.Py.html"><code>Py&lt;T&gt;</code></a> and <a href="https://docs.rs/pyo3/0.27.1/pyo3/struct.Bound.html"><code>Bound&lt;'py, T&gt;</code></a> smart pointers are the ways to represent a Python object in PyO3's API. More detail can be found about them <a href="./types.html#pyo3s-smart-pointers">in the Python objects</a> section of the guide.</p>
<p>Most Python objects do not offer exclusive (<code>&amp;mut</code>) access (see the <a href="./python-from-rust.html#pythons-memory-model">section on Python's memory model</a>). However, Rust structs wrapped as Python objects (called <code>pyclass</code> types) often <em>do</em> need <code>&amp;mut</code> access.
However, the Rust borrow checker cannot reason about <code>&amp;mut</code> references once an object's ownership has been passed to the Python interpreter.</p>
<p>To solve this, PyO3 does borrow checking at runtime using a scheme very similar to <code>std::cell::RefCell&lt;T&gt;</code>. This is known as <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">interior mutability</a>.</p>
<p>Users who are familiar with <code>RefCell&lt;T&gt;</code> can use <code>Py&lt;T&gt;</code> and <code>Bound&lt;'py, T&gt;</code> just like <code>RefCell&lt;T&gt;</code>.</p>
<p>For users who are not very familiar with <code>RefCell&lt;T&gt;</code>, here is a reminder of Rust's rules of borrowing:</p>
<ul>
<li>At any given time, you can have either (but not both of) one mutable reference or any number of immutable references.</li>
<li>References can never outlast the data they refer to.</li>
</ul>
<p><code>Py&lt;T&gt;</code> and <code>Bound&lt;'py, T&gt;</code>, like <code>RefCell&lt;T&gt;</code>, ensure these borrowing rules by tracking references at runtime.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    #[pyo3(get)]
    num: i32,
}
Python::attach(|py| {
    let obj = Bound::new(py, MyClass { num: 3 }).unwrap();
    {
        let obj_ref = obj.borrow(); // Get PyRef
        assert_eq!(obj_ref.num, 3);
        // You cannot get PyRefMut unless all PyRefs are dropped
        assert!(obj.try_borrow_mut().is_err());
    }
    {
        let mut obj_mut = obj.borrow_mut(); // Get PyRefMut
        obj_mut.num = 5;
        // You cannot get any other refs until the PyRefMut is dropped
        assert!(obj.try_borrow().is_err());
        assert!(obj.try_borrow_mut().is_err());
    }

    // You can convert `Bound` to a Python object
    pyo3::py_run!(py, obj, "assert obj.num == 5");
});</code></pre>
<p>A <code>Bound&lt;'py, T&gt;</code> is restricted to the Python lifetime <code>'py</code>. To make the object longer lived (for example, to store it in a struct on the
Rust side), use <code>Py&lt;T&gt;</code>. <code>Py&lt;T&gt;</code> needs a <code>Python&lt;'_&gt;</code> token to allow access:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}

fn return_myclass() -&gt; Py&lt;MyClass&gt; {
    Python::attach(|py| Py::new(py, MyClass { num: 1 }).unwrap())
}

let obj = return_myclass();

Python::attach(move |py| {
    let bound = obj.bind(py); // Py&lt;MyClass&gt;::bind returns &amp;Bound&lt;'py, MyClass&gt;
    let obj_ref = bound.borrow(); // Get PyRef&lt;T&gt;
    assert_eq!(obj_ref.num, 1);
});</code></pre>
<h3 id="frozen-classes-opting-out-of-interior-mutability"><a class="header" href="#frozen-classes-opting-out-of-interior-mutability">frozen classes: Opting out of interior mutability</a></h3>
<p>As detailed above, runtime borrow checking is currently enabled by default. But a class can opt of out it by declaring itself <code>frozen</code>. It can still use interior mutability via standard Rust types like <code>RefCell</code> or <code>Mutex</code>, but it is not bound to the implementation provided by PyO3 and can choose the most appropriate strategy on field-by-field basis.</p>
<p>Classes which are <code>frozen</code> and also <code>Sync</code>, e.g. they do use <code>Mutex</code> but not <code>RefCell</code>, can be accessed without needing a <code>Python</code> token via the <code>Bound::get</code> and <code>Py::get</code> methods:</p>
<pre><code class="language-rust">use std::sync::atomic::{AtomicUsize, Ordering};
<span class="boring">use pyo3::prelude::*;
</span>
#[pyclass(frozen)]
struct FrozenCounter {
    value: AtomicUsize,
}

let py_counter: Py&lt;FrozenCounter&gt; = Python::attach(|py| {
    let counter = FrozenCounter {
        value: AtomicUsize::new(0),
    };

    Py::new(py, counter).unwrap()
});

py_counter.get().value.fetch_add(1, Ordering::Relaxed);

Python::attach(move |_py| drop(py_counter));</code></pre>
<p>Frozen classes are likely to become the default thereby guiding the PyO3 ecosystem towards a more deliberate application of interior mutability. Eventually, this should enable further optimizations of PyO3's internals and avoid downstream code paying the cost of interior mutability when it is not actually required.</p>
<h2 id="customizing-the-class"><a class="header" href="#customizing-the-class">Customizing the class</a></h2>
<p><code>#[pyclass]</code> can be used with the following parameters:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>constructor</code></td><td style="text-align: left">This is currently only allowed on <a href="https://pyo3.rs/latest/class.html#complex-enums">variants of complex enums</a>. It allows customization of the generated class constructor for each variant. It uses the same syntax and supports the same options as the <code>signature</code> attribute of functions and methods.</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>crate = "some::path"</code></span></td><td style="text-align: left">Path to import the <code>pyo3</code> crate, if it's not accessible at <code>::pyo3</code>.</td></tr>
<tr><td style="text-align: left"><code>dict</code></td><td style="text-align: left">Gives instances of this class an empty <code>__dict__</code> to store custom attributes.</td></tr>
<tr><td style="text-align: left"><code>eq</code></td><td style="text-align: left">Implements <code>__eq__</code> using the <code>PartialEq</code> implementation of the underlying Rust datatype.</td></tr>
<tr><td style="text-align: left"><code>eq_int</code></td><td style="text-align: left">Implements <code>__eq__</code> using <code>__int__</code> for simple enums.</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>extends = BaseType</code></span></td><td style="text-align: left">Use a custom baseclass. Defaults to <a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyAny.html"><code>PyAny</code></a></td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>freelist = N</code></span></td><td style="text-align: left">Implements a <a href="https://en.wikipedia.org/wiki/Free_list">free list</a> of size N. This can improve performance for types that are often created and deleted in quick succession. Profile your code to see whether <code>freelist</code> is right for you.</td></tr>
<tr><td style="text-align: left"><code>from_py_object</code></td><td style="text-align: left">Implement <code>FromPyObject</code> for this pyclass. Requires the pyclass to be <code>Clone</code>.</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>frozen</code></span></td><td style="text-align: left">Declares that your pyclass is immutable. It removes the borrow checker overhead when retrieving a shared reference to the Rust struct, but disables the ability to get a mutable reference.</td></tr>
<tr><td style="text-align: left"><code>generic</code></td><td style="text-align: left">Implements runtime parametrization for the class following <a href="https://peps.python.org/pep-0560/">PEP 560</a>.</td></tr>
<tr><td style="text-align: left"><code>get_all</code></td><td style="text-align: left">Generates getters for all fields of the pyclass.</td></tr>
<tr><td style="text-align: left"><code>hash</code></td><td style="text-align: left">Implements <code>__hash__</code> using the <code>Hash</code> implementation of the underlying Rust datatype. <em>Requires <code>eq</code> and <code>frozen</code></em></td></tr>
<tr><td style="text-align: left"><code>immutable_type</code></td><td style="text-align: left">Makes the type object immutable. Supported on 3.14+ with the <code>abi3</code> feature active, or 3.10+ otherwise.</td></tr>
<tr><td style="text-align: left"><code>mapping</code></td><td style="text-align: left">Inform PyO3 that this class is a <a href="https://pyo3.rs/latest/class/protocols.html#mapping--sequence-types"><code>Mapping</code></a>, and so leave its implementation of sequence C-API slots empty.</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>module = "module_name"</code></span></td><td style="text-align: left">Python code will see the class as being defined in this module. Defaults to <code>builtins</code>.</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>name = "python_name"</code></span></td><td style="text-align: left">Sets the name that Python sees this class as. Defaults to the name of the Rust struct.</td></tr>
<tr><td style="text-align: left"><code>ord</code></td><td style="text-align: left">Implements <code>__lt__</code>, <code>__gt__</code>, <code>__le__</code>, &amp; <code>__ge__</code> using the <code>PartialOrd</code> implementation of the underlying Rust datatype. <em>Requires <code>eq</code></em></td></tr>
<tr><td style="text-align: left"><code>rename_all = "renaming_rule"</code></td><td style="text-align: left">Applies renaming rules to every getters and setters of a struct, or every variants of an enum. Possible values are: "camelCase", "kebab-case", "lowercase", "PascalCase", "SCREAMING-KEBAB-CASE", "SCREAMING_SNAKE_CASE", "snake_case", "UPPERCASE".</td></tr>
<tr><td style="text-align: left"><code>sequence</code></td><td style="text-align: left">Inform PyO3 that this class is a <a href="https://pyo3.rs/latest/class/protocols.html#mapping--sequence-types"><code>Sequence</code></a>, and so leave its C-API mapping length slot empty.</td></tr>
<tr><td style="text-align: left"><code>set_all</code></td><td style="text-align: left">Generates setters for all fields of the pyclass.</td></tr>
<tr><td style="text-align: left"><code>skip_from_py_object</code></td><td style="text-align: left">Prevents this PyClass from participating in the <code>FromPyObject: PyClass + Clone</code> blanket implementation. This allows a custom <code>FromPyObject</code> impl, even if <code>self</code> is <code>Clone</code>.</td></tr>
<tr><td style="text-align: left"><code>str</code></td><td style="text-align: left">Implements <code>__str__</code> using the <code>Display</code> implementation of the underlying Rust datatype or by passing an optional format string <code>str="&lt;format string&gt;"</code>. <em>Note: The optional format string is only allowed for structs.  <code>name</code> and <code>rename_all</code> are incompatible with the optional format string.  Additional details can be found in the discussion on this <a href="https://github.com/PyO3/pyo3/pull/4233">PR</a>.</em></td></tr>
<tr><td style="text-align: left"><code>subclass</code></td><td style="text-align: left">Allows other Python classes and <code>#[pyclass]</code> to inherit from this class. Enums cannot be subclassed.</td></tr>
<tr><td style="text-align: left"><code>unsendable</code></td><td style="text-align: left">Required if your struct is not <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>. Rather than using <code>unsendable</code>, consider implementing your struct in a thread-safe way by e.g. substituting <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> with <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>. By using <code>unsendable</code>, your class will panic when accessed by another thread. Also note the Python's GC is multi-threaded and while unsendable classes will not be traversed on foreign threads to avoid UB, this can lead to memory leaks.</td></tr>
<tr><td style="text-align: left"><code>weakref</code></td><td style="text-align: left">Allows this class to be <a href="https://docs.python.org/3/library/weakref.html">weakly referenceable</a>.</td></tr>
</tbody></table>
</div>
<p>All of these parameters can either be passed directly on the <code>#[pyclass(...)]</code> annotation, or as one or
more accompanying <code>#[pyo3(...)]</code> annotations, e.g.:</p>
<pre><code class="language-rust ignore">// Argument supplied directly to the `#[pyclass]` annotation.
#[pyclass(name = "SomeName", subclass)]
struct MyClass {}

// Argument supplied as a separate annotation.
#[pyclass]
#[pyo3(name = "SomeName", subclass)]
struct MyClass {}</code></pre>
<p>These parameters are covered in various sections of this guide.</p>
<h3 id="return-type"><a class="header" href="#return-type">Return type</a></h3>
<p>Generally, <code>#[new]</code> methods have to return <code>T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code> or
<code>PyResult&lt;T&gt; where T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code>.</p>
<p>For constructors that may fail, you should wrap the return type in a PyResult as well.
Consult the table below to determine which type your constructor should return:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th><strong>Cannot fail</strong></th><th><strong>May fail</strong></th></tr></thead><tbody>
<tr><td><strong>No inheritance</strong></td><td><code>T</code></td><td><code>PyResult&lt;T&gt;</code></td></tr>
<tr><td><strong>Inheritance(T Inherits U)</strong></td><td><code>(T, U)</code></td><td><code>PyResult&lt;(T, U)&gt;</code></td></tr>
<tr><td><strong>Inheritance(General Case)</strong></td><td><a href="https://docs.rs/pyo3/0.27.1/pyo3/pyclass_init/struct.PyClassInitializer.html"><code>PyClassInitializer&lt;T&gt;</code></a></td><td><code>PyResult&lt;PyClassInitializer&lt;T&gt;&gt;</code></td></tr>
</tbody></table>
</div>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>By default, <code>object</code>, i.e. <code>PyAny</code> is used as the base class. To override this default,
use the <code>extends</code> parameter for <code>pyclass</code> with the full path to the base class.
Currently, only classes defined in Rust and builtins provided by PyO3 can be inherited
from; inheriting from other classes defined in Python is not yet supported
(<a href="https://github.com/PyO3/pyo3/issues/991">#991</a>).</p>
<p>For convenience, <code>(T, U)</code> implements <code>Into&lt;PyClassInitializer&lt;T&gt;&gt;</code> where <code>U</code> is the
base class of <code>T</code>.
But for a more deeply nested inheritance, you have to return <code>PyClassInitializer&lt;T&gt;</code>
explicitly.</p>
<p>To get a parent class from a child, use <a href="https://docs.rs/pyo3/0.27.1/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> instead of <code>&amp;self</code> for methods,
or <a href="https://docs.rs/pyo3/0.27.1/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a> instead of <code>&amp;mut self</code>.
Then you can access a parent class by <code>self_.as_super()</code> as <code>&amp;PyRef&lt;Self::BaseClass&gt;</code>,
or by <code>self_.into_super()</code> as <code>PyRef&lt;Self::BaseClass&gt;</code> (and similar for the <code>PyRefMut</code>
case). For convenience, <code>self_.as_ref()</code> can also be used to get <code>&amp;Self::BaseClass</code>
directly; however, this approach does not let you access base classes higher in the
inheritance hierarchy, for which you would need to chain multiple <code>as_super</code> or
<code>into_super</code> calls.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass(subclass)]
struct BaseClass {
    val1: usize,
}

#[pymethods]
impl BaseClass {
    #[new]
    fn new() -&gt; Self {
        BaseClass { val1: 10 }
    }

    pub fn method1(&amp;self) -&gt; PyResult&lt;usize&gt; {
        Ok(self.val1)
    }
}

#[pyclass(extends=BaseClass, subclass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; (Self, BaseClass) {
        (SubClass { val2: 15 }, BaseClass::new())
    }

    fn method2(self_: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let super_ = self_.as_super(); // Get &amp;PyRef&lt;BaseClass&gt;
        super_.method1().map(|x| x * self_.val2)
    }
}

#[pyclass(extends=SubClass)]
struct SubSubClass {
    val3: usize,
}

#[pymethods]
impl SubSubClass {
    #[new]
    fn new() -&gt; PyClassInitializer&lt;Self&gt; {
        PyClassInitializer::from(SubClass::new()).add_subclass(SubSubClass { val3: 20 })
    }

    fn method3(self_: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let base = self_.as_super().as_super(); // Get &amp;PyRef&lt;'_, BaseClass&gt;
        base.method1().map(|x| x * self_.val3)
    }

    fn method4(self_: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let v = self_.val3;
        let super_ = self_.into_super(); // Get PyRef&lt;'_, SubClass&gt;
        SubClass::method2(super_).map(|x| x * v)
    }

      fn get_values(self_: PyRef&lt;'_, Self&gt;) -&gt; (usize, usize, usize) {
          let val1 = self_.as_super().as_super().val1;
          let val2 = self_.as_super().val2;
          (val1, val2, self_.val3)
      }

    fn double_values(mut self_: PyRefMut&lt;'_, Self&gt;) {
        self_.as_super().as_super().val1 *= 2;
        self_.as_super().val2 *= 2;
        self_.val3 *= 2;
    }

    #[staticmethod]
    fn factory_method(py: Python&lt;'_&gt;, val: usize) -&gt; PyResult&lt;Py&lt;PyAny&gt;&gt; {
        let base = PyClassInitializer::from(BaseClass::new());
        let sub = base.add_subclass(SubClass { val2: val });
        if val % 2 == 0 {
            Ok(Py::new(py, sub)?.into_any())
        } else {
            let sub_sub = sub.add_subclass(SubSubClass { val3: val });
            Ok(Py::new(py, sub_sub)?.into_any())
        }
    }
}
<span class="boring">Python::attach(|py| {
</span><span class="boring">    let subsub = pyo3::Py::new(py, SubSubClass::new()).unwrap();
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.method1() == 10");
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.method2() == 150");
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.method3() == 200");
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.method4() == 3000");
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.get_values() == (10, 15, 20)");
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.double_values() == None");
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.get_values() == (20, 30, 40)");
</span><span class="boring">    let subsub = SubSubClass::factory_method(py, 2).unwrap();
</span><span class="boring">    let subsubsub = SubSubClass::factory_method(py, 3).unwrap();
</span><span class="boring">    let cls = py.get_type::&lt;SubSubClass&gt;();
</span><span class="boring">    pyo3::py_run!(py, subsub cls, "assert not isinstance(subsub, cls)");
</span><span class="boring">    pyo3::py_run!(py, subsubsub cls, "assert isinstance(subsubsub, cls)");
</span><span class="boring">});</span></code></pre>
<p>You can inherit native types such as <code>PyDict</code>, if they implement
<a href="https://docs.rs/pyo3/0.27.1/pyo3/type_object/trait.PySizedLayout.html"><code>PySizedLayout</code></a>.
This is not supported when building for the Python limited API (aka the <code>abi3</code> feature of PyO3).</p>
<p>To convert between the Rust type and its native base class, you can take
<code>slf</code> as a Python object. To access the Rust fields use <code>slf.borrow()</code> or
<code>slf.borrow_mut()</code>, and to access the base class use <code>slf.cast::&lt;BaseClass&gt;()</code>.</p>
<pre><code class="language-rust"><span class="boring">#[cfg(not(Py_LIMITED_API))] {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyDict;
use std::collections::HashMap;

#[pyclass(extends=PyDict)]
#[derive(Default)]
struct DictWithCounter {
    counter: HashMap&lt;String, usize&gt;,
}

#[pymethods]
impl DictWithCounter {
    #[new]
    fn new() -&gt; Self {
        Self::default()
    }

    fn set(slf: &amp;Bound&lt;'_, Self&gt;, key: String, value: Bound&lt;'_, PyAny&gt;) -&gt; PyResult&lt;()&gt; {
        slf.borrow_mut().counter.entry(key.clone()).or_insert(0);
        let dict = slf.cast::&lt;PyDict&gt;()?;
        dict.set_item(key, value)
    }
}
<span class="boring">Python::attach(|py| {
</span><span class="boring">    let cnt = pyo3::Py::new(py, DictWithCounter::new()).unwrap();
</span><span class="boring">    pyo3::py_run!(py, cnt, "cnt.set('abc', 10); assert cnt['abc'] == 10")
</span><span class="boring">});
</span><span class="boring">}</span></code></pre>
<p>If <code>SubClass</code> does not provide a base class initialization, the compilation fails.</p>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct BaseClass {
    val1: usize,
}

#[pyclass(extends=BaseClass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; Self {
        SubClass { val2: 15 }
    }
}</code></pre>
<p>The <code>__new__</code> constructor of a native base class is called implicitly when
creating a new instance from Python.  Be sure to accept arguments in the
<code>#[new]</code> method that you want the base class to get, even if they are not used
in that <code>fn</code>:</p>
<pre><code class="language-rust"><span class="boring">#[allow(dead_code)]
</span><span class="boring">#[cfg(not(Py_LIMITED_API))] {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyDict;

#[pyclass(extends=PyDict)]
struct MyDict {
    private: i32,
}

#[pymethods]
impl MyDict {
    #[new]
    #[pyo3(signature = (*args, **kwargs))]
    fn new(args: &amp;Bound&lt;'_, PyAny&gt;, kwargs: Option&lt;&amp;Bound&lt;'_, PyAny&gt;&gt;) -&gt; Self {
        Self { private: 0 }
    }

    // some custom methods that use `private` here...
}
<span class="boring">Python::attach(|py| {
</span><span class="boring">    let cls = py.get_type::&lt;MyDict&gt;();
</span><span class="boring">    pyo3::py_run!(py, cls, "cls(a=1, b=2)")
</span><span class="boring">});
</span><span class="boring">}</span></code></pre>
<p>Here, the <code>args</code> and <code>kwargs</code> allow creating instances of the subclass passing
initial items, such as <code>MyDict(item_sequence)</code> or <code>MyDict(a=1, b=2)</code>.</p>
<h2 id="object-properties"><a class="header" href="#object-properties">Object properties</a></h2>
<p>PyO3 supports two ways to add properties to your <code>#[pyclass]</code>:</p>
<ul>
<li>For simple struct fields with no side effects, a <code>#[pyo3(get, set)]</code> attribute can be added directly to the field definition in the <code>#[pyclass]</code>.</li>
<li>For properties which require computation you can define <code>#[getter]</code> and <code>#[setter]</code> functions in the <a href="#instance-methods"><code>#[pymethods]</code></a> block.</li>
</ul>
<p>We'll cover each of these in the following sections.</p>
<h3 id="object-properties-using-pyo3get-set"><a class="header" href="#object-properties-using-pyo3get-set">Object properties using <code>#[pyo3(get, set)]</code></a></h3>
<p>For simple cases where a member variable is just read and written with no side effects, you can declare getters and setters in your <code>#[pyclass]</code> field definition using the <code>pyo3</code> attribute, like in the example below:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[allow(dead_code)]
</span>#[pyclass]
struct MyClass {
    #[pyo3(get, set)]
    num: i32,
}</code></pre>
<p>The above would make the <code>num</code> field available for reading and writing as a <code>self.num</code> Python property. To expose the property with a different name to the field, specify this alongside the rest of the options, e.g. <code>#[pyo3(get, set, name = "custom_name")]</code>.</p>
<p>Properties can be readonly or writeonly by using just <code>#[pyo3(get)]</code> or <code>#[pyo3(set)]</code> respectively.</p>
<p>To use these annotations, your field type must implement some conversion traits:</p>
<ul>
<li>For <code>get</code> the field type <code>T</code> must implement either <code>&amp;T: IntoPyObject</code> or <code>T: IntoPyObject + Clone</code>.</li>
<li>For <code>set</code> the field type must implement <code>FromPyObject</code>.</li>
</ul>
<p>For example, implementations of those traits are provided for the <code>Cell</code> type, if the inner type also implements the trait. This means you can use <code>#[pyo3(get, set)]</code> on fields wrapped in a <code>Cell</code>.</p>
<h3 id="object-properties-using-getter-and-setter"><a class="header" href="#object-properties-using-getter-and-setter">Object properties using <code>#[getter]</code> and <code>#[setter]</code></a></h3>
<p>For cases which don't satisfy the <code>#[pyo3(get, set)]</code> trait requirements, or need side effects, descriptor methods can be defined in a <code>#[pymethods]</code> <code>impl</code> block.</p>
<p>This is done using the <code>#[getter]</code> and <code>#[setter]</code> attributes, like in the example below:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}

#[pymethods]
impl MyClass {
    #[getter]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }
}</code></pre>
<p>A getter or setter's function name is used as the property name by default. There are several
ways how to override the name.</p>
<p>If a function name starts with <code>get_</code> or <code>set_</code> for getter or setter respectively,
the descriptor name becomes the function name with this prefix removed. This is also useful in case of
Rust keywords like <code>type</code>
(<a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/raw-identifiers.html">raw identifiers</a>
can be used since Rust 2018).</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter]
    fn get_num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}</code></pre>
<p>In this case, a property <code>num</code> is defined and available from Python code as <code>self.num</code>.</p>
<p>Both the <code>#[getter]</code> and <code>#[setter]</code> attributes accept one parameter.
If this parameter is specified, it is used as the property name, i.e.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">   num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter(number)]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter(number)]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}</code></pre>
<p>In this case, the property <code>number</code> is defined and available from Python code as <code>self.number</code>.</p>
<p>Attributes defined by <code>#[setter]</code> or <code>#[pyo3(set)]</code> will always raise <code>AttributeError</code> on <code>del</code>
operations. Support for defining custom <code>del</code> behavior is tracked in
<a href="https://github.com/PyO3/pyo3/issues/1778">#1778</a>.</p>
<h2 id="instance-methods"><a class="header" href="#instance-methods">Instance methods</a></h2>
<p>To define a Python compatible method, an <code>impl</code> block for your struct has to be annotated with the
<code>#[pymethods]</code> attribute. PyO3 generates Python compatible wrappers for all functions in this
block with some variations, like descriptors, class method static methods, etc.</p>
<p>Since Rust allows any number of <code>impl</code> blocks, you can easily split methods
between those accessible to Python (and Rust) and those accessible only to Rust. However to have multiple
<code>#[pymethods]</code>-annotated <code>impl</code> blocks for the same struct you must enable the <a href="features.html#multiple-pymethods"><code>multiple-pymethods</code></a> feature of PyO3.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method1(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }

    fn set_method(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}</code></pre>
<p>Both <code>&amp;self</code> and <code>&amp;mut self</code> can be used, due to the use of <a href="#bound-and-interior-mutability">runtime borrow checking</a>.</p>
<p>The return type must be <code>PyResult&lt;T&gt;</code> or <code>T</code> for some <code>T</code> that implements <code>IntoPyObject</code>;
the latter is allowed if the method cannot raise Python exceptions.</p>
<p>A <code>Python</code> parameter can be specified as part of method signature, in this case the <code>py</code> argument
gets injected by the method wrapper, e.g.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method2(&amp;self, py: Python&lt;'_&gt;) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}</code></pre>
<p>From the Python perspective, the <code>method2</code> in this example does not accept any arguments.</p>
<h2 id="class-methods"><a class="header" href="#class-methods">Class methods</a></h2>
<p>To create a class method for a custom class, the method needs to be annotated
with the <code>#[classmethod]</code> attribute.
This is the equivalent of the Python decorator <code>@classmethod</code>.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyType;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    #[allow(dead_code)]
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[classmethod]
    fn cls_method(cls: &amp;Bound&lt;'_, PyType&gt;) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}</code></pre>
<p>Declares a class method callable from Python.</p>
<ul>
<li>The first parameter is the type object of the class on which the method is called.
This may be the type object of a derived class.</li>
<li>The first parameter implicitly has type <code>&amp;Bound&lt;'_, PyType&gt;</code>.</li>
<li>For details on <code>parameter-list</code>, see the documentation of <code>Method arguments</code> section.</li>
<li>The return type must be <code>PyResult&lt;T&gt;</code> or <code>T</code> for some <code>T</code> that implements <code>IntoPyObject</code>.</li>
</ul>
<h3 id="constructors-which-accept-a-class-argument"><a class="header" href="#constructors-which-accept-a-class-argument">Constructors which accept a class argument</a></h3>
<p>To create a constructor which takes a positional class argument, you can combine the <code>#[classmethod]</code> and <code>#[new]</code> modifiers:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyType;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct BaseClass(Py&lt;PyAny&gt;);
</span><span class="boring">
</span>#[pymethods]
impl BaseClass {
    #[new]
    #[classmethod]
    fn py_new(cls: &amp;Bound&lt;'_, PyType&gt;) -&gt; PyResult&lt;Self&gt; {
        // Get an abstract attribute (presumably) declared on a subclass of this class.
        let subclass_attr: Bound&lt;'_, PyAny&gt; = cls.getattr("a_class_attr")?;
        Ok(Self(subclass_attr.unbind()))
    }
}</code></pre>
<h2 id="static-methods"><a class="header" href="#static-methods">Static methods</a></h2>
<p>To create a static method for a custom class, the method needs to be annotated with the
<code>#[staticmethod]</code> attribute. The return type must be <code>T</code> or <code>PyResult&lt;T&gt;</code> for some <code>T</code> that implements
<code>IntoPyObject</code>.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    #[allow(dead_code)]
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[staticmethod]
    fn static_method(param1: i32, param2: &amp;str) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}</code></pre>
<h2 id="class-attributes"><a class="header" href="#class-attributes">Class attributes</a></h2>
<p>To create a class attribute (also called <a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables">class variable</a>), a method without
any arguments can be annotated with the <code>#[classattr]</code> attribute.</p>
<pre><code class="language-rust no_run"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>#[pymethods]
impl MyClass {
    #[classattr]
    fn my_attribute() -&gt; String {
        "hello".to_string()
    }
}

Python::attach(|py| {
    let my_class = py.get_type::&lt;MyClass&gt;();
    pyo3::py_run!(py, my_class, "assert my_class.my_attribute == 'hello'")
});</code></pre>
<blockquote>
<p>Note: if the method has a <code>Result</code> return type and returns an <code>Err</code>, PyO3 will panic during
class creation.</p>
</blockquote>
<blockquote>
<p>Note: <code>#[classattr]</code> does not work with <a href="./function.html#warn"><code>#[pyo3(warn(...))]</code></a> attribute.</p>
</blockquote>
<p>If the class attribute is defined with <code>const</code> code only, one can also annotate associated
constants:</p>
<pre><code class="language-rust no_run"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>#[pymethods]
impl MyClass {
    #[classattr]
    const MY_CONST_ATTRIBUTE: &amp;'static str = "foobar";
}</code></pre>
<h2 id="classes-as-function-arguments"><a class="header" href="#classes-as-function-arguments">Classes as function arguments</a></h2>
<p>Class objects can be used as arguments to <code>#[pyfunction]</code>s and <code>#[pymethods]</code> in the same way as the self parameters of instance methods, i.e. they can be passed as:</p>
<ul>
<li><code>Py&lt;T&gt;</code> or <code>Bound&lt;'py, T&gt;</code> smart pointers to the class Python object,</li>
<li><code>&amp;T</code> or <code>&amp;mut T</code> references to the Rust data contained in the Python object, or</li>
<li><code>PyRef&lt;T&gt;</code> and <code>PyRefMut&lt;T&gt;</code> reference wrappers.</li>
</ul>
<p>Examples of each of these below:</p>
<pre><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    my_field: i32,
}

// Take a reference to Rust data when the Python object is irrelevant.
#[pyfunction]
fn increment_field(my_class: &amp;mut MyClass) {
    my_class.my_field += 1;
}

// Take a reference wrapper when borrowing should be automatic,
// but access to the Python object is still needed
#[pyfunction]
fn print_field_and_return_me(my_class: PyRef&lt;'_, MyClass&gt;) -&gt; PyRef&lt;'_, MyClass&gt; {
    println!("{}", my_class.my_field);
    my_class
}

// Take (a reference to) a Python object smart pointer when borrowing needs to be managed manually.
#[pyfunction]
fn increment_then_print_field(my_class: &amp;Bound&lt;'_, MyClass&gt;) {
    my_class.borrow_mut().my_field += 1;

    println!("{}", my_class.borrow().my_field);
}

// When the Python object smart pointer needs to be stored elsewhere prefer `Py&lt;T&gt;` over `Bound&lt;'py, T&gt;`
// to avoid the lifetime restrictions.
#[pyfunction]
fn print_refcnt(my_class: Py&lt;MyClass&gt;, py: Python&lt;'_&gt;) {
    println!("{}", my_class.get_refcnt(py));
}</code></pre>
<p>Classes can also be passed by value if they can be cloned, i.e. they automatically implement <code>FromPyObject</code> if they implement <code>Clone</code>, e.g. via <code>#[derive(Clone)]</code>:</p>
<pre><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
#[derive(Clone)]
struct MyClass {
    my_field: Box&lt;i32&gt;,
}

#[pyfunction]
fn disassemble_clone(my_class: MyClass) {
    let MyClass { mut my_field } = my_class;
    *my_field += 1;
}</code></pre>
<p>Note that <code>#[derive(FromPyObject)]</code> on a class is usually not useful as it tries to construct a new Rust value by filling in the fields by looking up attributes of any given Python value.</p>
<h2 id="method-arguments"><a class="header" href="#method-arguments">Method arguments</a></h2>
<p>Similar to <code>#[pyfunction]</code>, the <code>#[pyo3(signature = (...))]</code> attribute can be used to specify the way that <code>#[pymethods]</code> accept arguments. Consult the documentation for <a href="./function/signature.html"><code>function signatures</code></a> to see the parameters this attribute accepts.</p>
<p>The following example defines a class <code>MyClass</code> with a method <code>method</code>. This method has a signature that sets default values for <code>num</code> and <code>name</code>, and indicates that <code>py_args</code> should collect all extra positional arguments and <code>py_kwargs</code> all extra keyword arguments:</p>
<pre><code class="language-rust no_run"><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::{PyDict, PyTuple};
<span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[new]
    #[pyo3(signature = (num=-1))]
    fn new(num: i32) -&gt; Self {
        MyClass { num }
    }

    #[pyo3(signature = (num=10, *py_args, name="Hello", **py_kwargs))]
    fn method(
        &amp;mut self,
        num: i32,
        py_args: &amp;Bound&lt;'_, PyTuple&gt;,
        name: &amp;str,
        py_kwargs: Option&lt;&amp;Bound&lt;'_, PyDict&gt;&gt;,
    ) -&gt; String {
        let num_before = self.num;
        self.num = num;
        format!(
            "num={} (was previously={}), py_args={:?}, name={}, py_kwargs={:?} ",
            num, num_before, py_args, name, py_kwargs,
        )
    }
}</code></pre>
<p>In Python, this might be used like:</p>
<pre><code class="language-python">&gt;&gt;&gt; import mymodule
&gt;&gt;&gt; mc = mymodule.MyClass()
&gt;&gt;&gt; print(mc.method(44, False, "World", 666, x=44, y=55))
py_args=('World', 666), py_kwargs=Some({'x': 44, 'y': 55}), name=Hello, num=44, num_before=-1
&gt;&gt;&gt; print(mc.method(num=-1, name="World"))
py_args=(), py_kwargs=None, name=World, num=-1, num_before=44
</code></pre>
<p>The <a href="./function/signature.html#overriding-the-generated-signature"><code>#[pyo3(text_signature = "...")</code></a> option for <code>#[pyfunction]</code> also works for <code>#[pymethods]</code>.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;
use pyo3::types::PyType;

#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
    #[new]
    #[pyo3(text_signature = "(c, d)")]
    fn new(c: i32, d: &amp;str) -&gt; Self {
        Self {}
    }
    // the self argument should be written $self
    #[pyo3(text_signature = "($self, e, f)")]
    fn my_method(&amp;self, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    // similarly for classmethod arguments, use $cls
    #[classmethod]
    #[pyo3(text_signature = "($cls, e, f)")]
    fn my_class_method(cls: &amp;Bound&lt;'_, PyType&gt;, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    #[staticmethod]
    #[pyo3(text_signature = "(e, f)")]
    fn my_static_method(e: i32, f: i32) -&gt; i32 {
        e + f
    }
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::attach(|py| {
</span><span class="boring">        let inspect = PyModule::import(py, "inspect")?.getattr("signature")?;
</span><span class="boring">        let module = PyModule::new(py, "my_module")?;
</span><span class="boring">        module.add_class::&lt;MyClass&gt;()?;
</span><span class="boring">        let class = module.getattr("MyClass")?;
</span><span class="boring">
</span><span class="boring">        if cfg!(not(Py_LIMITED_API)) || py.version_info() &gt;= (3, 10)  {
</span><span class="boring">            let doc: String = class.getattr("__doc__")?.extract()?;
</span><span class="boring">            assert_eq!(doc, "");
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((&amp;class,))?
</span><span class="boring">                .call_method0("__str__")?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, "(c, d)");
</span><span class="boring">        } else {
</span><span class="boring">            let doc: String = class.getattr("__doc__")?.extract()?;
</span><span class="boring">            assert_eq!(doc, "");
</span><span class="boring">
</span><span class="boring">            inspect.call1((&amp;class,)).expect_err("`text_signature` on classes is not compatible with compilation in `abi3` mode until Python 3.10 or greater");
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let method = class.getattr("my_method")?;
</span><span class="boring">
</span><span class="boring">            assert!(method.getattr("__doc__")?.is_none());
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((method,))?
</span><span class="boring">                .call_method0("__str__")?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, "(self, /, e, f)");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let method = class.getattr("my_class_method")?;
</span><span class="boring">
</span><span class="boring">            assert!(method.getattr("__doc__")?.is_none());
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((method,))?
</span><span class="boring">                .call_method0("__str__")?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, "(e, f)");  // inspect.signature skips the $cls arg
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let method = class.getattr("my_static_method")?;
</span><span class="boring">
</span><span class="boring">            assert!(method.getattr("__doc__")?.is_none());
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((method,))?
</span><span class="boring">                .call_method0("__str__")?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, "(e, f)");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>Note that <code>text_signature</code> on <code>#[new]</code> is not compatible with compilation in
<code>abi3</code> mode until Python 3.10 or greater.</p>
<h3 id="method-receivers-and-lifetime-elision"><a class="header" href="#method-receivers-and-lifetime-elision">Method receivers and lifetime elision</a></h3>
<p>PyO3 supports writing instance methods using the normal method receivers for shared <code>&amp;self</code> and unique <code>&amp;mut self</code> references. This interacts with <a href="https://doc.rust-lang.org/reference/lifetime-elision.html">lifetime elision</a> insofar as the lifetime of a such a receiver is assigned to all elided output lifetime parameters.</p>
<p>This is a good default for general Rust code where return values are more likely to borrow from the receiver than from the other arguments, if they contain any lifetimes at all. However, when returning bound references <code>Bound&lt;'py, T&gt;</code> in PyO3-based code, the Python lifetime <code>'py</code> should usually be derived from a <code>py: Python&lt;'py&gt;</code> token passed as an argument instead of the receiver.</p>
<p>Specifically, signatures like</p>
<pre><code class="language-rust ignore">fn frobnicate(&amp;self, py: Python) -&gt; Bound&lt;Foo&gt;;</code></pre>
<p>will not work as they are inferred as</p>
<pre><code class="language-rust ignore">fn frobnicate&lt;'a, 'py&gt;(&amp;'a self, py: Python&lt;'py&gt;) -&gt; Bound&lt;'a, Foo&gt;;</code></pre>
<p>instead of the intended</p>
<pre><code class="language-rust ignore">fn frobnicate&lt;'a, 'py&gt;(&amp;'a self, py: Python&lt;'py&gt;) -&gt; Bound&lt;'py, Foo&gt;;</code></pre>
<p>and should usually be written as</p>
<pre><code class="language-rust ignore">fn frobnicate&lt;'py&gt;(&amp;self, py: Python&lt;'py&gt;) -&gt; Bound&lt;'py, Foo&gt;;</code></pre>
<p>The same problem does not exist for <code>#[pyfunction]</code>s as the special case for receiver lifetimes does not apply and indeed a signature like</p>
<pre><code class="language-rust ignore">fn frobnicate(bar: &amp;Bar, py: Python) -&gt; Bound&lt;Foo&gt;;</code></pre>
<p>will yield compiler error <a href="https://doc.rust-lang.org/error_codes/E0106.html">E0106 "missing lifetime specifier"</a>.</p>
<h2 id="pyclass-enums"><a class="header" href="#pyclass-enums"><code>#[pyclass]</code> enums</a></h2>
<p>Enum support in PyO3 comes in two flavors, depending on what kind of variants the enum has: simple and complex.</p>
<h3 id="simple-enums"><a class="header" href="#simple-enums">Simple enums</a></h3>
<p>A simple enum (a.k.a. C-like enum) has only unit variants.</p>
<p>PyO3 adds a class attribute for each variant, so you can access them in Python without defining <code>#[new]</code>. PyO3 also provides default implementations of <code>__richcmp__</code> and <code>__int__</code>, so they can be compared using <code>==</code>:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(eq, eq_int)]
#[derive(PartialEq)]
enum MyEnum {
    Variant,
    OtherVariant,
}

Python::attach(|py| {
    let x = Py::new(py, MyEnum::Variant).unwrap();
    let y = Py::new(py, MyEnum::OtherVariant).unwrap();
    let cls = py.get_type::&lt;MyEnum&gt;();
    pyo3::py_run!(py, x y cls, r#"
        assert x == cls.Variant
        assert y == cls.OtherVariant
        assert x != y
    "#)
})</code></pre>
<p>You can also convert your simple enums into <code>int</code>:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(eq, eq_int)]
#[derive(PartialEq)]
enum MyEnum {
    Variant,
    OtherVariant = 10,
}

Python::attach(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    let x = MyEnum::Variant as i32; // The exact value is assigned by the compiler.
    pyo3::py_run!(py, cls x, r#"
        assert int(cls.Variant) == x
        assert int(cls.OtherVariant) == 10
    "#)
})</code></pre>
<p>PyO3 also provides <code>__repr__</code> for enums:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(eq, eq_int)]
#[derive(PartialEq)]
enum MyEnum{
    Variant,
    OtherVariant,
}

Python::attach(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    let x = Py::new(py, MyEnum::Variant).unwrap();
    pyo3::py_run!(py, cls x, r#"
        assert repr(x) == 'MyEnum.Variant'
        assert repr(cls.OtherVariant) == 'MyEnum.OtherVariant'
    "#)
})</code></pre>
<p>All methods defined by PyO3 can be overridden. For example here's how you override <code>__repr__</code>:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(eq, eq_int)]
#[derive(PartialEq)]
enum MyEnum {
    Answer = 42,
}

#[pymethods]
impl MyEnum {
    fn __repr__(&amp;self) -&gt; &amp;'static str {
        "42"
    }
}

Python::attach(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    pyo3::py_run!(py, cls, "assert repr(cls.Answer) == '42'")
})</code></pre>
<p>Enums and their variants can also be renamed using <code>#[pyo3(name)]</code>.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(eq, eq_int, name = "RenamedEnum")]
#[derive(PartialEq)]
enum MyEnum {
    #[pyo3(name = "UPPERCASE")]
    Variant,
}

Python::attach(|py| {
    let x = Py::new(py, MyEnum::Variant).unwrap();
    let cls = py.get_type::&lt;MyEnum&gt;();
    pyo3::py_run!(py, x cls, r#"
        assert repr(x) == 'RenamedEnum.UPPERCASE'
        assert x == cls.UPPERCASE
    "#)
})</code></pre>
<p>Ordering of enum variants is optionally added using <code>#[pyo3(ord)]</code>.
<em>Note: Implementation of the <code>PartialOrd</code> trait is required when passing the <code>ord</code> argument.  If not implemented, a compile time error is raised.</em></p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(eq, ord)]
#[derive(PartialEq, PartialOrd)]
enum MyEnum{
    A,
    B,
    C,
}

Python::attach(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    let a = Py::new(py, MyEnum::A).unwrap();
    let b = Py::new(py, MyEnum::B).unwrap();
    let c = Py::new(py, MyEnum::C).unwrap();
    pyo3::py_run!(py, cls a b c, r#"
        assert (a &lt; b) == True
        assert (c &lt;= b) == False
        assert (c &gt; a) == True
    "#)
})</code></pre>
<p>You may not use enums as a base class or let enums inherit from other classes.</p>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(subclass)]
enum BadBase {
    Var1,
}</code></pre>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass(subclass)]
struct Base;

#[pyclass(extends=Base)]
enum BadSubclass {
    Var1,
}</code></pre>
<p><code>#[pyclass]</code> enums are currently not interoperable with <code>IntEnum</code> in Python.</p>
<h3 id="complex-enums"><a class="header" href="#complex-enums">Complex enums</a></h3>
<p>An enum is complex if it has any non-unit (struct or tuple) variants.</p>
<p>PyO3 supports only struct and tuple variants in a complex enum. Unit variants aren't supported at present (the recommendation is to use an empty tuple enum instead).</p>
<p>PyO3 adds a class attribute for each variant, which may be used to construct values and in match patterns. PyO3 also provides getter methods for all fields of each variant.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum Shape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
    RegularPolygon(u32, f64),
    Nothing { },
}

<span class="boring">#[cfg(Py_3_10)]
</span>Python::attach(|py| {
    let circle = Shape::Circle { radius: 10.0 }.into_pyobject(py)?;
    let square = Shape::RegularPolygon(4, 10.0).into_pyobject(py)?;
    let cls = py.get_type::&lt;Shape&gt;();
    pyo3::py_run!(py, circle square cls, r#"
        assert isinstance(circle, cls)
        assert isinstance(circle, cls.Circle)
        assert circle.radius == 10.0

        assert isinstance(square, cls)
        assert isinstance(square, cls.RegularPolygon)
        assert square[0] == 4 # Gets _0 field
        assert square[1] == 10.0 # Gets _1 field

        def count_vertices(cls, shape):
            match shape:
                case cls.Circle():
                    return 0
                case cls.Rectangle():
                    return 4
                case cls.RegularPolygon(n):
                    return n
                case cls.Nothing():
                    return 0

        assert count_vertices(cls, circle) == 0
        assert count_vertices(cls, square) == 4
    "#);
<span class="boring">  Ok::&lt;_, PyErr&gt;(())
</span>})
<span class="boring">.unwrap();</span></code></pre>
<p>WARNING: <code>Py::new</code> and <code>.into_pyobject</code> are currently inconsistent. Note how the constructed value is <em>not</em> an instance of the specific variant. For this reason, constructing values is only recommended using <code>.into_pyobject</code>.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum MyEnum {
    Variant { i: i32 },
}

Python::attach(|py| {
    let x = Py::new(py, MyEnum::Variant { i: 42 }).unwrap();
    let cls = py.get_type::&lt;MyEnum&gt;();
    pyo3::py_run!(py, x cls, r#"
        assert isinstance(x, cls)
        assert not isinstance(x, cls.Variant)
    "#)
})</code></pre>
<p>The constructor of each generated class can be customized using the <code>#[pyo3(constructor = (...))]</code> attribute. This uses the same syntax as the <a href="function/signature.html"><code>#[pyo3(signature = (...))]</code></a>
attribute on function and methods and supports the same options. To apply this attribute simply place it on top of a variant in a <code>#[pyclass]</code> complex enum as shown below:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum Shape {
    #[pyo3(constructor = (radius=1.0))]
    Circle { radius: f64 },
    #[pyo3(constructor = (*, width, height))]
    Rectangle { width: f64, height: f64 },
    #[pyo3(constructor = (side_count, radius=1.0))]
    RegularPolygon { side_count: u32, radius: f64 },
    Nothing { },
}

<span class="boring">#[cfg(Py_3_10)]
</span>Python::attach(|py| {
    let cls = py.get_type::&lt;Shape&gt;();
    pyo3::py_run!(py, cls, r#"
        circle = cls.Circle()
        assert isinstance(circle, cls)
        assert isinstance(circle, cls.Circle)
        assert circle.radius == 1.0

        square = cls.Rectangle(width = 1, height = 1)
        assert isinstance(square, cls)
        assert isinstance(square, cls.Rectangle)
        assert square.width == 1
        assert square.height == 1

        hexagon = cls.RegularPolygon(6)
        assert isinstance(hexagon, cls)
        assert isinstance(hexagon, cls.RegularPolygon)
        assert hexagon.side_count == 6
        assert hexagon.radius == 1
    "#)
})</code></pre>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation details</a></h2>
<p>The <code>#[pyclass]</code> macros rely on a lot of conditional code generation: each <code>#[pyclass]</code> can optionally have a <code>#[pymethods]</code> block.</p>
<p>To support this flexibility the <code>#[pyclass]</code> macro expands to a blob of boilerplate code which sets up the structure for <a href="https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/README.md">"dtolnay specialization"</a>. This implementation pattern enables the Rust compiler to use <code>#[pymethods]</code> implementations when they are present, and fall back to default (empty) definitions when they are not.</p>
<p>This simple technique works for the case when there is zero or one implementations. To support multiple <code>#[pymethods]</code> for a <code>#[pyclass]</code> (in the <a href="features.html#multiple-pymethods"><code>multiple-pymethods</code></a> feature), a registry mechanism provided by the <a href="https://github.com/dtolnay/inventory"><code>inventory</code></a> crate is used instead. This collects <code>impl</code>s at library load time, but isn't supported on all platforms. See <a href="https://github.com/dtolnay/inventory#how-it-works">inventory: how it works</a> for more details.</p>
<p>The <code>#[pyclass]</code> macro expands to roughly the code seen below. The <code>PyClassImplCollector</code> is the type used internally by PyO3 for dtolnay specialization:</p>
<pre><code class="language-rust"><span class="boring">#[cfg(not(feature = "multiple-pymethods"))] {
</span><span class="boring">use pyo3::prelude::*;
</span>// Note: the implementation differs slightly with the `multiple-pymethods` feature enabled.
<span class="boring">#[allow(dead_code)]
</span>struct MyClass {
<span class="boring">    #[allow(dead_code)]
</span>    num: i32,
}

impl pyo3::types::DerefToPyAny for MyClass {}

unsafe impl pyo3::type_object::PyTypeInfo for MyClass {
    const NAME: &amp;'static str = "MyClass";
    const MODULE: ::std::option::Option&lt;&amp;'static str&gt; = ::std::option::Option::None;

    #[inline]
    fn type_object_raw(py: pyo3::Python&lt;'_&gt;) -&gt; *mut pyo3::ffi::PyTypeObject {
        &lt;Self as pyo3::impl_::pyclass::PyClassImpl&gt;::lazy_type_object()
            .get_or_try_init(py)
            .unwrap_or_else(|e| pyo3::impl_::pyclass::type_object_init_failed(
                py,
                e,
                &lt;Self as pyo3::type_object::PyTypeInfo&gt;::NAME
            ))
            .as_type_ptr()
    }
}

impl pyo3::PyClass for MyClass {
    type Frozen = pyo3::pyclass::boolean_struct::False;
}

impl pyo3::impl_::pyclass::PyClassImpl for MyClass {
    const IS_BASETYPE: bool = false;
    const IS_SUBCLASS: bool = false;
    const IS_MAPPING: bool = false;
    const IS_SEQUENCE: bool = false;
    type BaseType = PyAny;
    type ThreadChecker = pyo3::impl_::pyclass::SendablePyClass&lt;MyClass&gt;;
    type PyClassMutability = &lt;&lt;pyo3::PyAny as pyo3::impl_::pyclass::PyClassBaseType&gt;::PyClassMutability as pyo3::impl_::pycell::PyClassMutability&gt;::MutableChild;
    type Dict = pyo3::impl_::pyclass::PyClassDummySlot;
    type WeakRef = pyo3::impl_::pyclass::PyClassDummySlot;
    type BaseNativeType = pyo3::PyAny;

    const RAW_DOC: &amp;'static std::ffi::CStr = pyo3::ffi::c_str!("...");
    const DOC: &amp;'static std::ffi::CStr = pyo3::ffi::c_str!("...");

    fn items_iter() -&gt; pyo3::impl_::pyclass::PyClassItemsIter {
        use pyo3::impl_::pyclass::*;
        let collector = PyClassImplCollector::&lt;MyClass&gt;::new();
        static INTRINSIC_ITEMS: PyClassItems = PyClassItems { slots: &amp;[], methods: &amp;[] };
        PyClassItemsIter::new(&amp;INTRINSIC_ITEMS, collector.py_methods())
    }

    fn lazy_type_object() -&gt; &amp;'static pyo3::impl_::pyclass::LazyTypeObject&lt;MyClass&gt; {
        use pyo3::impl_::pyclass::LazyTypeObject;
        static TYPE_OBJECT: LazyTypeObject&lt;MyClass&gt; = LazyTypeObject::new();
        &amp;TYPE_OBJECT
    }
}

<span class="boring">Python::attach(|py| {
</span><span class="boring">    let cls = py.get_type::&lt;MyClass&gt;();
</span><span class="boring">    pyo3::py_run!(py, cls, "assert cls.__name__ == 'MyClass'")
</span><span class="boring">});
</span><span class="boring">}</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="function/error-handling.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="class/protocols.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="function/error-handling.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="class/protocols.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/tabs.js"></script>



    </div>
    </body>
</html>
