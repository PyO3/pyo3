<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PyO3 user guide</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="PyO3 user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="module.html"><strong aria-hidden="true">1.</strong> Python Modules</a></li><li class="expanded "><a href="function.html"><strong aria-hidden="true">2.</strong> Python Functions</a></li><li class="expanded "><a href="class.html"><strong aria-hidden="true">3.</strong> Python Classes</a></li><li class="expanded "><a href="conversions.html"><strong aria-hidden="true">4.</strong> Type Conversions</a></li><li class="expanded "><a href="exception.html"><strong aria-hidden="true">5.</strong> Python Exceptions</a></li><li class="expanded "><a href="python_from_rust.html"><strong aria-hidden="true">6.</strong> Calling Python from Rust</a></li><li class="expanded "><a href="types.html"><strong aria-hidden="true">7.</strong> GIL, mutability and object types</a></li><li class="expanded "><a href="parallelism.html"><strong aria-hidden="true">8.</strong> Parallelism</a></li><li class="expanded "><a href="debugging.html"><strong aria-hidden="true">9.</strong> Debugging</a></li><li class="expanded "><a href="advanced.html"><strong aria-hidden="true">10.</strong> Advanced Topics</a></li><li class="expanded "><a href="building_and_distribution.html"><strong aria-hidden="true">11.</strong> Building and Distribution</a></li><li class="expanded "><a href="pypy.html"><strong aria-hidden="true">12.</strong> PyPy support</a></li><li class="expanded "><a href="faq.html"><strong aria-hidden="true">13.</strong> FAQ &amp; Troubleshooting</a></li><li class="expanded "><a href="rust_cpython.html"><strong aria-hidden="true">14.</strong> Appendix A: PyO3 and rust-cpython</a></li><li class="expanded "><a href="migration.html"><strong aria-hidden="true">15.</strong> Appendix B: Migration Guide</a></li><li class="expanded "><a href="trait_bounds.html"><strong aria-hidden="true">16.</strong> Appendix C: Trait bounds</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">PyO3 user guide</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#python-modules" id="python-modules">Python Modules</a></h1>
<p>You can create a module as follows:</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;

// add bindings to the generated Python module
// N.B: &quot;rust2py&quot; must be the name of the `.so` or `.pyd` file.

/// This module is implemented in Rust.
#[pymodule]
fn rust2py(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    // PyO3 aware function. All of our Python interfaces could be declared in a separate module.
    // Note that the `#[pyfn()]` annotation automatically converts the arguments from
    // Python objects to Rust values, and the Rust return value back into a Python object.
    // The `_py` argument represents that we're holding the GIL.
    #[pyfn(m, &quot;sum_as_string&quot;)]
    fn sum_as_string_py(_py: Python, a: i64, b: i64) -&gt; PyResult&lt;String&gt; {
        let out = sum_as_string(a, b);
        Ok(out)
    }

    Ok(())
}

// logic implemented as a normal Rust function
fn sum_as_string(a: i64, b: i64) -&gt; String {
    format!(&quot;{}&quot;, a + b)
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>The <code>#[pymodule]</code> procedural macro attribute takes care of exporting the initialization function of your module to Python. It can take as an argument the name of your module, which must be the name of the <code>.so</code> or <code>.pyd</code> file; the default is the Rust function's name.</p>
<p>If the name of the module (the default being the function name) does not match the name of the <code>.so</code> or <code>.pyd</code> file, you will get an import error in Python with the following message:
<code>ImportError: dynamic module does not define module export function (PyInit_name_of_your_module)</code></p>
<p>To import the module, either copy the shared library as described in <a href="https://github.com/PyO3/pyo3">the README</a> or use a tool, e.g. <code>maturin develop</code> with <a href="https://github.com/PyO3/maturin">maturin</a> or <code>python setup.py develop</code> with <a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a>.</p>
<h2><a class="header" href="#documentation" id="documentation">Documentation</a></h2>
<p>The <a href="https://doc.rust-lang.org/stable/book/first-edition/comments.html">Rust doc comments</a> of the module initialization function will be applied automatically as the Python docstring of your module.</p>
<pre><code class="language-python">import rust2py

print(rust2py.__doc__)
</code></pre>
<p>Which means that the above Python code will print <code>This module is implemented in Rust.</code>.</p>
<h2><a class="header" href="#modules-as-objects" id="modules-as-objects">Modules as objects</a></h2>
<p>In Python, modules are first class objects. This means that you can store them as values or add them to dicts or other modules:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::{wrap_pyfunction, wrap_pymodule};
use pyo3::types::IntoPyDict;

#[pyfunction]
fn subfunction() -&gt; String {
    &quot;Subfunction&quot;.to_string()
}

#[pymodule]
fn submodule(_py: Python, module: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    module.add_wrapped(wrap_pyfunction!(subfunction))?;
    Ok(())
}

#[pymodule]
fn supermodule(_py: Python, module: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    module.add_wrapped(wrap_pymodule!(submodule))?;
    Ok(())
}

fn nested_call() {
    let gil = GILGuard::acquire();
    let py = gil.python();
    let supermodule = wrap_pymodule!(supermodule)(py);
    let ctx = [(&quot;supermodule&quot;, supermodule)].into_py_dict(py);

    py.run(&quot;assert supermodule.submodule.subfunction() == 'Subfunction'&quot;, None, Some(&amp;ctx)).unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>This way, you can create a module hierarchy within a single extension module.</p>
<h1><a class="header" href="#python-functions" id="python-functions">Python Functions</a></h1>
<p>PyO3 supports two ways to define a free function in Python. Both require registering
the function to a <a href="./module.html">module</a>.</p>
<p>One way is defining the function in the module definition, annotated with <code>#[pyfn]</code>.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;

#[pymodule]
fn rust2py(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {

    #[pyfn(m, &quot;sum_as_string&quot;)]
    fn sum_as_string_py(_py: Python, a:i64, b:i64) -&gt; PyResult&lt;String&gt; {
        Ok(format!(&quot;{}&quot;, a + b))
    }

    Ok(())
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>The other is annotating a function with <code>#[pyfunction]</code> and then adding it
to the module using the <code>wrap_pyfunction!</code> macro.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;
use pyo3::wrap_pyfunction;

#[pyfunction]
fn double(x: usize) -&gt; usize {
    x * 2
}

#[pymodule]
fn module_with_functions(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_wrapped(wrap_pyfunction!(double)).unwrap();

    Ok(())
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<h2><a class="header" href="#argument-parsing" id="argument-parsing">Argument parsing</a></h2>
<p>Both the <code>#[pyfunction]</code> and <code>#[pyfn]</code> attributes support specifying details of
argument parsing.  The details are given in the section &quot;Method arguments&quot; in
the <a href="class.html">Classes</a> chapter.  Here is an example for a function that accepts
arbitrary keyword arguments (<code>**kwargs</code> in Python syntax) and returns the number
that was passed:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">extern crate pyo3;
</span>use pyo3::prelude::*;
use pyo3::wrap_pyfunction;
use pyo3::types::PyDict;

#[pyfunction(kwds=&quot;**&quot;)]
fn num_kwds(kwds: Option&lt;&amp;PyDict&gt;) -&gt; usize {
    kwds.map_or(0, |dict| dict.len())
}

#[pymodule]
fn module_with_functions(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_wrapped(wrap_pyfunction!(num_kwds)).unwrap();
    Ok(())
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<h2><a class="header" href="#making-the-function-signature-available-to-python" id="making-the-function-signature-available-to-python">Making the function signature available to Python</a></h2>
<p>In order to make the function signature available to Python to be retrieved via
<code>inspect.signature</code>, use the <code>#[text_signature]</code> annotation as in the example
below. The <code>/</code> signifies the end of positional-only arguments. (This
is not a feature of this library in particular, but the general format used by
CPython for annotating signatures of built-in functions.)</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

/// This function adds two unsigned 64-bit integers.
#[pyfunction]
#[text_signature = &quot;(a, b, /)&quot;]
fn add(a: u64, b: u64) -&gt; u64 {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>This also works for classes and methods:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::types::PyType;

// it works even if the item is not documented:

#[pyclass]
#[text_signature = &quot;(c, d, /)&quot;]
struct MyClass {}

#[pymethods]
impl MyClass {
    // the signature for the constructor is attached
    // to the struct definition instead.
    #[new]
    fn new(c: i32, d: &amp;str) -&gt; Self {
        Self {}
    }
    // the self argument should be written $self
    #[text_signature = &quot;($self, e, f)&quot;]
    fn my_method(&amp;self, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    #[classmethod]
    #[text_signature = &quot;(cls, e, f)&quot;]
    fn my_class_method(cls: &amp;PyType, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    #[staticmethod]
    #[text_signature = &quot;(e, f)&quot;]
    fn my_static_method(e: i32, f: i32) -&gt; i32 {
        e + f
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#making-the-function-signature-available-to-python-old-method" id="making-the-function-signature-available-to-python-old-method">Making the function signature available to Python (old method)</a></h3>
<p>Alternatively, simply make sure the first line of your docstring is
formatted like in the following example. Please note that the newline after the
<code>--</code> is mandatory. The <code>/</code> signifies the end of positional-only arguments.</p>
<p><code>#[text_signature]</code> should be preferred, since it will override automatically
generated signatures when those are added in a future version of PyO3.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

/// add(a, b, /)
/// --
///
/// This function adds two unsigned 64-bit integers.
#[pyfunction]
fn add(a: u64, b: u64) -&gt; u64 {
    a + b
}

// a function with a signature but without docs. Both blank lines after the `--` are mandatory.

/// sub(a, b, /)
/// --
///
///
#[pyfunction]
fn sub(a: u64, b: u64) -&gt; u64 {
    a - b
}
<span class="boring">}
</span></code></pre></pre>
<p>When annotated like this, signatures are also correctly displayed in IPython.</p>
<pre><code class="language-ignore">&gt;&gt;&gt; pyo3_test.add?
Signature: pyo3_test.add(a, b, /)
Docstring: This function adds two unsigned 64-bit integers.
Type:      builtin_function_or_method
</code></pre>
<h2><a class="header" href="#closures" id="closures">Closures</a></h2>
<p>Currently, there are no conversions between <code>Fn</code>s in Rust and callables in Python. This would definitely be possible and very useful, so contributions are welcome. In the meantime, you can do the following:</p>
<h3><a class="header" href="#calling-python-functions-in-rust" id="calling-python-functions-in-rust">Calling Python functions in Rust</a></h3>
<p>You can use <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyAny.html#tymethod.is_callable"><code>PyAny::is_callable</code></a> to check if you have a callable object. <code>is_callable</code> will return <code>true</code> for functions (including lambdas), methods and objects with a <code>__call__</code> method. You can call the object with <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyAny.html#tymethod.call"><code>PyAny::call</code></a> with the args as first parameter and the kwargs (or <code>None</code>) as second parameter. There are also <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyAny.html#tymethod.call0"><code>PyAny::call0</code></a> with no args and <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyAny.html#tymethod.call1"><code>PyAny::call1</code></a> with only positional args.</p>
<h3><a class="header" href="#calling-rust-functions-in-python" id="calling-rust-functions-in-python">Calling Rust functions in Python</a></h3>
<p>If you have a static function, you can expose it with <code>#[pyfunction]</code> and use <a href="https://docs.rs/pyo3/latest/pyo3/macro.wrap_pyfunction.html"><code>wrap_pyfunction!</code></a> to get the corresponding <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyObject.html"><code>PyObject</code></a>. For dynamic functions, e.g. lambdas and functions that were passed as arguments, you must put them in some kind of owned container, e.g. a <code>Box</code>. (A long-term solution will be a special container similar to wasm-bindgen's <code>Closure</code>). You can then use a <code>#[pyclass]</code> struct with that container as a field as a way to pass the function over the FFI barrier. You can even make that class callable with <code>__call__</code> so it looks like a function in Python code.</p>
<h1><a class="header" href="#python-classes" id="python-classes">Python Classes</a></h1>
<h2><a class="header" href="#defining-a-new-class" id="defining-a-new-class">Defining a new class</a></h2>
<p>To define a custom Python class, a Rust struct needs to be annotated with the
<code>#[pyclass]</code> attribute.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
    debug: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>Because Python objects are freely shared between threads by the Python interpreter, all structs annotated with <code>#[pyclass]</code> must implement <code>Send</code>.</p>
<p>The above example generates implementations for <a href="https://docs.rs/pyo3/latest/pyo3/type_object/trait.PyTypeInfo.html"><code>PyTypeInfo</code></a>, <a href="https://docs.rs/pyo3/latest/pyo3/type_object/trait.PyTypeObject.html"><code>PyTypeObject</code></a>, and <a href="https://pyo3.rs/master/doc/pyo3/pyclass/trait.PyClass.html"><code>PyClass</code></a> for <code>MyClass</code>. To see these generated implementations, refer to the section <a href="class.html#how-methods-are-implemented">How methods are implemented</a> at the end of this chapter.</p>
<h2><a class="header" href="#adding-the-class-to-a-module" id="adding-the-class-to-a-module">Adding the class to a module</a></h2>
<p>Custom Python classes can then be added to a module using <code>add_class()</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">   num: i32,
</span><span class="boring">   debug: bool,
</span><span class="boring">}
</span>#[pymodule]
fn mymodule(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;MyClass&gt;()?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pycell-and-interior-mutability" id="pycell-and-interior-mutability">PyCell and interior mutability</a></h2>
<p>You sometimes need to convert your <code>pyclass</code> into a Python object and access it
from Rust code (e.g., for testing it).
<a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyCell.html"><code>PyCell</code></a> is the primary interface for that.</p>
<p><code>PyCell&lt;T: PyClass&gt;</code> is always allocated in the Python heap, so Rust doesn't have ownership of it.
In other words, Rust code can only extract a <code>&amp;PyCell&lt;T&gt;</code>, not a <code>PyCell&lt;T&gt;</code>.</p>
<p>Thus, to mutate data behind <code>&amp;PyCell</code> safely, PyO3 employs the
<a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">Interior Mutability Pattern</a>
like <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>.</p>
<p>Users who are familiar with <code>RefCell</code> can use <code>PyCell</code> just like <code>RefCell</code>.</p>
<p>For users who are not very familiar with <code>RefCell</code>, here is a reminder of Rust's rules of borrowing:</p>
<ul>
<li>At any given time, you can have either (but not both of) one mutable reference or any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<p><code>PyCell</code>, like <code>RefCell</code>, ensures these borrowing rules by tracking references at runtime.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyDict;
</span>#[pyclass]
struct MyClass {
    #[pyo3(get)]
    num: i32,
    debug: bool,
}
let gil = Python::acquire_gil();
let py = gil.python();
let obj = PyCell::new(py, MyClass { num: 3, debug: true }).unwrap();
{
    let obj_ref = obj.borrow(); // Get PyRef
    assert_eq!(obj_ref.num, 3);
    // You cannot get PyRefMut unless all PyRefs are dropped
    assert!(obj.try_borrow_mut().is_err());
}
{
    let mut obj_mut = obj.borrow_mut(); // Get PyRefMut
    obj_mut.num = 5;
    // You cannot get any other refs until the PyRefMut is dropped
    assert!(obj.try_borrow().is_err());
    assert!(obj.try_borrow_mut().is_err());
}

// You can convert `&amp;PyCell` to a Python object
pyo3::py_run!(py, obj, &quot;assert obj.num == 5&quot;)
<span class="boring">}
</span></code></pre></pre>
<p><code>&amp;PyCell&lt;T&gt;</code> is bounded by the same lifetime as a <a href="https://docs.rs/pyo3/latest/pyo3/struct.GILGuard.html"><code>GILGuard</code></a>.
To make the object longer lived (for example, to store it in a struct on the
Rust side), you can use <code>Py&lt;T&gt;</code>, which stores an object longer than the GIL
lifetime, and therefore needs a <code>Python&lt;'_&gt;</code> token to access.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}
fn return_myclass() -&gt; Py&lt;MyClass&gt; {
    let gil = Python::acquire_gil();
    let py = gil.python();
    Py::new(py, MyClass { num: 1 }).unwrap()
}
let gil = Python::acquire_gil();
let obj = return_myclass();
let cell = obj.as_ref(gil.python()); // AsPyRef::as_ref returns &amp;PyCell
let obj_ref = cell.borrow(); // Get PyRef&lt;T&gt;
assert_eq!(obj_ref.num, 1);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#customizing-the-class" id="customizing-the-class">Customizing the class</a></h2>
<p>The <code>#[pyclass]</code> macro accepts the following parameters:</p>
<ul>
<li><code>name=XXX</code> - Set the class name shown in Python code. By default, the struct name is used as the class name.</li>
<li><code>freelist=XXX</code> - The <code>freelist</code> parameter adds support of free allocation list to custom class.
The performance improvement applies to types that are often created and deleted in a row,
so that they can benefit from a freelist. <code>XXX</code> is a number of items for the free list.</li>
<li><code>gc</code> - Classes with the <code>gc</code> parameter participate in Python garbage collection.
If a custom class contains references to other Python objects that can be collected, the <a href="https://docs.rs/pyo3/latest/pyo3/class/gc/trait.PyGCProtocol.html"><code>PyGCProtocol</code></a> trait has to be implemented.</li>
<li><code>weakref</code> - Adds support for Python weak references.</li>
<li><code>extends=BaseType</code> - Use a custom base class. The base <code>BaseType</code> must implement <code>PyTypeInfo</code>.</li>
<li><code>subclass</code> - Allows Python classes to inherit from this class.</li>
<li><code>dict</code> - Adds <code>__dict__</code> support, so that the instances of this type have a dictionary containing arbitrary instance variables.</li>
<li><code>module=&quot;XXX&quot;</code> - Set the name of the module the class will be shown as defined in. If not given, the class
will be a virtual member of the <code>builtins</code> module.</li>
</ul>
<h2><a class="header" href="#constructor" id="constructor">Constructor</a></h2>
<p>By default it is not possible to create an instance of a custom class from Python code.
To declare a constructor, you need to define a method and annotate it with the <code>#[new]</code>
attribute. Only Python's <code>__new__</code> method can be specified, <code>__init__</code> is not available.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}

#[pymethods]
impl MyClass {
    #[new]
    fn new(num: i32) -&gt; Self {
        MyClass { num }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If no method marked with <code>#[new]</code> is declared, object instances can only be
created from Rust, but not from Python.</p>
<p>For arguments, see the <code>Method arguments</code> section below.</p>
<h3><a class="header" href="#return-type" id="return-type">Return type</a></h3>
<p>Generally, <code>#[new]</code> method have to return <code>T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code> or
<code>PyResult&lt;T&gt; where T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code>.</p>
<p>For constructors that may fail, you should wrap the return type in a PyResult as well.
Consult the table below to determine which type your constructor should return:</p>
<table><thead><tr><th></th><th><strong>Cannot fail</strong></th><th><strong>May fail</strong></th></tr></thead><tbody>
<tr><td><strong>No inheritance</strong></td><td><code>T</code></td><td><code>PyResult&lt;T&gt;</code></td></tr>
<tr><td><strong>Inheritance(T Inherits U)</strong></td><td><code>(T, U)</code></td><td><code>PyResult&lt;(T, U)&gt;</code></td></tr>
<tr><td><strong>Inheritance(General Case)</strong></td><td><a href="https://pyo3.rs/master/doc/pyo3/pyclass_init/struct.PyClassInitializer.html"><code>PyClassInitializer&lt;T&gt;</code></a></td><td><code>PyResult&lt;PyClassInitializer&lt;T&gt;&gt;</code></td></tr>
</tbody></table>
<h2><a class="header" href="#inheritance" id="inheritance">Inheritance</a></h2>
<p>By default, <code>PyAny</code> is used as the base class. To override this default,
use the <code>extends</code> parameter for <code>pyclass</code> with the full path to the base class.</p>
<p>For convenience, <code>(T, U)</code> implements <code>Into&lt;PyClassInitializer&lt;T&gt;&gt;</code> where <code>U</code> is the
baseclass of <code>T</code>.
But for more deeply nested inheritance, you have to return <code>PyClassInitializer&lt;T&gt;</code>
explicitly.</p>
<p>To get a parent class from a child, use <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> instead of <code>&amp;self</code> for methods,
or <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a> instead of <code>&amp;mut self</code>.
Then you can access a parent class by <code>self_.as_ref()</code> as <code>&amp;Self::BaseClass</code>,
or by <code>self_.into_super()</code> as <code>PyRef&lt;Self::BaseClass&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct BaseClass {
    val1: usize,
}

#[pymethods]
impl BaseClass {
    #[new]
    fn new() -&gt; Self {
        BaseClass { val1: 10 }
    }

    pub fn method(&amp;self) -&gt; PyResult&lt;usize&gt; {
        Ok(self.val1)
    }
}

#[pyclass(extends=BaseClass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; (Self, BaseClass) {
        (SubClass { val2: 15 }, BaseClass::new())
    }

    fn method2(self_: PyRef&lt;Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let super_ = self_.as_ref();  // Get &amp;BaseClass
        super_.method().map(|x| x * self_.val2)
    }
}

#[pyclass(extends=SubClass)]
struct SubSubClass {
    val3: usize,
}

#[pymethods]
impl SubSubClass {
    #[new]
    fn new() -&gt; PyClassInitializer&lt;Self&gt; {
        PyClassInitializer::from(SubClass::new())
            .add_subclass(SubSubClass{val3: 20})
    }

    fn method3(self_: PyRef&lt;Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let v = self_.val3;
        let super_ = self_.into_super();  // Get PyRef&lt;SubClass&gt;
        SubClass::method2(super_).map(|x| x * v)
    }
}
<span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">let subsub = pyo3::PyCell::new(py, SubSubClass::new()).unwrap();
</span><span class="boring">pyo3::py_run!(py, subsub, &quot;assert subsub.method3() == 3000&quot;)
</span><span class="boring">}
</span></code></pre></pre>
<p>You can also inherit native types such as <code>PyDict</code>, if they implement
<a href="https://pyo3.rs/master/doc/pyo3/type_object/trait.PySizedLayout.html"><code>PySizedLayout</code></a>.</p>
<p>However, because of some technical problems, we don't currently provide safe upcasting methods for types
that inherit native types. Even in such cases, you can unsafely get a base class by raw pointer conversion.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyDict;
use pyo3::{AsPyPointer, PyNativeType};
use std::collections::HashMap;

#[pyclass(extends=PyDict)]
#[derive(Default)]
struct DictWithCounter {
    counter: HashMap&lt;String, usize&gt;,
}

#[pymethods]
impl DictWithCounter {
    #[new]
    fn new() -&gt; Self {
        Self::default()
    }
    fn set(mut self_: PyRefMut&lt;Self&gt;, key: String, value: &amp;PyAny) -&gt; PyResult&lt;()&gt; {
        self_.counter.entry(key.clone()).or_insert(0);
        let py = self_.py();
        let dict: &amp;PyDict = unsafe { py.from_borrowed_ptr_or_err(self_.as_ptr())? };
        dict.set_item(key, value)
    }
}
<span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">let cnt = pyo3::PyCell::new(py, DictWithCounter::new()).unwrap();
</span><span class="boring">pyo3::py_run!(py, cnt, &quot;cnt.set('abc', 10); assert cnt['abc'] == 10&quot;)
</span><span class="boring">}
</span></code></pre></pre>
<p>If <code>SubClass</code> does not provide a baseclass initialization, the compilation fails.</p>
<pre><code class="language-compile_fail"># use pyo3::prelude::*;

#[pyclass]
struct BaseClass {
    val1: usize,
}

#[pyclass(extends=BaseClass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; Self {
        SubClass { val2: 15 }
    }
}
</code></pre>
<h2><a class="header" href="#object-properties" id="object-properties">Object properties</a></h2>
<p>PyO3 supports two ways to add properties to your <code>#[pyclass]</code>:</p>
<ul>
<li>For simple fields with no side effects, a <code>#[pyo3(get, set)]</code> attribute can be added directly to the field definition in the <code>#[pyclass]</code>.</li>
<li>For properties which require computation you can define <code>#[getter]</code> and <code>#[setter]</code> functions in the <code>#[pymethods]</code> block.</li>
</ul>
<p>We'll cover each of these in the following sections.</p>
<h3><a class="header" href="#object-properties-using-pyo3get-set" id="object-properties-using-pyo3get-set">Object properties using <code>#[pyo3(get, set)]</code></a></h3>
<p>For simple cases where a member variable is just read and written with no side effects, you can declare getters and setters in your <code>#[pyclass]</code> field definition using the <code>pyo3</code> attribute, like in the example below:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    #[pyo3(get, set)]
    num: i32
}
<span class="boring">}
</span></code></pre></pre>
<p>The above would make the <code>num</code> property available for reading and writing from Python code as <code>self.num</code>.</p>
<p>Properties can be readonly or writeonly by using just <code>#[pyo3(get)]</code> or <code>#[pyo3(set)]</code> respectively.</p>
<p>To use these annotations, your field type must implement some conversion traits:</p>
<ul>
<li>For <code>get</code> the field type must implement both <code>IntoPy&lt;PyObject&gt;</code> and <code>Clone</code>.</li>
<li>For <code>set</code> the field type must implement <code>FromPyObject</code>.</li>
</ul>
<h3><a class="header" href="#object-properties-using-getter-and-setter" id="object-properties-using-getter-and-setter">Object properties using <code>#[getter]</code> and <code>#[setter]</code></a></h3>
<p>For cases which don't satisfy the <code>#[pyo3(get, set)]</code> trait requirements, or need side effects, descriptor methods can be defined in a <code>#[pymethods]</code> <code>impl</code> block.</p>
<p>This is done using the <code>#[getter]</code> and <code>#[setter]</code> attributes, like in the example below:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}

#[pymethods]
impl MyClass {
    #[getter]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A getter or setter's function name is used as the property name by default. There are several
ways how to override the name.</p>
<p>If a function name starts with <code>get_</code> or <code>set_</code> for getter or setter respectively,
the descriptor name becomes the function name with this prefix removed. This is also useful in case of
Rust keywords like <code>type</code>
(<a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/raw-identifiers.html">raw identifiers</a>
can be used since Rust 2018).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter]
    fn get_num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, a property <code>num</code> is defined and available from Python code as <code>self.num</code>.</p>
<p>Both the <code>#[getter]</code> and <code>#[setter]</code> attributes accept one parameter.
If this parameter is specified, it is used as the property name, i.e.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">   num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter(number)]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter(number)]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, the property <code>number</code> is defined and available from Python code as <code>self.number</code>.</p>
<h2><a class="header" href="#instance-methods" id="instance-methods">Instance methods</a></h2>
<p>To define a Python compatible method, an <code>impl</code> block for your struct has to be annotated with the
<code>#[pymethods]</code> attribute. PyO3 generates Python compatible wrappers for all functions in this
block with some variations, like descriptors, class method static methods, etc.</p>
<p>Since Rust allows any number of <code>impl</code> blocks, you can easily split methods
between those accessible to Python (and Rust) and those accessible only to Rust.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method1(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }

    fn set_method(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Calls to these methods are protected by the GIL, so both <code>&amp;self</code> and <code>&amp;mut self</code> can be used.
The return type must be <code>PyResult&lt;T&gt;</code> or <code>T</code> for some <code>T</code> that implements <code>IntoPy&lt;PyObject&gt;</code>;
the latter is allowed if the method cannot raise Python exceptions.</p>
<p>A <code>Python</code> parameter can be specified as part of method signature, in this case the <code>py</code> argument
gets injected by the method wrapper, e.g.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method2(&amp;self, py: Python) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>From the Python perspective, the <code>method2</code> in this example does not accept any arguments.</p>
<h2><a class="header" href="#class-methods" id="class-methods">Class methods</a></h2>
<p>To create a class method for a custom class, the method needs to be annotated
with the <code>#[classmethod]</code> attribute.
This is the equivalent of the Python decorator <code>@classmethod</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyType;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[classmethod]
    fn cls_method(cls: &amp;PyType) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Declares a class method callable from Python.</p>
<ul>
<li>The first parameter is the type object of the class on which the method is called.
This may be the type object of a derived class.</li>
<li>The first parameter implicitly has type <code>&amp;PyType</code>.</li>
<li>For details on <code>parameter-list</code>, see the documentation of <code>Method arguments</code> section.</li>
<li>The return type must be <code>PyResult&lt;T&gt;</code> or <code>T</code> for some <code>T</code> that implements <code>IntoPy&lt;PyObject&gt;</code>.</li>
</ul>
<h2><a class="header" href="#static-methods" id="static-methods">Static methods</a></h2>
<p>To create a static method for a custom class, the method needs to be annotated with the
<code>#[staticmethod]</code> attribute. The return type must be <code>T</code> or <code>PyResult&lt;T&gt;</code> for some <code>T</code> that implements
<code>IntoPy&lt;PyObject&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[staticmethod]
    fn static_method(param1: i32, param2: &amp;str) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#class-attributes" id="class-attributes">Class attributes</a></h2>
<p>To create a class attribute (also called <a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables">class variable</a>), a method without
any arguments can be annotated with the <code>#[classattr]</code> attribute. The return type must be <code>T</code> for
some <code>T</code> that implements <code>IntoPy&lt;PyObject&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>#[pymethods]
impl MyClass {
    #[classattr]
    fn my_attribute() -&gt; String {
        &quot;hello&quot;.to_string()
    }
}

let gil = Python::acquire_gil();
let py = gil.python();
let my_class = py.get_type::&lt;MyClass&gt;();
pyo3::py_run!(py, my_class, &quot;assert my_class.my_attribute == 'hello'&quot;)
<span class="boring">}
</span></code></pre></pre>
<p>Note that unlike class variables defined in Python code, class attributes defined in Rust cannot
be mutated at all:</p>
<pre><code class="language-rust ignore">// Would raise a `TypeError: can't set attributes of built-in/extension type 'MyClass'`
pyo3::py_run!(py, my_class, &quot;my_class.my_attribute = 'foo'&quot;)
</code></pre>
<p>If the class attribute is defined with <code>const</code> code only, one can also annotate associated
constants:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>#[pymethods]
impl MyClass {
    #[classattr]
    const MY_CONST_ATTRIBUTE: &amp;'static str = &quot;foobar&quot;;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#callable-objects" id="callable-objects">Callable objects</a></h2>
<p>To specify a custom <code>__call__</code> method for a custom class, the method needs to be annotated with
the <code>#[call]</code> attribute. Arguments of the method are specified as for instance methods.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyTuple;
<span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[call]
    #[args(args=&quot;*&quot;)]
    fn __call__(&amp;self, args: &amp;PyTuple) -&gt; PyResult&lt;i32&gt; {
        println!(&quot;MyClass has been called&quot;);
        Ok(self.num)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#method-arguments" id="method-arguments">Method arguments</a></h2>
<p>By default, PyO3 uses function signatures to determine which arguments are required. Then it scans
the incoming <code>args</code> and <code>kwargs</code> parameters. If it can not find all required
parameters, it raises a <code>TypeError</code> exception. It is possible to override the default behavior
with the <code>#[args(...)]</code> attribute. This attribute accepts a comma separated list of parameters in
the form of <code>attr_name=&quot;default value&quot;</code>. Each parameter has to match the method parameter by name.</p>
<p>Each parameter can be one of the following types:</p>
<ul>
<li><code>&quot;*&quot;</code>: var arguments separator, each parameter defined after <code>&quot;*&quot;</code> is a keyword-only parameter.
Corresponds to python's <code>def meth(*, arg1.., arg2=..)</code>.</li>
<li><code>args=&quot;*&quot;</code>: &quot;args&quot; is var args, corresponds to Python's <code>def meth(*args)</code>. Type of the <code>args</code>
parameter has to be <code>&amp;PyTuple</code>.</li>
<li><code>kwargs=&quot;**&quot;</code>: &quot;kwargs&quot; receives keyword arguments, corresponds to Python's <code>def meth(**kwargs)</code>.
The type of the <code>kwargs</code> parameter has to be <code>Option&lt;&amp;PyDict&gt;</code>.</li>
<li><code>arg=&quot;Value&quot;</code>: arguments with default value. Corresponds to Python's <code>def meth(arg=Value)</code>.
If the <code>arg</code> argument is defined after var arguments, it is treated as a keyword-only argument.
Note that <code>Value</code> has to be valid rust code, PyO3 just inserts it into the generated
code unmodified.</li>
</ul>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::{PyDict, PyTuple};
<span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[new]
    #[args(num = &quot;-1&quot;, debug = &quot;true&quot;)]
    fn new(num: i32, debug: bool) -&gt; Self {
        MyClass { num, debug }
    }

    #[args(
        num = &quot;10&quot;,
        debug = &quot;true&quot;,
        py_args = &quot;*&quot;,
        name = &quot;\&quot;Hello\&quot;&quot;,
        py_kwargs = &quot;**&quot;
    )]
    fn method(
        &amp;mut self,
        num: i32,
        debug: bool,
        name: &amp;str,
        py_args: &amp;PyTuple,
        py_kwargs: Option&lt;&amp;PyDict&gt;,
    ) -&gt; PyResult&lt;String&gt; {
        self.debug = debug;
        self.num = num;
        Ok(format!(
            &quot;py_args={:?}, py_kwargs={:?}, name={}, num={}, debug={}&quot;,
            py_args, py_kwargs, name, self.num, self.debug
        ))
    }

    fn make_change(&amp;mut self, num: i32, debug: bool) -&gt; PyResult&lt;String&gt; {
        self.num = num;
        self.debug = debug;
        Ok(format!(&quot;num={}, debug={}&quot;, self.num, self.debug))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>N.B. the position of the <code>&quot;*&quot;</code> argument (if included) controls the system of handling positional and keyword arguments. In Python:</p>
<pre><code class="language-python">import mymodule

mc = mymodule.MyClass()
print(mc.method(44, False, &quot;World&quot;, 666, x=44, y=55))
print(mc.method(num=-1, name=&quot;World&quot;))
print(mc.make_change(44, False))
print(mc.make_change(debug=False, num=-1))
</code></pre>
<p>Produces output:</p>
<pre><code class="language-text">py_args=('World', 666), py_kwargs=Some({'x': 44, 'y': 55}), name=Hello, num=44, debug=false
py_args=(), py_kwargs=None, name=World, num=-1, debug=true
num=44, debug=false
num=-1, debug=false
</code></pre>
<h2><a class="header" href="#class-customizations" id="class-customizations">Class customizations</a></h2>
<p>Python's object model defines several protocols for different object behavior, like sequence,
mapping or number protocols. PyO3 defines separate traits for each of them. To provide specific
Python object behavior, you need to implement the specific trait for your struct. Important note,
each protocol implementation block has to be annotated with the <code>#[pyproto]</code> attribute.</p>
<p>All <code>#[pyproto]</code> methods which can be defined below can return <code>T</code> instead of <code>PyResult&lt;T&gt;</code> if the
method implementation is infallible. In addition, if the return type is <code>()</code>, it can be omitted altogether.</p>
<h3><a class="header" href="#basic-object-customization" id="basic-object-customization">Basic object customization</a></h3>
<p>The <a href="https://docs.rs/pyo3/latest/pyo3/class/basic/trait.PyObjectProtocol.html"><code>PyObjectProtocol</code></a> trait provides several basic customizations.</p>
<h4><a class="header" href="#attribute-access" id="attribute-access">Attribute access</a></h4>
<p>To customize object attribute access, define the following methods:</p>
<ul>
<li><code>fn __getattr__(&amp;self, name: FromPyObject) -&gt; PyResult&lt;impl IntoPy&lt;PyObject&gt;&gt;</code></li>
<li><code>fn __setattr__(&amp;mut self, name: FromPyObject, value: FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __delattr__(&amp;mut self, name: FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
</ul>
<p>Each method corresponds to Python's <code>self.attr</code>, <code>self.attr = value</code> and <code>del self.attr</code> code.</p>
<h4><a class="header" href="#string-conversions" id="string-conversions">String Conversions</a></h4>
<ul>
<li>
<p><code>fn __repr__(&amp;self) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
</li>
<li>
<p><code>fn __str__(&amp;self) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
<p>Possible return types for <code>__str__</code> and <code>__repr__</code> are <code>PyResult&lt;String&gt;</code> or <code>PyResult&lt;PyString&gt;</code>.</p>
</li>
<li>
<p><code>fn __bytes__(&amp;self) -&gt; PyResult&lt;PyBytes&gt;</code></p>
<p>Provides the conversion to <code>bytes</code>.</p>
</li>
<li>
<p><code>fn __format__(&amp;self, format_spec: &amp;str) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
<p>Special method that is used by the <code>format()</code> builtin and the <code>str.format()</code> method.
Possible return types are <code>PyResult&lt;String&gt;</code> or <code>PyResult&lt;PyString&gt;</code>.</p>
</li>
</ul>
<h4><a class="header" href="#comparison-operators" id="comparison-operators">Comparison operators</a></h4>
<ul>
<li>
<p><code>fn __richcmp__(&amp;self, other: impl FromPyObject, op: CompareOp) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Overloads Python comparison operations (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>).
The <code>op</code> argument indicates the comparison operation being performed.
The return type will normally be <code>PyResult&lt;bool&gt;</code>, but any Python object can be returned.
If <code>other</code> is not of the type specified in the signature, the generated code will
automatically <code>return NotImplemented</code>.</p>
</li>
<li>
<p><code>fn __hash__(&amp;self) -&gt; PyResult&lt;impl PrimInt&gt;</code></p>
<p>Objects that compare equal must have the same hash value.
The return type must be <code>PyResult&lt;T&gt;</code> where <code>T</code> is one of Rust's primitive integer types.</p>
</li>
</ul>
<h4><a class="header" href="#other-methods" id="other-methods">Other methods</a></h4>
<ul>
<li>
<p><code>fn __bool__(&amp;self) -&gt; PyResult&lt;bool&gt;</code></p>
<p>Determines the &quot;truthyness&quot; of the object.</p>
</li>
</ul>
<h3><a class="header" href="#garbage-collector-integration" id="garbage-collector-integration">Garbage Collector Integration</a></h3>
<p>If your type owns references to other Python objects, you will need to
integrate with Python's garbage collector so that the GC is aware of
those references.
To do this, implement the <a href="https://docs.rs/pyo3/latest/pyo3/class/gc/trait.PyGCProtocol.html"><code>PyGCProtocol</code></a> trait for your struct.
It includes two methods <code>__traverse__</code> and <code>__clear__</code>.
These correspond to the slots <code>tp_traverse</code> and <code>tp_clear</code> in the Python C API.
<code>__traverse__</code> must call <code>visit.call()</code> for each reference to another Python object.
<code>__clear__</code> must clear out any mutable references to other Python objects
(thus breaking reference cycles). Immutable references do not have to be cleared,
as every cycle must contain at least one mutable reference.
Example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>extern crate pyo3;

use pyo3::prelude::*;
use pyo3::PyTraverseError;
use pyo3::gc::{PyGCProtocol, PyVisit};

#[pyclass]
struct ClassWithGCSupport {
    obj: Option&lt;PyObject&gt;,
}

#[pyproto]
impl PyGCProtocol for ClassWithGCSupport {
    fn __traverse__(&amp;self, visit: PyVisit) -&gt; Result&lt;(), PyTraverseError&gt; {
        if let Some(ref obj) = self.obj {
            visit.call(obj)?
        }
        Ok(())
    }

    fn __clear__(&amp;mut self) {
        if let Some(obj) = self.obj.take() {
            // Release reference, this decrements ref counter.
            let gil = GILGuard::acquire();
            let py = gil.python();
            py.release(obj);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Special protocol trait implementations have to be annotated with the <code>#[pyproto]</code> attribute.</p>
<p>It is also possible to enable GC for custom classes using the <code>gc</code> parameter of the <code>pyclass</code> attribute.
i.e. <code>#[pyclass(gc)]</code>. In that case instances of custom class participate in Python garbage
collection, and it is possible to track them with <code>gc</code> module methods. When using the <code>gc</code> parameter,
it is <em>required</em> to implement the <code>PyGCProtocol</code> trait, failure to do so will result in an error
at compile time:</p>
<pre><code class="language-compile_fail">#[pyclass(gc)]
struct GCTracked {} // Fails because it does not implement PyGCProtocol
</code></pre>
<h3><a class="header" href="#iterator-types" id="iterator-types">Iterator Types</a></h3>
<p>Iterators can be defined using the
<a href="https://docs.rs/pyo3/latest/pyo3/class/iter/trait.PyIterProtocol.html"><code>PyIterProtocol</code></a> trait.
It includes two methods <code>__iter__</code> and <code>__next__</code>:</p>
<ul>
<li><code>fn __iter__(slf: PyRefMut&lt;Self&gt;) -&gt; PyResult&lt;impl IntoPy&lt;PyObject&gt;&gt;</code></li>
<li><code>fn __next__(slf: PyRefMut&lt;Self&gt;) -&gt; PyResult&lt;Option&lt;impl IntoPy&lt;PyObject&gt;&gt;&gt;</code></li>
</ul>
<p>Returning <code>None</code> from <code>__next__</code> indicates that that there are no further items.
These two methods can be take either <code>PyRef&lt;Self&gt;</code> or <code>PyRefMut&lt;Self&gt;</code> as their
first argument, so that mutable borrow can be avoided if needed.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::PyIterProtocol;

#[pyclass]
struct MyIterator {
    iter: Box&lt;Iterator&lt;Item = PyObject&gt; + Send&gt;,
}

#[pyproto]
impl PyIterProtocol for MyIterator {
    fn __iter__(slf: PyRef&lt;Self&gt;) -&gt; Py&lt;MyIterator&gt; {
        slf.into()
    }
    fn __next__(mut slf: PyRefMut&lt;Self&gt;) -&gt; Option&lt;PyObject&gt; {
        slf.iter.next()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In many cases you'll have a distinction between the type being iterated over (i.e. the <em>iterable</em>) and the iterator it
provides. In this case, you should implement <code>PyIterProtocol</code> for both the iterable and the iterator, but the iterable
only needs to support <code>__iter__()</code> while the iterator must support both <code>__iter__()</code> and <code>__next__()</code>. The default
implementations in <code>PyIterProtocol</code> will ensure that the objects behave correctly in Python. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::PyIterProtocol;
</span>
#[pyclass]
struct Iter {
    inner: std::vec::IntoIter&lt;usize&gt;,
}

#[pyproto]
impl PyIterProtocol for Iter {
    fn __iter__(slf: PyRefMut&lt;Self&gt;) -&gt; Py&lt;Iter&gt; {
        slf.into()
    }

    fn __next__(mut slf: PyRefMut&lt;Self&gt;) -&gt; Option&lt;usize&gt; {
        slf.inner.next()
    }
}

#[pyclass]
struct Container {
    iter: Vec&lt;usize&gt;,
}

#[pyproto]
impl PyIterProtocol for Container {
    fn __iter__(slf: PyRefMut&lt;Self&gt;) -&gt; PyResult&lt;Py&lt;Iter&gt;&gt; {
        let iter = Iter {
            inner: slf.iter.clone().into_iter(),
        };
        Py::new(slf.py(), iter)
    }
}

<span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">let inst = pyo3::PyCell::new(
</span><span class="boring">    py,
</span><span class="boring">    Container {
</span><span class="boring">        iter: vec![1, 2, 3, 4],
</span><span class="boring">    },
</span><span class="boring">)
</span><span class="boring">.unwrap();
</span><span class="boring">pyo3::py_run!(py, inst, &quot;assert list(inst) == [1, 2, 3, 4]&quot;);
</span><span class="boring">pyo3::py_run!(py, inst, &quot;assert list(iter(iter(inst))) == [1, 2, 3, 4]&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>For more details on Python's iteration protocols, check out <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types">the &quot;Iterator Types&quot; section of the library
documentation</a>.</p>
<h4><a class="header" href="#returning-a-value-from-iteration" id="returning-a-value-from-iteration">Returning a value from iteration</a></h4>
<p>This guide has so far shown how to use <code>Option&lt;T&gt;</code> to implement yielding values during iteration.
In Python a generator can also return a value. To express this in Rust, PyO3 provides the
<a href="https://docs.rs/pyo3/latest/pyo3/class/iter/enum.IterNextOutput.html"><code>IterNextOutput</code></a> enum to
both <code>Yield</code> values and <code>Return</code> a final value - see its docs for further details and an example.</p>
<h2><a class="header" href="#how-methods-are-implemented" id="how-methods-are-implemented">How methods are implemented</a></h2>
<p>Users should be able to define a <code>#[pyclass]</code> with or without <code>#[pymethods]</code>, while PyO3 needs a
trait with a function that returns all methods. Since it's impossible to make the code generation in
pyclass dependent on whether there is an impl block, we'd need to implement the trait on
<code>#[pyclass]</code> and override the implementation in <code>#[pymethods]</code>.
To enable this, we use a static registry type provided by <a href="https://github.com/dtolnay/inventory">inventory</a>,
which allows us to collect <code>impl</code>s from arbitrary source code by exploiting some binary trick.
See <a href="https://github.com/dtolnay/inventory#how-it-works">inventory: how it works</a> and <code>pyo3_derive_backend::py_class</code> for more details.
Also for <code>#[pyproto]</code>, we use a similar, but more task-specific registry and
initialize it using the <a href="https://github.com/mmastrac/rust-ctor">ctor</a> crate.</p>
<p>Specifically, the following implementation is generated:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

/// Class for demonstration
struct MyClass {
    num: i32,
    debug: bool,
}

impl pyo3::pyclass::PyClassAlloc for MyClass {}

unsafe impl pyo3::PyTypeInfo for MyClass {
    type Type = MyClass;
    type BaseType = PyAny;
    type BaseLayout = pyo3::pycell::PyCellBase&lt;PyAny&gt;;
    type Layout = PyCell&lt;Self&gt;;
    type Initializer = PyClassInitializer&lt;Self&gt;;
    type AsRefTarget = PyCell&lt;Self&gt;;

    const NAME: &amp;'static str = &quot;MyClass&quot;;
    const MODULE: Option&lt;&amp;'static str&gt; = None;
    const DESCRIPTION: &amp;'static str = &quot;Class for demonstration&quot;;
    const FLAGS: usize = 0;

    #[inline]
    fn type_object_raw(py: pyo3::Python) -&gt; *mut pyo3::ffi::PyTypeObject {
        use pyo3::type_object::LazyStaticType;
        static TYPE_OBJECT: LazyStaticType = LazyStaticType::new();
        TYPE_OBJECT.get_or_init::&lt;Self&gt;(py)
    }
}

impl pyo3::pyclass::PyClass for MyClass {
    type Dict = pyo3::pyclass_slots::PyClassDummySlot;
    type WeakRef = pyo3::pyclass_slots::PyClassDummySlot;
    type BaseNativeType = PyAny;
}

impl pyo3::IntoPy&lt;PyObject&gt; for MyClass {
    fn into_py(self, py: pyo3::Python) -&gt; pyo3::PyObject {
        pyo3::IntoPy::into_py(pyo3::Py::new(py, self).unwrap(), py)
    }
}

pub struct Pyo3MethodsInventoryForMyClass {
    methods: &amp;'static [pyo3::class::PyMethodDefType],
}
impl pyo3::class::methods::PyMethodsInventory for Pyo3MethodsInventoryForMyClass {
    fn new(methods: &amp;'static [pyo3::class::PyMethodDefType]) -&gt; Self {
        Self { methods }
    }
    fn get(&amp;self) -&gt; &amp;'static [pyo3::class::PyMethodDefType] {
        self.methods
    }
}
impl pyo3::class::methods::HasMethodsInventory for MyClass {
    type Methods = Pyo3MethodsInventoryForMyClass;
}
pyo3::inventory::collect!(Pyo3MethodsInventoryForMyClass);

impl pyo3::class::proto_methods::HasProtoRegistry for MyClass {
    fn registry() -&gt; &amp;'static pyo3::class::proto_methods::PyProtoRegistry {
        static REGISTRY: pyo3::class::proto_methods::PyProtoRegistry
            = pyo3::class::proto_methods::PyProtoRegistry::new();
        &amp;REGISTRY
    }
}
<span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">let cls = py.get_type::&lt;MyClass&gt;();
</span><span class="boring">pyo3::py_run!(py, cls, &quot;assert cls.__name__ == 'MyClass'&quot;)
</span><span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#type-conversions" id="type-conversions">Type Conversions</a></h1>
<p>In this portion of the guide we'll talk about the mapping of Python types to Rust types offered by PyO3, as well as the traits available to perform conversions between them.</p>
<h2><a class="header" href="#mapping-of-rust-types-to-python-types" id="mapping-of-rust-types-to-python-types">Mapping of Rust types to Python types</a></h2>
<p>When writing functions callable from Python (such as a <code>#[pyfunction]</code> or in a <code>#[pymethods]</code> block), the trait <code>FromPyObject</code> is required for function arguments, and <code>IntoPy&lt;PyObject&gt;</code> is required for function return values.</p>
<p>Consult the tables in the following section to find the Rust types provided by PyO3 which implement these traits.</p>
<h3><a class="header" href="#argument-types" id="argument-types">Argument Types</a></h3>
<p>When accepting a function argument, it is possible to either use Rust library types or PyO3's Python-native types. (See the next section for discussion on when to use each.)</p>
<p>The table below contains the Python type and the corresponding function argument types that will accept them:</p>
<table><thead><tr><th>Python</th><th align="center">Rust</th><th align="center">Rust (Python-native)</th></tr></thead><tbody>
<tr><td><code>object</code></td><td align="center">-</td><td align="center"><code>&amp;PyAny</code></td></tr>
<tr><td><code>str</code></td><td align="center"><code>String</code>, <code>Cow&lt;str&gt;</code>, <code>&amp;str</code></td><td align="center"><code>&amp;PyUnicode</code></td></tr>
<tr><td><code>bytes</code></td><td align="center"><code>Vec&lt;u8&gt;</code>, <code>&amp;[u8]</code></td><td align="center"><code>&amp;PyBytes</code></td></tr>
<tr><td><code>bool</code></td><td align="center"><code>bool</code></td><td align="center"><code>&amp;PyBool</code></td></tr>
<tr><td><code>int</code></td><td align="center">Any integer type (<code>i32</code>, <code>u32</code>, <code>usize</code>, etc)</td><td align="center"><code>&amp;PyLong</code></td></tr>
<tr><td><code>float</code></td><td align="center"><code>f32</code>, <code>f64</code></td><td align="center"><code>&amp;PyFloat</code></td></tr>
<tr><td><code>complex</code></td><td align="center"><code>num_complex::Complex</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td align="center"><code>&amp;PyComplex</code></td></tr>
<tr><td><code>list[T]</code></td><td align="center"><code>Vec&lt;T&gt;</code></td><td align="center"><code>&amp;PyList</code></td></tr>
<tr><td><code>dict[K, V]</code></td><td align="center"><code>HashMap&lt;K, V&gt;</code>, <code>BTreeMap&lt;K, V&gt;</code></td><td align="center"><code>&amp;PyDict</code></td></tr>
<tr><td><code>tuple[T, U]</code></td><td align="center"><code>(T, U)</code>, <code>Vec&lt;T&gt;</code></td><td align="center"><code>&amp;PyTuple</code></td></tr>
<tr><td><code>set[T]</code></td><td align="center"><code>HashSet&lt;T&gt;</code>, <code>BTreeSet&lt;T&gt;</code></td><td align="center"><code>&amp;PySet</code></td></tr>
<tr><td><code>frozenset[T]</code></td><td align="center"><code>HashSet&lt;T&gt;</code>, <code>BTreeSet&lt;T&gt;</code></td><td align="center"><code>&amp;PyFrozenSet</code></td></tr>
<tr><td><code>bytearray</code></td><td align="center"><code>Vec&lt;u8&gt;</code></td><td align="center"><code>&amp;PyByteArray</code></td></tr>
<tr><td><code>slice</code></td><td align="center">-</td><td align="center"><code>&amp;PySlice</code></td></tr>
<tr><td><code>type</code></td><td align="center">-</td><td align="center"><code>&amp;PyType</code></td></tr>
<tr><td><code>module</code></td><td align="center">-</td><td align="center"><code>&amp;PyModule</code></td></tr>
<tr><td><code>datetime.datetime</code></td><td align="center">-</td><td align="center"><code>&amp;PyDateTime</code></td></tr>
<tr><td><code>datetime.date</code></td><td align="center">-</td><td align="center"><code>&amp;PyDate</code></td></tr>
<tr><td><code>datetime.time</code></td><td align="center">-</td><td align="center"><code>&amp;PyTime</code></td></tr>
<tr><td><code>datetime.tzinfo</code></td><td align="center">-</td><td align="center"><code>&amp;PyTzInfo</code></td></tr>
<tr><td><code>datetime.timedelta</code></td><td align="center">-</td><td align="center"><code>&amp;PyDelta</code></td></tr>
<tr><td><code>typing.Optional[T]</code></td><td align="center"><code>Option&lt;T&gt;</code></td><td align="center">-</td></tr>
<tr><td><code>typing.Sequence[T]</code></td><td align="center"><code>Vec&lt;T&gt;</code></td><td align="center"><code>&amp;PySequence</code></td></tr>
<tr><td><code>typing.Iterator[Any]</code></td><td align="center">-</td><td align="center"><code>&amp;PyIterator</code></td></tr>
</tbody></table>
<p>There are also a few special types related to the GIL and Rust-defined <code>#[pyclass]</code>es which may come in useful:</p>
<table><thead><tr><th>What</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Python</code></td><td>A GIL token, used to pass to PyO3 constructors to prove ownership of the GIL</td></tr>
<tr><td><code>PyObject</code></td><td>A Python object isolated from the GIL lifetime. This can be sent to other threads. To call Python APIs using this object, it must be used with <code>AsPyRef::as_ref</code> to get a <code>&amp;PyAny</code> reference.</td></tr>
<tr><td><code>Py&lt;T&gt;</code></td><td>Same as above, for a specific Python type or <code>#[pyclass]</code> T.</td></tr>
<tr><td><code>&amp;PyCell&lt;T&gt;</code></td><td>A <code>#[pyclass]</code> value owned by Python.</td></tr>
<tr><td><code>PyRef&lt;T&gt;</code></td><td>A <code>#[pyclass]</code> borrowed immutably.</td></tr>
<tr><td><code>PyRefMut&lt;T&gt;</code></td><td>A <code>#[pyclass]</code> borrowed mutably.</td></tr>
</tbody></table>
<p>For more detail on accepting <code>#[pyclass]</code> values as function arguments, see <a href="class.html">the section of this guide on Python Classes</a>.</p>
<h4><a class="header" href="#using-rust-library-types-vs-python-native-types" id="using-rust-library-types-vs-python-native-types">Using Rust library types vs Python-native types</a></h4>
<p>Using Rust library types as function arguments will incur a conversion cost compared to using the Python-native types. Using the Python-native types is almost zero-cost (they just require a type check similar to the Python builtin function <code>isinstance()</code>).</p>
<p>However, once that conversion cost has been paid, the Rust standard library types offer a number of benefits:</p>
<ul>
<li>You can write functionality in native-speed Rust code (free of Python's runtime costs).</li>
<li>You get better interoperability with the rest of the Rust ecosystem.</li>
<li>You can use <code>Python::allow_threads</code> to release the Python GIL and let other Python threads make progress while your Rust code is executing.</li>
<li>You also benefit from stricter type checking. For example you can specify <code>Vec&lt;i32&gt;</code>, which will only accept a Python <code>list</code> containing integers. The Python-native equivalent, <code>&amp;PyList</code>, would accept a Python <code>list</code> containing Python objects of any type.</li>
</ul>
<p>For most PyO3 usage the conversion cost is worth paying to get these benefits. As always, if you're not sure it's worth it in your case, benchmark it!</p>
<h3><a class="header" href="#returning-rust-values-to-python" id="returning-rust-values-to-python">Returning Rust values to Python</a></h3>
<p>When returning values from functions callable from Python, Python-native types (<code>&amp;PyAny</code>, <code>&amp;PyDict</code> etc.) can be used with zero cost.</p>
<p>Because these types are references, in some situations the Rust compiler may ask for lifetime annotations. If this is the case, you should use <code>Py&lt;PyAny&gt;</code>, <code>Py&lt;PyDict&gt;</code> etc. instead - which are also zero-cost. For all of these Python-native types <code>T</code>, <code>Py&lt;T&gt;</code> can be created from <code>T</code> with an <code>.into()</code> conversion.</p>
<p>If your function is fallible, it should return <code>PyResult&lt;T&gt;</code>, which will raise a <code>Python</code> exception if the <code>Err</code> variant is returned.</p>
<p>Finally, the following Rust types are also able to convert to Python as return values:</p>
<table><thead><tr><th>Rust type</th><th align="center">Resulting Python Type</th></tr></thead><tbody>
<tr><td><code>String</code></td><td align="center"><code>str</code></td></tr>
<tr><td><code>&amp;str</code></td><td align="center"><code>str</code></td></tr>
<tr><td><code>bool</code></td><td align="center"><code>bool</code></td></tr>
<tr><td>Any integer type (<code>i32</code>, <code>u32</code>, <code>usize</code>, etc)</td><td align="center"><code>int</code></td></tr>
<tr><td><code>f32</code>, <code>f64</code></td><td align="center"><code>float</code></td></tr>
<tr><td><code>Option&lt;T&gt;</code></td><td align="center"><code>Optional[T]</code></td></tr>
<tr><td><code>(T, U)</code></td><td align="center"><code>Tuple[T, U]</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td align="center"><code>List[T]</code></td></tr>
<tr><td><code>HashMap&lt;K, V&gt;</code></td><td align="center"><code>Dict[K, V]</code></td></tr>
<tr><td><code>BTreeMap&lt;K, V&gt;</code></td><td align="center"><code>Dict[K, V]</code></td></tr>
<tr><td><code>HashSet&lt;T&gt;</code></td><td align="center"><code>Set[T]</code></td></tr>
<tr><td><code>BTreeSet&lt;T&gt;</code></td><td align="center"><code>Set[T]</code></td></tr>
<tr><td><code>&amp;PyCell&lt;T: PyClass&gt;</code></td><td align="center"><code>T</code></td></tr>
<tr><td><code>PyRef&lt;T: PyClass&gt;</code></td><td align="center"><code>T</code></td></tr>
<tr><td><code>PyRefMut&lt;T: PyClass&gt;</code></td><td align="center"><code>T</code></td></tr>
</tbody></table>
<h2><a class="header" href="#traits" id="traits">Traits</a></h2>
<p>PyO3 provides some handy traits to convert between Python types and Rust types.</p>
<h3><a class="header" href="#extract-and-the-frompyobject-trait" id="extract-and-the-frompyobject-trait"><code>.extract()</code> and the <code>FromPyObject</code> trait</a></h3>
<p>The easiest way to convert a Python object to a Rust value is using
<code>.extract()</code>.  It returns a <code>PyResult</code> with a type error if the conversion
fails, so usually you will use something like</p>
<pre><code class="language-ignore">let v: Vec&lt;i32&gt; = obj.extract()?;
</code></pre>
<p>This method is available for many Python object types, and can produce a wide
variety of Rust types, which you can check out in the implementor list of
<a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a>.</p>
<p><a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> is also implemented for your own Rust types wrapped as Python
objects (see <a href="class.html">the chapter about classes</a>).  There, in order to both be
able to operate on mutable references <em>and</em> satisfy Rust's rules of non-aliasing
mutable references, you have to extract the PyO3 reference wrappers <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a>
and <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a>.  They work like the reference wrappers of
<code>std::cell::RefCell</code> and ensure (at runtime) that Rust borrows are allowed.</p>
<h3><a class="header" href="#the-topyobject-trait" id="the-topyobject-trait">The <code>ToPyObject</code> trait</a></h3>
<p><a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.ToPyObject.html"><code>ToPyObject</code></a> is a conversion trait that allows various objects to be
converted into <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyObject.html"><code>PyObject</code></a>. <code>IntoPy&lt;PyObject&gt;</code> serves the
same purpose, except that it consumes <code>self</code>.</p>
<h3><a class="header" href="#args-and-kwargs-for-python-object-calls" id="args-and-kwargs-for-python-object-calls"><code>*args</code> and <code>**kwargs</code> for Python object calls</a></h3>
<p>There are several ways how to pass positional and keyword arguments to a Python object call.
<a href="https://docs.rs/pyo3/latest/pyo3/struct.PyAny.html"><code>PyAny</code></a> provides two methods:</p>
<ul>
<li><code>call</code> - call any callable Python object.</li>
<li><code>call_method</code> - call a specific method on the object, shorthand for <code>get_attr</code> then <code>call</code>.</li>
</ul>
<p>Both methods need <code>args</code> and <code>kwargs</code> arguments, but there are variants for less
complex calls, such as <code>call1</code> for only <code>args</code> and <code>call0</code> for no arguments at all.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::{PyDict, PyTuple};

struct SomeObject;
impl SomeObject {
    fn new(py: Python) -&gt; PyObject {
        PyDict::new(py).to_object(py)
    }
}

fn main() {
    let arg1 = &quot;arg1&quot;;
    let arg2 = &quot;arg2&quot;;
    let arg3 = &quot;arg3&quot;;

    let gil = Python::acquire_gil();
    let py = gil.python();

    let obj = SomeObject::new(py);

    // call object without empty arguments
    obj.call0(py);

    // call object with PyTuple
    let args = PyTuple::new(py, &amp;[arg1, arg2, arg3]);
    obj.call1(py, args);

    // pass arguments as rust tuple
    let args = (arg1, arg2, arg3);
    obj.call1(py, args);
}
</code></pre></pre>
<p><code>kwargs</code> can be <code>None</code> or <code>Some(&amp;PyDict)</code>. You can use the
<a href="https://docs.rs/pyo3/latest/pyo3/types/trait.IntoPyDict.html"><code>IntoPyDict</code></a> trait to convert other dict-like containers,
e.g. <code>HashMap</code> or <code>BTreeMap</code>, as well as tuples with up to 10 elements and
<code>Vec</code>s where each element is a two-element tuple.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::{IntoPyDict, PyDict};
use std::collections::HashMap;

struct SomeObject;

impl SomeObject {
    fn new(py: Python) -&gt; PyObject {
        PyDict::new(py).to_object(py)
    }
}

fn main() {
    let key1 = &quot;key1&quot;;
    let val1 = 1;
    let key2 = &quot;key2&quot;;
    let val2 = 2;

    let gil = Python::acquire_gil();
    let py = gil.python();

    let obj = SomeObject::new(py);

    // call object with PyDict
    let kwargs = [(key1, val1)].into_py_dict(py);
    obj.call(py, (), Some(kwargs));

    // pass arguments as Vec
    let kwargs = vec![(key1, val1), (key2, val2)];
    obj.call(py, (), Some(kwargs.into_py_dict(py)));

    // pass arguments as HashMap
    let mut kwargs = HashMap::&lt;&amp;str, i32&gt;::new();
    kwargs.insert(key1, 1);
    obj.call(py, (), Some(kwargs.into_py_dict(py)));
}
</code></pre></pre>
<h3><a class="header" href="#frompyt-and-intopyt" id="frompyt-and-intopyt"><code>FromPy&lt;T&gt;</code> and <code>IntoPy&lt;T&gt;</code></a></h3>
<p>Many conversions in PyO3 can't use <code>std::convert::From</code> because they need a GIL token.
The <a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.FromPy.html"><code>FromPy</code></a> trait offers an <code>from_py</code> method that works just like <code>from</code>, except for taking a <code>Python&lt;'_&gt;</code> argument.
I.e. <code>FromPy&lt;T&gt;</code> could be converting a Rust object into a Python object even though it is called <a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.FromPy.html"><code>FromPy</code></a> - it doesn't say anything about which side of the conversion is a Python object.</p>
<p>Just like <code>From&lt;T&gt;</code>, if you implement <code>FromPy&lt;T&gt;</code> you gain a blanket implementation of <a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.IntoPy.html"><code>IntoPy</code></a> for free.</p>
<p>Eventually, traits such as <a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.ToPyObject.html"><code>ToPyObject</code></a> will be replaced by this trait and a <a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.FromPy.html"><code>FromPy</code></a> trait will be added that will implement
<a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.IntoPy.html"><code>IntoPy</code></a>, just like with <code>From</code> and <code>Into</code>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Requires the <code>num-complex</code> optional feature.</p>
</div>
<h1><a class="header" href="#python-exceptions" id="python-exceptions">Python Exceptions</a></h1>
<h2><a class="header" href="#defining-a-new-exception" id="defining-a-new-exception">Defining a new exception</a></h2>
<p>You can use the <a href="https://docs.rs/pyo3/latest/pyo3/macro.create_exception.html"><code>create_exception!</code></a> macro to define a new exception type:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::create_exception;

create_exception!(module, MyError, pyo3::exceptions::Exception);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>module</code> is the name of the containing module.</li>
<li><code>MyError</code> is the name of the new exception type.</li>
</ul>
<p>For example:</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;
use pyo3::create_exception;
use pyo3::types::IntoPyDict;
use pyo3::exceptions::Exception;

create_exception!(mymodule, CustomError, Exception);

fn main() {
    let gil = Python::acquire_gil();
    let py = gil.python();
    let ctx = [(&quot;CustomError&quot;, py.get_type::&lt;CustomError&gt;())].into_py_dict(py);

    py.run(&quot;assert str(CustomError) == \&quot;&lt;class 'mymodule.CustomError'&gt;\&quot;&quot;, None, Some(&amp;ctx)).unwrap();
    py.run(&quot;assert CustomError('oops').args == ('oops',)&quot;, None, Some(&amp;ctx)).unwrap();
}
</code></pre></pre>
<h2><a class="header" href="#raising-an-exception" id="raising-an-exception">Raising an exception</a></h2>
<p>To raise an exception, first you need to obtain an exception type and construct a new <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html"><code>PyErr</code></a>, then call the <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html#method.restore"><code>PyErr::restore</code></a> method to write the exception back to the Python interpreter's global state.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::{Python, PyErr};
use pyo3::exceptions;

fn main() {
    let gil = Python::acquire_gil();
    let py = gil.python();
    PyErr::new::&lt;exceptions::TypeError, _&gt;(&quot;Error&quot;).restore(py);
    assert!(PyErr::occurred(py));
    drop(PyErr::fetch(py));
}
</code></pre></pre>
<p>From <code>pyfunction</code>s and <code>pyclass</code> methods, returning an <code>Err(PyErr)</code> is enough;
PyO3 will handle restoring the exception on the Python interpreter side.</p>
<p>If you already have a Python exception instance, you can simply call <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html#method.from_instance"><code>PyErr::from_instance</code></a>.</p>
<pre><code class="language-rust ignore">PyErr::from_instance(py, err).restore(py);
</code></pre>
<p>If a Rust type exists for the exception, then it is possible to use the <code>py_err</code> method.
For example, each standard exception defined in the <code>pyo3::exceptions</code> module
has a corresponding Rust type, exceptions defined by <a href="https://docs.rs/pyo3/latest/pyo3/macro.create_exception.html"><code>create_exception!</code></a> and <a href="https://docs.rs/pyo3/latest/pyo3/macro.import_exception.html"><code>import_exception!</code></a> macro
have Rust types as well.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::exceptions;
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">fn check_for_error() -&gt; bool {false}
</span>fn my_func(arg: PyObject) -&gt; PyResult&lt;()&gt; {
    if check_for_error() {
        Err(exceptions::ValueError::py_err(&quot;argument is wrong&quot;))
    } else {
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#checking-exception-types" id="checking-exception-types">Checking exception types</a></h2>
<p>Python has an <a href="https://docs.python.org/3/library/functions.html#isinstance"><code>isinstance</code></a> method to check an object's type,
in PyO3 there is a <a href="https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.is_instance"><code>Python::is_instance</code></a> method which does the same thing.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::Python;
use pyo3::types::{PyBool, PyList};

fn main() {
    let gil = Python::acquire_gil();
    let py = gil.python();
    assert!(py.is_instance::&lt;PyBool, _&gt;(PyBool::new(py, true)).unwrap());
    let list = PyList::new(py, &amp;[1, 2, 3, 4]);
    assert!(!py.is_instance::&lt;PyBool, _&gt;(list.as_ref()).unwrap());
    assert!(py.is_instance::&lt;PyList, _&gt;(list.as_ref()).unwrap());
}
</code></pre></pre>
<p><a href="https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.is_instance"><code>Python::is_instance</code></a> calls the underlying <a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyType.html#method.is_instance"><code>PyType::is_instance</code></a>
method to do the actual work.</p>
<p>To check the type of an exception, you can simply do:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">use pyo3::exceptions;
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">let err = exceptions::TypeError::py_err(());
</span>err.is_instance::&lt;exceptions::TypeError&gt;(py);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#handling-rust-errors" id="handling-rust-errors">Handling Rust errors</a></h2>
<p>The vast majority of operations in this library will return <a href="https://docs.rs/pyo3/latest/pyo3/prelude/type.PyResult.html"><code>PyResult&lt;T&gt;</code></a>,
which is an alias for the type <code>Result&lt;T, PyErr&gt;</code>.</p>
<p>A <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html"><code>PyErr</code></a> represents a Python exception.
Errors within the PyO3 library are also exposed as Python exceptions.</p>
<p>The PyO3 library handles Python exceptions in two stages. During the first stage, a <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html"><code>PyErr</code></a> instance is
created. At this stage, holding Python's GIL is not required. During the second stage, an actual Python
exception instance is created and set active in the Python interpreter.</p>
<p>In simple cases, for custom errors adding an implementation of <code>std::convert::From&lt;T&gt;</code> trait
for this custom error is enough. <code>PyErr::new</code> accepts an argument in the form
of <code>ToPyObject + 'static</code>. If the <code>'static</code> constraint can not be satisfied or
more complex arguments are required, the
<a href="https://docs.rs/pyo3/latest/pyo3/trait.PyErrArguments.html"><code>PyErrArguments</code></a>
trait can be implemented. In that case, actual exception argument creation is delayed
until a <code>Python</code> object is available.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::{exceptions, PyErr, PyResult};
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct CustomIOError;
</span><span class="boring">
</span><span class="boring">impl Error for CustomIOError {}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for CustomIOError {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
</span><span class="boring">        write!(f, &quot;Oh no!&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bind(_addr: &amp;str) -&gt; Result&lt;(), CustomIOError&gt; {
</span><span class="boring">    Err(CustomIOError)
</span><span class="boring">}
</span>impl std::convert::From&lt;CustomIOError&gt; for PyErr {
    fn from(err: CustomIOError) -&gt; PyErr {
        exceptions::OSError::py_err(err.to_string())
    }
}

fn connect(s: String) -&gt; PyResult&lt;bool&gt; {
    bind(&quot;127.0.0.1:80&quot;)?;
    Ok(true)
}
<span class="boring">}
</span></code></pre></pre>
<p>The code snippet above will raise an <code>OSError</code> in Python if <code>bind()</code> returns a <code>CustomIOError</code>.</p>
<p>The <code>std::convert::From&lt;T&gt;</code> trait is implemented for most of the Rust standard library's error
types so the <code>?</code> operator can be used.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

fn parse_int(s: String) -&gt; PyResult&lt;usize&gt; {
    Ok(s.parse::&lt;usize&gt;()?)
}
<span class="boring">}
</span></code></pre></pre>
<p>The code snippet above will raise a <code>ValueError</code> in Python if <code>String::parse()</code> returns an error.</p>
<h2><a class="header" href="#using-exceptions-defined-in-python-code" id="using-exceptions-defined-in-python-code">Using exceptions defined in Python code</a></h2>
<p>It is possible to use an exception defined in Python code as a native Rust type.
The <code>import_exception!</code> macro allows importing a specific exception class and defines a zero-sized Rust type
for that exception.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::import_exception;

import_exception!(io, UnsupportedOperation);

fn tell(file: PyObject) -&gt; PyResult&lt;u64&gt; {
    use pyo3::exceptions::*;

    let gil = Python::acquire_gil();
    let py = gil.python();

    match file.call_method0(py, &quot;tell&quot;) {
        Err(_) =&gt; Err(UnsupportedOperation::py_err(&quot;not supported: tell&quot;)),
        Ok(x) =&gt; x.extract::&lt;u64&gt;(py),
    }
}

<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/pyo3/latest/pyo3/exceptions/index.html"><code>pyo3::exceptions</code></a>
defines exceptions for several standard library modules.</p>
<h1><a class="header" href="#calling-python-in-rust-code" id="calling-python-in-rust-code">Calling Python in Rust code</a></h1>
<p>These APIs work from Rust whenever you have a <code>Python</code> object handy, whether
PyO3 is built for an extension module or not.</p>
<h2><a class="header" href="#want-to-access-python-apis-then-use-pymoduleimport" id="want-to-access-python-apis-then-use-pymoduleimport">Want to access Python APIs? Then use <code>PyModule::import</code>.</a></h2>
<p><a href="https://pyo3.rs/master/doc/pyo3/types/struct.PyModule.html#method.import"><code>Pymodule::import</code></a> can
be used to get handle to a Python module from Rust. You can use this to import and use any Python
module available in your environment.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;

fn main() -&gt; PyResult&lt;()&gt; {
    let gil = Python::acquire_gil();
    let py = gil.python();
    let builtins = PyModule::import(py, &quot;builtins&quot;)?;
    let total: i32 = builtins.call1(&quot;sum&quot;, (vec![1, 2, 3],))?.extract()?;
    assert_eq!(total, 6);
    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#want-to-run-just-an-expression-then-use-eval" id="want-to-run-just-an-expression-then-use-eval">Want to run just an expression? Then use <code>eval</code>.</a></h2>
<p><a href="https://pyo3.rs/master/doc/pyo3/struct.Python.html#method.eval"><code>Python::eval</code></a> is
a method to execute a <a href="https://docs.python.org/3.7/reference/expressions.html">Python expression</a>
and return the evaluated value as a <code>&amp;PyAny</code> object.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::IntoPyDict;

fn main() -&gt; Result&lt;(), ()&gt; {
    let gil = Python::acquire_gil();
    let py = gil.python();
    let result = py.eval(&quot;[i * 10 for i in range(5)]&quot;, None, None).map_err(|e| {
        e.print_and_set_sys_last_vars(py);
    })?;
    let res: Vec&lt;i64&gt; = result.extract().unwrap();
    assert_eq!(res, vec![0, 10, 20, 30, 40]);
    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#want-to-run-statements-then-use-run" id="want-to-run-statements-then-use-run">Want to run statements? Then use <code>run</code>.</a></h2>
<p><a href="https://pyo3.rs/master/doc/pyo3/struct.Python.html#method.run"><code>Python::run</code></a> is a method to execute one or more
<a href="https://docs.python.org/3.7/reference/simple_stmts.html">Python statements</a>.
This method returns nothing (like any Python statement), but you can get
access to manipulated objects via the <code>locals</code> dict.</p>
<p>You can also use the <a href="https://pyo3.rs/master/doc/pyo3/macro.py_run.html"><code>py_run!</code></a> macro, which is a shorthand for <a href="https://pyo3.rs/master/doc/pyo3/struct.Python.html#method.run"><code>Python::run</code></a>.
Since <a href="https://pyo3.rs/master/doc/pyo3/macro.py_run.html"><code>py_run!</code></a> panics on exceptions, we recommend you use this macro only for
quickly testing your Python extensions.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;
use pyo3::{PyCell, PyObjectProtocol, py_run};
<span class="boring"> fn main() {
</span>#[pyclass]
struct UserData {
    id: u32,
    name: String,
}
#[pymethods]
impl UserData {
    fn as_tuple(&amp;self) -&gt; (u32, String) {
        (self.id, self.name.clone())
    }
}
#[pyproto]
impl PyObjectProtocol for UserData {
    fn __repr__(&amp;self) -&gt; PyResult&lt;String&gt; {
        Ok(format!(&quot;User {}(id: {})&quot;, self.name, self.id))
    }
}
let gil = Python::acquire_gil();
let py = gil.python();
let userdata = UserData {
    id: 34,
    name: &quot;Yu&quot;.to_string(),
};
let userdata = PyCell::new(py, userdata).unwrap();
let userdata_as_tuple = (34, &quot;Yu&quot;);
py_run!(py, userdata userdata_as_tuple, r#&quot;
assert repr(userdata) == &quot;User Yu(id: 34)&quot;
assert userdata.as_tuple() == userdata_as_tuple
&quot;#);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#you-have-a-python-file-or-python-function-then-use-pymodulefrom_code" id="you-have-a-python-file-or-python-function-then-use-pymodulefrom_code">You have a Python file or Python function? Then use <code>PyModule::from_code</code>.</a></h2>
<p><a href="https://pyo3.rs/master/doc/pyo3/types/struct.PyModule.html#method.from_code">PyModule::from_code</a>
can be used to generate a Python module which can then be used just as if it was imported with
<code>PyModule::import</code>.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::{prelude::*, types::{IntoPyDict, PyModule}};
<span class="boring"> fn main() -&gt; PyResult&lt;()&gt; {
</span>let gil = Python::acquire_gil();
let py = gil.python();
let activators = PyModule::from_code(py, r#&quot;
def relu(x):
    &quot;&quot;&quot;see https://en.wikipedia.org/wiki/Rectifier_(neural_networks)&quot;&quot;&quot;
    return max(0.0, x)

def leaky_relu(x, slope=0.01):
    return x if x &gt;= 0 else x * slope
&quot;#, &quot;activators.py&quot;, &quot;activators&quot;)?;

let relu_result: f64 = activators.call1(&quot;relu&quot;, (-1.0,))?.extract()?;
assert_eq!(relu_result, 0.0);

let kwargs = [(&quot;slope&quot;, 0.2)].into_py_dict(py);
let lrelu_result: f64 = activators
    .call(&quot;leaky_relu&quot;, (-1.0,), Some(kwargs))?
    .extract()?;
assert_eq!(lrelu_result, -0.2);
<span class="boring">Ok(()) }
</span></code></pre></pre>
<h1><a class="header" href="#gil-lifetimes-mutability-and-python-object-types" id="gil-lifetimes-mutability-and-python-object-types">GIL lifetimes, mutability and Python object types</a></h1>
<p>On first glance, PyO3 provides a huge number of different types that can be used
to wrap or refer to Python objects.  This page delves into the details and gives
an overview of their intended meaning, with examples when each type is best
used.</p>
<h2><a class="header" href="#mutability-and-rust-types" id="mutability-and-rust-types">Mutability and Rust types</a></h2>
<p>Since Python has no concept of ownership, and works solely with boxed objects,
any Python object can be referenced any number of times, and mutation is allowed
from any reference.</p>
<p>The situation is helped a little by the Global Interpreter Lock (GIL), which
ensures that only one thread can use the Python interpreter and its API at the
same time, while non-Python operations (system calls and extension code) can
unlock the GIL.  (See <a href="parallelism.html">the section on parallelism</a> for how to do
that in PyO3.)</p>
<p>In PyO3, holding the GIL is modeled by acquiring a token of the type
<code>Python&lt;'py&gt;</code>, which serves three purposes:</p>
<ul>
<li>It provides some global API for the Python interpreter, such as
<a href="https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.eval"><code>eval</code></a>.</li>
<li>It can be passed to functions that require a proof of holding the GIL,
such as <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyObject.html#method.clone_ref"><code>PyObject::clone_ref</code></a>.</li>
<li>Its lifetime can be used to create Rust references that implicitly guarantee
holding the GIL, such as <a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyAny.html"><code>&amp;'py PyAny</code></a>.</li>
</ul>
<p>The latter two points are the reason why some APIs in PyO3 require the <code>py: Python</code> argument, while others don't.</p>
<p>The PyO3 API for Python objects is written such that instead of requiring a
mutable Rust reference for mutating operations such as
<a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyList.html#method.append"><code>PyList::append</code></a>, a shared reference (which, in turn, can only
be created through <code>Python&lt;'_&gt;</code> with a GIL lifetime) is sufficient.</p>
<p>However, Rust structs wrapped as Python objects (called <code>pyclass</code> types) usually
<em>do</em> need <code>&amp;mut</code> access.  Due to the GIL, PyO3 <em>can</em> guarantee thread-safe acces
to them, but it cannot statically guarantee uniqueness of <code>&amp;mut</code> references once
an object's ownership has been passed to the Python interpreter, ensuring
references is done at runtime using <code>PyCell</code>, a scheme very similar to
<code>std::cell::RefCell</code>.</p>
<h2><a class="header" href="#object-types" id="object-types">Object types</a></h2>
<h3><a class="header" href="#a-hrefhttpsdocsrspyo3latestpyo3typesstructpyanyhtmlpyanya" id="a-hrefhttpsdocsrspyo3latestpyo3typesstructpyanyhtmlpyanya"><a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyAny.html"><code>PyAny</code></a></a></h3>
<p><strong>Represents:</strong> a Python object of unspecified type, restricted to a GIL
lifetime.  Currently, <code>PyAny</code> can only ever occur as a reference, <code>&amp;PyAny</code>.</p>
<p><strong>Used:</strong> Whenever you want to refer to some Python object and will have the
GIL for the whole duration you need to access that object. For example,
intermediate values and arguments to <code>pyfunction</code>s or <code>pymethod</code>s implemented
in Rust where any type is allowed.</p>
<p>Many general methods for interacting with Python objects are on the <code>PyAny</code> struct,
such as <code>getattr</code>, <code>setattr</code>, and <code>.call</code>.</p>
<p><strong>Conversions:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span>let obj: &amp;PyAny = PyList::empty(py);

// Convert to &amp;ConcreteType using PyAny::downcast
let _: &amp;PyList = obj.downcast().unwrap();

// Convert to PyObject using .into() or .to_object(py)
let _: PyObject = obj.into();

// Convert to Py&lt;PyAny&gt; using .into() or Py::from
let _: Py&lt;PyAny&gt; = obj.into();

// Convert to Py&lt;ConcreteType&gt; using PyAny::extract
let _: Py&lt;PyList&gt; = obj.extract().unwrap();
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#pytuple-pydict-and-many-more" id="pytuple-pydict-and-many-more"><code>PyTuple</code>, <code>PyDict</code>, and many more</a></h3>
<p><strong>Represents:</strong> a native Python object of known type, restricted to a GIL
lifetime just like <code>PyAny</code>.</p>
<p><strong>Used:</strong> Whenever you want to operate with native Python types while holding
the GIL.  Like <code>PyAny</code>, this is the most convenient form to use for function
arguments and intermediate values.</p>
<p>These types all implement <code>Deref&lt;Target = PyAny&gt;</code>, so they all expose the same
methods which can be found on <code>PyAny</code>.</p>
<p>To see all Python types exposed by <code>PyO3</code> you should consult the
<a href="https://pyo3.rs/master/doc/pyo3/types/index.html"><code>pyo3::types</code></a> module.</p>
<p><strong>Conversions:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span>let list = PyList::empty(py);

// Can use methods from PyAny on all Python types due to Deref implementation
let _ = list.repr();

// Rust will convert &amp;PyList etc. to &amp;PyAny automatically due to Deref implementation
let _: &amp;PyAny = list;

// For more explicit &amp;PyAny conversion, use .as_ref()
let _: &amp;PyAny = list.as_ref();

// To convert to PyObject use .into() or .to_object(py)
let _: PyObject = list.into();

// To convert to Py&lt;T&gt; use .into() or Py::from()
let _: Py&lt;PyList&gt; = list.into();
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#pyobject" id="pyobject"><code>PyObject</code></a></h3>
<p><strong>Represents:</strong> a GIL independent reference to a Python object of unspecified
type.</p>
<p><strong>Used:</strong> Whenever you want to carry around references to &quot;some&quot; Python object,
without caring about a GIL lifetime.  For example, storing Python object
references in a Rust struct that outlives the Python-Rust FFI boundary,
or returning objects from functions implemented in Rust back to Python.</p>
<p>Can be cloned using Python reference counts with <code>.clone_ref()</code>.</p>
<p><strong>Conversions:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span>let obj: PyObject = PyList::empty(py).into();

// Convert to &amp;PyAny using AsPyRef::as_ref
let _: &amp;PyAny = obj.as_ref(py);

// Convert to &amp;ConcreteType using PyObject::cast_as
let _: &amp;PyList = obj.cast_as(py).unwrap();

// Convert to Py&lt;ConcreteType&gt; using PyObject::extract
let _: Py&lt;PyList&gt; = obj.extract(py).unwrap();
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#pysometype" id="pysometype"><code>Py&lt;SomeType&gt;</code></a></h3>
<p><strong>Represents:</strong> a GIL independent reference to a Python object of known type.
This can be a Python native type (like <code>PyTuple</code>), or a <code>pyclass</code> type
implemented in Rust.</p>
<p><strong>Used:</strong> Like <code>PyObject</code>, but with a known inner type.</p>
<p><strong>Conversions:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span>let list: Py&lt;PyList&gt; = PyList::empty(py).into();

// Access the native type using AsPyRef::as_ref(py)
// (For #[pyclass] types, as_ref() will return &amp;PyCell&lt;T&gt;)
let _: &amp;PyList = list.as_ref(py);

// Convert to PyObject with .into()
let _: PyObject = list.into();
<span class="boring">}
</span></code></pre></pre>
<p><strong>Note:</strong> <code>PyObject</code> is semantically equivalent to <code>Py&lt;PyAny&gt;</code> and might be
merged with it in the future.</p>
<h3><a class="header" href="#pycellsometype" id="pycellsometype"><code>PyCell&lt;SomeType&gt;</code></a></h3>
<p><strong>Represents:</strong> a reference to a Rust object (instance of <code>PyClass</code>) which is
wrapped in a Python object.  The cell part is an analog to stdlib's
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> to allow access to <code>&amp;mut</code> references.</p>
<p><strong>Used:</strong> for accessing pure-Rust API of the instance (members and functions
taking <code>&amp;SomeType</code> or <code>&amp;mut SomeType</code>) while maintaining the aliasing rules of
Rust references.</p>
<p>Like pyo3's Python native types, <code>PyCell&lt;T&gt;</code> implements <code>Deref&lt;Target = PyAny&gt;</code>,
so it also exposes all of the methods on <code>PyAny</code>.</p>
<p><strong>Conversions:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">#[pyclass] struct MyClass { }
</span><span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span>let cell: &amp;PyCell&lt;MyClass&gt; = PyCell::new(py, MyClass { }).unwrap();

// Obtain PyRef&lt;T&gt; with .try_borrow()
let pr: PyRef&lt;MyClass&gt; = cell.try_borrow().unwrap();
<span class="boring">drop(pr);
</span>
// Obtain PyRefMut&lt;T&gt; with .try_borrow_mut()
let prm: PyRefMut&lt;MyClass&gt; = cell.try_borrow_mut().unwrap();
<span class="boring">drop(prm);
</span>
// Can use methods from PyAny on PyCell&lt;T&gt; due to Deref implementation
let _ = cell.repr();

// Rust will convert &amp;PyCell&lt;T&gt; to &amp;PyAny automatically due to Deref implementation
let _: &amp;PyAny = cell;

// For more explicit &amp;PyAny conversion, use .as_ref()
let any: &amp;PyAny = cell.as_ref();

// To obtain a PyCell&lt;T&gt; from PyAny, use PyAny::downcast
let _: &amp;PyCell&lt;MyClass&gt; = any.downcast().unwrap();
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#pyrefsometype-and-pyrefmutsometype" id="pyrefsometype-and-pyrefmutsometype"><code>PyRef&lt;SomeType&gt;</code> and <code>PyRefMut&lt;SomeType&gt;</code></a></h3>
<p><strong>Represents:</strong> reference wrapper types employed by <code>PyCell</code> to keep track of
borrows, analog to <code>Ref</code> and <code>RefMut</code> used by <code>RefCell</code>.</p>
<p><strong>Used:</strong> while borrowing a <code>PyCell</code>.  They can also be used with <code>.extract()</code>
on types like <code>Py&lt;T&gt;</code> and <code>PyAny</code> to get a reference quickly.</p>
<h2><a class="header" href="#related-traits-and-types" id="related-traits-and-types">Related traits and types</a></h2>
<h3><a class="header" href="#pyclass" id="pyclass"><code>PyClass</code></a></h3>
<p>This trait marks structs defined in Rust that are also usable as Python classes,
usually defined using the <code>#[pyclass]</code> macro.</p>
<h3><a class="header" href="#pynativetype" id="pynativetype"><code>PyNativeType</code></a></h3>
<p>This trait marks structs that mirror native Python types, such as <code>PyList</code>.</p>
<h1><a class="header" href="#parallelism" id="parallelism">Parallelism</a></h1>
<p>CPython has the infamous <a href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock">Global Interpreter Lock</a>, which prevents several threads from executing Python bytecode in parallel. This makes threading in Python a bad fit for <a href="https://stackoverflow.com/questions/868568/">CPU-bound</a> tasks and often forces developers to accept the overhead of multiprocessing.</p>
<p>In PyO3 parallelism can be easily achieved in Rust-only code. Let's take a look at our <a href="https://github.com/PyO3/pyo3/blob/master/examples/word-count/src/lib.rs">word-count</a> example, where we have a <code>search</code> function that utilizes the <a href="https://github.com/nikomatsakis/rayon">rayon</a> crate to count words in parallel.</p>
<pre><code class="language-rust ignore">#[pyfunction]
fn search(contents: &amp;str, needle: &amp;str) -&gt; usize {
    contents
        .par_lines()
        .map(|line| count_line(line, needle))
        .sum()
}
</code></pre>
<p>But let's assume you have a long running Rust function which you would like to execute several times in parallel. For the sake of example let's take a sequential version of the word count:</p>
<pre><code class="language-rust ignore">fn search_sequential(contents: &amp;str, needle: &amp;str) -&gt; usize {
    contents.lines().map(|line| count_line(line, needle)).sum()
}
</code></pre>
<p>To enable parallel execution of this function, the <a href="https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.allow_threads"><code>Python::allow_threads</code></a> method can be used to temporarily release the GIL, thus allowing other Python threads to run. We then have a function exposed to the Python runtime which calls <code>search_sequential</code> inside a closure passed to <a href="https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.allow_threads"><code>Python::allow_threads</code></a> to enable true parallelism:</p>
<pre><code class="language-rust ignore">#[pyfunction]
fn search_sequential_allow_threads(py: Python, contents: &amp;str, needle: &amp;str) -&gt; usize {
    py.allow_threads(|| search_sequential(contents, needle))
}
</code></pre>
<p>Now Python threads can use more than one CPU core, resolving the limitation which usually makes multi-threading in Python only good for IO-bound tasks:</p>
<pre><code class="language-Python">from concurrent.futures import ThreadPoolExecutor
from word_count import search_sequential_allow_threads

executor = ThreadPoolExecutor(max_workers=2)

future_1 = executor.submit(
    word_count.search_sequential_allow_threads, contents, needle
)
future_2 = executor.submit(
    word_count.search_sequential_allow_threads, contents, needle
)
result_1 = future_1.result()
result_2 = future_2.result()
</code></pre>
<h2><a class="header" href="#benchmark" id="benchmark">Benchmark</a></h2>
<p>Let's benchmark the <code>word-count</code> example to verify that we really did unlock parallelism with PyO3.</p>
<p>We are using <code>pytest-benchmark</code> to benchmark four word count functions:</p>
<ol>
<li>Pure Python version</li>
<li>Rust parallel version</li>
<li>Rust sequential version</li>
<li>Rust sequential version executed twice with two Python threads</li>
</ol>
<p>The benchmark script can be found <a href="https://github.com/PyO3/pyo3/blob/master/examples/word-count/tests/test_word_count.py">here</a>, and we can run <code>tox</code> in the <code>word-count</code> folder to benchmark these functions.</p>
<p>While the results of the benchmark of course depend on your machine, the relative results should be similar to this (mid 2020):</p>
<pre><code class="language-ignore">-------------------------------------------------------------------------------------------------- benchmark: 4 tests -------------------------------------------------------------------------------------------------
Name (time in ms)                                          Min                Max               Mean            StdDev             Median               IQR            Outliers       OPS            Rounds  Iterations
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
test_word_count_rust_parallel                           1.7315 (1.0)       4.6495 (1.0)       1.9972 (1.0)      0.4299 (1.0)       1.8142 (1.0)      0.2049 (1.0)         40;46  500.6943 (1.0)         375           1
test_word_count_rust_sequential                         7.3348 (4.24)     10.3556 (2.23)      8.0035 (4.01)     0.7785 (1.81)      7.5597 (4.17)     0.8641 (4.22)         26;5  124.9457 (0.25)        121           1
test_word_count_rust_sequential_twice_with_threads      7.9839 (4.61)     10.3065 (2.22)      8.4511 (4.23)     0.4709 (1.10)      8.2457 (4.55)     0.3927 (1.92)        17;17  118.3274 (0.24)        114           1
test_word_count_python_sequential                      27.3985 (15.82)    45.4527 (9.78)     28.9604 (14.50)    4.1449 (9.64)     27.5781 (15.20)    0.4638 (2.26)          3;5   34.5299 (0.07)         35           1
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</code></pre>
<p>You can see that the Python threaded version is not much slower than the Rust sequential version, which means compared to an execution on a single CPU core the speed has doubled.</p>
<h1><a class="header" href="#debugging" id="debugging">Debugging</a></h1>
<h2><a class="header" href="#macros" id="macros">Macros</a></h2>
<p>PyO3's attributes (<code>#[pyclass]</code>, <code>#[pymodule]</code>, etc.) are <a href="https://doc.rust-lang.org/reference/procedural-macros.html">procedural macros</a>, which means that they rewrite the source of the annotated item. You can view the generated source with the following command, which also expands a few other things:</p>
<pre><code class="language-bash">cargo rustc --profile=check -- -Z unstable-options --pretty=expanded &gt; expanded.rs; rustfmt expanded.rs
</code></pre>
<p>(You might need to install <a href="https://github.com/rust-lang-nursery/rustfmt">rustfmt</a> if you don't already have it.)</p>
<p>You can also debug classic <code>!</code>-macros by adding <code>-Z trace-macros</code>:</p>
<pre><code class="language-bash">cargo rustc --profile=check -- -Z unstable-options --pretty=expanded -Z trace-macros &gt; expanded.rs; rustfmt expanded.rs
</code></pre>
<p>See <a href="https://github.com/dtolnay/cargo-expand">cargo expand</a> for a more elaborate version of those commands.</p>
<h2><a class="header" href="#running-with-valgrind" id="running-with-valgrind">Running with Valgrind</a></h2>
<p>Valgrind is a tool to detect memory management bugs such as memory leaks.</p>
<p>You first need to install a debug build of Python, otherwise Valgrind won't produce usable results. In Ubuntu there's e.g. a <code>python3-dbg</code> package.</p>
<p>Activate an environment with the debug interpreter and recompile. If you're on Linux, use <code>ldd</code> with the name of your binary and check that you're linking e.g. <code>libpython3.6dm.so.1.0</code> instead of <code>libpython3.6m.so.1.0</code>.</p>
<p><a href="https://raw.githubusercontent.com/python/cpython/master/Misc/valgrind-python.supp">Download the suppressions file for cpython</a>.</p>
<p>Run Valgrind with <code>valgrind --suppressions=valgrind-python.supp ./my-command --with-options</code></p>
<h2><a class="header" href="#getting-a-stacktrace" id="getting-a-stacktrace">Getting a stacktrace</a></h2>
<p>The best start to investigate a crash such as an segmentation fault is a backtrace.</p>
<ul>
<li>Link against a debug build of python as described in the previous chapter</li>
<li>Run <code>gdb &lt;my-binary&gt;</code></li>
<li>Enter <code>r</code> to run</li>
<li>After the crash occurred, enter <code>bt</code> or <code>bt full</code> to print the stacktrace</li>
</ul>
<h1><a class="header" href="#advanced-topics" id="advanced-topics">Advanced topics</a></h1>
<h2><a class="header" href="#ffi" id="ffi">FFI</a></h2>
<p>PyO3 exposes much of Python's C API through the <code>ffi</code> module.</p>
<p>The C API is naturally unsafe and requires you to manage reference counts, errors and specific invariants yourself. Please refer to the <a href="https://docs.python.org/3/c-api/">C API Reference Manual</a> and <a href="https://doc.rust-lang.org/nightly/nomicon/ffi.html">The Rustonomicon</a> before using any function from that API.</p>
<h2><a class="header" href="#memory-management" id="memory-management">Memory Management</a></h2>
<p>PyO3's &quot;owned references&quot; (<code>&amp;PyAny</code> etc.) make PyO3 more ergonomic to use by ensuring that their lifetime can never be longer than the duration the Python GIL is held. This means that most of PyO3's API can assume the GIL is held. (If PyO3 could not assume this, every PyO3 API would need to take a <code>Python</code> GIL token to prove that the GIL is held.)</p>
<p>The caveat to these &quot;owned references&quot; is that Rust references do not normally convey ownership (they are always <code>Copy</code>, and cannot implement <code>Drop</code>). Whenever a PyO3 API returns an owned reference, PyO3 stores it internally, so that PyO3 can decrease the reference count just before PyO3 releases the GIL.</p>
<p>For most use cases this behaviour is invisible. Occasionally, however, users may need to clear memory usage sooner than PyO3 usually does. PyO3 exposes this functionality with the  the <code>GILPool</code> struct. When a <code>GILPool</code> is dropped, <em><strong>all</strong></em> owned references created after the <code>GILPool</code> was created will be cleared.</p>
<p>The unsafe function <code>Python::new_pool</code> allows you to create a new <code>GILPool</code>. When doing this, you must be very careful to ensure that once the <code>GILPool</code> is dropped you do not retain access any owned references created after the <code>GILPool</code> was created.</p>
<h2><a class="header" href="#the-nightly-feature" id="the-nightly-feature">The <code>nightly</code> feature</a></h2>
<p>The <code>pyo3/nightly</code> feature needs the nightly Rust compiler. This allows PyO3 to use Rust's unstable specialization feature to apply the following optimizations:</p>
<ul>
<li><code>FromPyObject</code> for <code>Vec</code> and <code>[T;N]</code> can perform a <code>memcpy</code> when the object is a <code>PyBuffer</code></li>
<li><code>ToBorrowedObject</code> can skip a reference count increase when the provided object is a Python native type.</li>
</ul>
<h1><a class="header" href="#building-and-distribution" id="building-and-distribution">Building and Distribution</a></h1>
<h2><a class="header" href="#python-version" id="python-version">Python version</a></h2>
<p>PyO3 uses a build script to determine the Python version and set the correct linker arguments. By default it uses the <code>python3</code> executable. You can override the Python interpreter by setting <code>PYTHON_SYS_EXECUTABLE</code>, e.g., <code>PYTHON_SYS_EXECUTABLE=python3.6</code>.</p>
<h2><a class="header" href="#linking" id="linking">Linking</a></h2>
<p>Different linker arguments must be set for libraries/extension modules and binaries, which includes both standalone binaries and tests. (More specifically, binaries must be told where to find libpython and libraries must not link to libpython for <a href="https://www.python.org/dev/peps/pep-0513/">manylinux</a> compliance).</p>
<p>Since PyO3's build script can't know whether you're building a binary or a library, you have to activate the <code>extension-module</code> feature to get the build options for a library, or it'll default to binary.</p>
<p>If you have e.g. a library crate and a profiling crate alongside, you need to use optional features. E.g. you put the following in the library crate:</p>
<pre><code class="language-toml">[dependencies]
pyo3 = &quot;0.6&quot;

[lib]
name = &quot;hyperjson&quot;
crate-type = [&quot;rlib&quot;, &quot;cdylib&quot;]

[features]
default = [&quot;pyo3/extension-module&quot;]
</code></pre>
<p>And this in the profiling crate:</p>
<pre><code class="language-toml">[dependencies]
my_main_crate = { path = &quot;..&quot;, default-features = false }
pyo3 = &quot;0.6&quot;
</code></pre>
<p>On Linux/macOS you might have to change <code>LD_LIBRARY_PATH</code> to include libpython, while on windows you might need to set <code>LIB</code> to include <code>pythonxy.lib</code> (where x and y are major and minor version), which is normally either in the <code>libs</code> or <code>Lib</code> folder of a Python installation.</p>
<h2><a class="header" href="#distribution" id="distribution">Distribution</a></h2>
<p>There are two ways to distribute your module as a Python package: the old, <a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a>, and the new, <a href="https://github.com/pyo3/maturin">maturin</a>. setuptools-rust needs some configuration files (<code>setup.py</code>, <code>MANIFEST.in</code>, <code>build-wheels.sh</code>, etc.) and external tools (docker, twine). maturin doesn't need any configuration files, however it does not support some functionality of setuptools such as package data (<a href="https://github.com/PyO3/maturin/issues/258">pyo3/maturin#258</a>).</p>
<h2><a class="header" href="#cross-compiling" id="cross-compiling">Cross Compiling</a></h2>
<p>Cross compiling PyO3 modules is relatively straightforward and requires a few pieces of software:</p>
<ul>
<li>A toolchain for your target.</li>
<li>The appropriate options in your Cargo <code>.config</code> for the platform you're targeting and the toolchain you are using.</li>
<li>A Python interpreter that's already been compiled for your target.</li>
<li>The headers that match the above interpreter.</li>
</ul>
<p>See https://github.com/japaric/rust-cross for a primer on cross compiling Rust in general.</p>
<p>After you've obtained the above, you can build a cross compiled PyO3 module by setting a few extra environment variables:</p>
<ul>
<li><code>PYO3_CROSS_INCLUDE_DIR</code>: This variable must be set to the directory containing the headers for the target's Python interpreter.</li>
<li><code>PYO3_CROSS_LIB_DIR</code>: This variable must be set to the directory containing the target's libpython DSO.</li>
</ul>
<p>An example might look like the following (assuming your target's sysroot is at <code>/home/pyo3/cross/sysroot</code> and that your target is <code>armv7</code>):</p>
<pre><code class="language-sh">export PYO3_CROSS_INCLUDE_DIR=&quot;/home/pyo3/cross/sysroot/usr/include&quot;
export PYO3_CROSS_LIB_DIR=&quot;/home/pyo3/cross/sysroot/usr/lib&quot;

cargo build --target armv7-unknown-linux-gnueabihf
</code></pre>
<h1><a class="header" href="#pypy-support" id="pypy-support">PyPy Support</a></h1>
<p>Using PyPy is supported via cpyext.</p>
<p>Support is only provided for building Rust extension for code running under PyPy. This means that PyPy <strong>cannot</strong> be called from rust via cpyext. Note that there some differences in the ffi module between PyPy and CPython.</p>
<p>This is a limitation of cpyext and support for embedding cpyext is not planned.</p>
<p>Compilation against PyPy is done by exporting the <code>PYTHON_SYS_EXECUTABLE</code> to point to a PyPy binary or by compiling in a PyPy virtualenv.</p>
<p>For example, <code>PYTHON_SYS_EXECUTABLE=&quot;/path/to/pypy3&quot; /path/to/pypy3 setup.py install</code></p>
<h2><a class="header" href="#unsupported-features" id="unsupported-features">Unsupported features</a></h2>
<p>These are features currently supported by PyO3, but not yet implemented in cpyext.</p>
<ul>
<li>Complex number functions (<code>_Py_c_sum</code>, <code>_Py_c_sum</code> ..)</li>
<li>Conversion to rust's i128, u128 types.</li>
<li><code>PySequence_Count</code> (which is used to count number of element in array)</li>
<li><code>PyDict_MergeFromSeq2</code> (used in <code>PyDict::from_sequence</code>)</li>
</ul>
<h1><a class="header" href="#frequently-asked-questions--troubleshooting" id="frequently-asked-questions--troubleshooting">Frequently Asked Questions / Troubleshooting</a></h1>
<h2><a class="header" href="#im-experiencing-deadlocks-using-pyo3-with-lazy_static-or-once_cell" id="im-experiencing-deadlocks-using-pyo3-with-lazy_static-or-once_cell">I'm experiencing deadlocks using PyO3 with lazy_static or once_cell!</a></h2>
<p><code>lazy_static</code> and <code>once_cell::sync</code> both use locks to ensure that initialization is performed only by a single thread. Because the Python GIL is an additional lock this can lead to deadlocks in the following way:</p>
<ol>
<li>A thread (thread A) which has acquired the Python GIL starts initialization of a <code>lazy_static</code> value.</li>
<li>The initialization code calls some Python API which temporarily releases the GIL e.g. <code>Python::import</code>.</li>
<li>Another thread (thread B) acquires the Python GIL and attempts to access the same <code>lazy_static</code> value.</li>
<li>Thread B is blocked, because it waits for <code>lazy_static</code>'s initialization to lock to release.</li>
<li>Thread A is blocked, because it waits to re-aquire the GIL which thread B still holds.</li>
<li>Deadlock.</li>
</ol>
<p>PyO3 provides a struct <a href="https://docs.rs/pyo3/latest/pyo3/once_cell/struct.GILOnceCell.html"><code>GILOnceCell</code></a> which works equivalently to <code>OnceCell</code> but relies solely on the Python GIL for thread safety. This means it can be used in place of <code>lazy_static</code> or <code>once_cell</code> where you are experiencing the deadlock described above. See the documentation for <a href="https://docs.rs/pyo3/latest/pyo3/once_cell/struct.GILOnceCell.html"><code>GILOnceCell</code></a> for an example how to use it.</p>
<h2><a class="header" href="#i-cant-run-cargo-test-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-_pyexc_systemerror" id="i-cant-run-cargo-test-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-_pyexc_systemerror">I can't run <code>cargo test</code>: I'm having linker issues like &quot;Symbol not found&quot; or &quot;Undefined reference to _PyExc_SystemError&quot;!</a></h2>
<p>Currently, <a href="https://github.com/PyO3/pyo3/issues/341">#341</a> causes <code>cargo test</code> to fail with linking errors when the <code>extension-module</code> feature is activated. For now you can work around this by making the <code>extension-module</code> feature optional and running the tests with <code>cargo test --no-default-features</code>:</p>
<pre><code class="language-toml">[dependencies.pyo3]
version = &quot;0.11.0&quot;

[features]
extension-module = [&quot;pyo3/extension-module&quot;]
default = [&quot;extension-module&quot;]
</code></pre>
<h1><a class="header" href="#appendix-a-pyo3-and-rust-cpython" id="appendix-a-pyo3-and-rust-cpython">Appendix A: PyO3 and rust-cpython</a></h1>
<p>PyO3 began as fork of <a href="https://github.com/dgrunwald/rust-cpython">rust-cpython</a> when rust-cpython wasn't maintained. Over the time PyO3 has become fundamentally different from rust-cpython.</p>
<p>This chapter is based on the discussion in <a href="https://github.com/PyO3/pyo3/issues/55">PyO3/pyo3#55</a>.</p>
<h2><a class="header" href="#macros-1" id="macros-1">Macros</a></h2>
<p>While rust-cpython has a <code>macro_rules!</code> based dsl for declaring modules and classes, PyO3 uses proc macros. PyO3 also doesn't change your struct and functions so you can still use them as normal Rust functions.</p>
<p><strong>rust-cpython</strong></p>
<pre><code class="language-rust ignore">py_class!(class MyClass |py| {
    data number: i32;
    def __new__(_cls, arg: i32) -&gt; PyResult&lt;MyClass&gt; {
        MyClass::create_instance(py, arg)
    }
    def half(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.number(py) / 2)
    }
});
</code></pre>
<p><strong>pyo3</strong></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass]
struct MyClass {
   num: u32,
}

#[pymethods]
impl MyClass {
    #[new]
    fn new(num: u32) -&gt; Self {
        MyClass { num }
    }

    fn half(&amp;self) -&gt; PyResult&lt;u32&gt; {
        Ok(self.num / 2)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ownership-and-lifetimes" id="ownership-and-lifetimes">Ownership and lifetimes</a></h2>
<p>While in rust-cpython you always own python objects, PyO3 allows efficient <em>borrowed objects</em>
and most APIs are available with references.</p>
<p>Here is an example of the PyList API:</p>
<p><strong>rust-cpython</strong></p>
<pre><code class="language-rust ignore">impl PyList {

   fn new(py: Python) -&gt; PyList {...}

   fn get_item(&amp;self, py: Python, index: isize) -&gt; PyObject {...}
}
</code></pre>
<p><strong>pyo3</strong></p>
<pre><code class="language-rust ignore">impl PyList {

   fn new(py: Python) -&gt; &amp;PyList {...}

   fn get_item(&amp;self, index: isize) -&gt; &amp;PyAny {...}
}
</code></pre>
<p>In PyO3, all object references are bounded by the GIL lifetime.
So the owned Python object is not required, and it is safe to have functions like <code>fn py&lt;'p&gt;(&amp;'p self) -&gt; Python&lt;'p&gt; {}</code>.</p>
<h2><a class="header" href="#error-handling" id="error-handling">Error handling</a></h2>
<p>rust-cpython requires a <code>Python</code> parameter for constructing a <code>PyErr</code>, so error handling ergonomics is pretty bad. It is not possible to use <code>?</code> with Rust errors.</p>
<p>PyO3 on other hand does not require <code>Python</code> for constructing a <code>PyErr</code>, it is only required if you want to raise an exception in Python with the <code>PyErr::restore()</code> method. Due to various <code>std::convert::From&lt;E&gt; for PyErr</code> implementations for Rust standard error types <code>E</code>, propagating <code>?</code> is supported automatically.</p>
<h1><a class="header" href="#appendix-b-migrating-from-older-pyo3-versions" id="appendix-b-migrating-from-older-pyo3-versions">Appendix B: Migrating from older PyO3 versions</a></h1>
<p>This guide can help you upgrade code through breaking changes from one PyO3 version to the next.
For a detailed list of all changes, see <a href="https://github.com/PyO3/pyo3/blob/master/CHANGELOG.md">CHANGELOG.md</a></p>
<h2><a class="header" href="#from-010-to-011" id="from-010-to-011">from 0.10.* to 0.11</a></h2>
<h3><a class="header" href="#stable-rust" id="stable-rust">Stable Rust</a></h3>
<p>PyO3 now supports the stable Rust toolchain. The minimum required version is 1.39.0.</p>
<h3><a class="header" href="#pyclass-structs-must-now-be-send" id="pyclass-structs-must-now-be-send"><code>#[pyclass]</code> structs must now be <code>Send</code></a></h3>
<p>Because <code>#[pyclass]</code> structs can be sent between threads by the Python interpreter, they must implement
<code>Send</code> to guarantee thread safety. This bound was added in PyO3 <code>0.11.0</code>.</p>
<p>This may &quot;break&quot; some code which previously was accepted, even though it was unsound. To resolve this,
consider using types like <code>Arc</code> instead of <code>Rc</code>, <code>Mutex</code> instead of <code>RefCell</code>, and add <code>Send</code> to any
boxed closures stored inside the <code>#[pyclass]</code>.</p>
<p>Before:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use std::rc::Rc;
use std::cell::RefCell;

#[pyclass]
struct NotThreadSafe {
    shared_bools: Rc&lt;RefCell&lt;Vec&lt;bool&gt;&gt;&gt;,
    closure: Box&lt;Fn()&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use std::sync::{Arc, Mutex};

#[pyclass]
struct ThreadSafe {
    shared_bools: Arc&lt;Mutex&lt;Vec&lt;bool&gt;&gt;&gt;,
    closure: Box&lt;Fn() + Send&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Or in situations where you cannot change your <code>#[pyclass]</code> to automatically implement <code>Send</code>
(e.g., when it contains a raw pointer), you can use <code>unsafe impl Send</code>.
In such cases, care should be taken to ensure the struct is actually thread safe.
See <a href="ttps://doc.rust-lang.org/nomicon/send-and-sync.html">the Rustnomicon</a> for more.</p>
<h3><a class="header" href="#all-pyobject-and-pyt-methods-now-take-python-as-an-argument" id="all-pyobject-and-pyt-methods-now-take-python-as-an-argument">All <code>PyObject</code> and <code>Py&lt;T&gt;</code> methods now take <code>Python</code> as an argument</a></h3>
<p>Previously, a few methods such as <code>Object::get_refcnt</code> did not take <code>Python</code> as an argument (to
ensure that the Python GIL was held by the current thread). Technically, this was not sound.
To migrate, just pass a <code>py</code> argument to any calls to these methods.</p>
<p>Before:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

let gil = Python::acquire_gil();
let py = gil.python();

py.None().get_refcnt();
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

let gil = Python::acquire_gil();
let py = gil.python();

py.None().get_refcnt(py);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#from-09-to-010" id="from-09-to-010">from 0.9.* to 0.10</a></h2>
<h3><a class="header" href="#objectprotocol-is-removed" id="objectprotocol-is-removed"><code>ObjectProtocol</code> is removed</a></h3>
<p>All methods are moved to <a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyAny.html"><code>PyAny</code></a>.
And since now all native types (e.g., <code>PyList</code>) implements <code>Deref&lt;Target=PyAny&gt;</code>,
all you need to do is remove <code>ObjectProtocol</code> from your code.
Or if you use <code>ObjectProtocol</code> by <code>use pyo3::prelude::*</code>, you have to do nothing.</p>
<p>Before:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::ObjectProtocol;

let gil = pyo3::Python::acquire_gil();
let obj = gil.python().eval(&quot;lambda: 'Hi :)'&quot;, None, None).unwrap();
let hi: &amp;pyo3::types::PyString = obj.call0().unwrap().downcast().unwrap();
assert_eq!(hi.len().unwrap(), 5);
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let gil = pyo3::Python::acquire_gil();
let obj = gil.python().eval(&quot;lambda: 'Hi :)'&quot;, None, None).unwrap();
let hi: &amp;pyo3::types::PyString = obj.call0().unwrap().downcast().unwrap();
assert_eq!(hi.len().unwrap(), 5);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#no-featurespecialization-in-user-code" id="no-featurespecialization-in-user-code">No <code>#![feature(specialization)]</code> in user code</a></h3>
<p>While PyO3 itself still requires specialization and nightly Rust,
now you don't have to use <code>#![feature(specialization)]</code> in your crate.</p>
<h2><a class="header" href="#from-08-to-09" id="from-08-to-09">from 0.8.* to 0.9</a></h2>
<h3><a class="header" href="#new-interface" id="new-interface"><code>#[new]</code> interface</a></h3>
<p><a href="https://docs.rs/pyo3/0.8.5/pyo3/type_object/struct.PyRawObject.html"><code>PyRawObject</code></a>
is now removed and our syntax for constructors has changed.</p>
<p>Before:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
   #[new]
   fn new(obj: &amp;PyRawObject) {
       obj.init(MyClass { })
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
   #[new]
   fn new() -&gt; Self {
       MyClass {}
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Basically you can return <code>Self</code> or <code>Result&lt;Self&gt;</code> directly.
For more, see <a href="https://pyo3.rs/master/class.html#constructor">the constructor section</a> of this guide.</p>
<h3><a class="header" href="#pycell" id="pycell">PyCell</a></h3>
<p>PyO3 0.9 introduces <a href="https://docs.rs/pyo3/latest/pyo3/pycell/struct.PyCell.html"><code>PyCell</code></a>, which is a <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>-like object wrapper
for ensuring Rust's rules regarding aliasing of references are upheld.
For more detail, see the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#the-rules-of-references">Rust Book's section on Rust's rules of references</a></p>
<p>For <code>#[pymethods]</code> or <code>#[pyfunction]</code>s, your existing code should continue to work without any change.
Python exceptions will automatically be raised when your functions are used in a way which breaks Rust's
rules of references.</p>
<p>Here is an example.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct Names {
    names: Vec&lt;String&gt;
}

#[pymethods]
impl Names {
    #[new]
    fn new() -&gt; Self {
        Names { names: vec![] }
    }
    fn merge(&amp;mut self, other: &amp;mut Names) {
        self.names.append(&amp;mut other.names)
    }
}
<span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">let names = PyCell::new(py, Names::new()).unwrap();
</span><span class="boring">let borrow_mut_err = py.get_type::&lt;pyo3::pycell::PyBorrowMutError&gt;();
</span><span class="boring">pyo3::py_run!(py, names borrow_mut_err, r&quot;
</span><span class="boring">try:
</span><span class="boring">   names.merge(names)
</span><span class="boring">   assert False, 'Unreachable'
</span><span class="boring">except RuntimeError as e:
</span><span class="boring">   isinstance(e, borrow_mut_err)
</span><span class="boring">&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p><code>Names</code> has a <code>merge</code> method, which takes <code>&amp;mut self</code> and another argument of type <code>&amp;mut Self</code>.
Given this <code>#[pyclass]</code>, calling <code>names.merge(names)</code> in Python raises
a <a href="https://docs.rs/pyo3/latest/pyo3/pycell/struct.PyBorrowMutError.html"><code>PyBorrowMutError</code></a> exception, since it requires two mutable borrows of <code>names</code>.</p>
<p>However, for <code>#[pyproto]</code> and some functions, you need to manually fix the code.</p>
<h4><a class="header" href="#object-creation" id="object-creation">Object creation</a></h4>
<p>In 0.8 object creation was done with <code>PyRef::new</code> and <code>PyRefMut::new</code>.
In 0.9 these have both been removed.
To upgrade code, please use
<a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyCell.html#method.new"><code>PyCell::new</code></a> instead.
If you need <a href="https://docs.rs/pyo3/latest/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> or <a href="https://docs.rs/pyo3/latest/pyo3/pycell/struct.PyRef.html"><code>PyRefMut</code></a>, just call <code>.borrow()</code> or <code>.borrow_mut()</code>
on the newly-created <code>PyCell</code>.</p>
<p>Before:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>let gil = Python::acquire_gil();
let py = gil.python();
let obj_ref = PyRef::new(py, MyClass {}).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>let gil = Python::acquire_gil();
let py = gil.python();
let obj = PyCell::new(py, MyClass {}).unwrap();
let obj_ref = obj.borrow();
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#object-extraction" id="object-extraction">Object extraction</a></h4>
<p>For <code>PyClass</code> types <code>T</code>, <code>&amp;T</code> and <code>&amp;mut T</code> no longer have <a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> implementations.
Instead you should extract <code>PyRef&lt;T&gt;</code> or <code>PyRefMut&lt;T&gt;</code>, respectively.
If <code>T</code> implements <code>Clone</code>, you can extract <code>T</code> itself.
In addition, you can also extract <code>&amp;PyCell&lt;T&gt;</code>, though you rarely need it.</p>
<p>Before:</p>
<pre><code class="language-ignore">let obj: &amp;PyAny = create_obj();
let obj_ref: &amp;MyClass = obj.extract().unwrap();
let obj_ref_mut: &amp;mut MyClass = obj.extract().unwrap();
</code></pre>
<p>After:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::IntoPyDict;
</span><span class="boring">#[pyclass] #[derive(Clone)] struct MyClass {}
</span><span class="boring">#[pymethods] impl MyClass { #[new]fn new() -&gt; Self { MyClass {} }}
</span><span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">let typeobj = py.get_type::&lt;MyClass&gt;();
</span><span class="boring">let d = [(&quot;c&quot;, typeobj)].into_py_dict(py);
</span><span class="boring">let create_obj = || py.eval(&quot;c()&quot;, None, Some(d)).unwrap();
</span>let obj: &amp;PyAny = create_obj();
let obj_cell: &amp;PyCell&lt;MyClass&gt; = obj.extract().unwrap();
let obj_cloned: MyClass = obj.extract().unwrap(); // extracted by cloning the object
{
    let obj_ref: PyRef&lt;MyClass&gt; = obj.extract().unwrap();
    // we need to drop obj_ref before we can extract a PyRefMut due to Rust's rules of references
}
let obj_ref_mut: PyRefMut&lt;MyClass&gt; = obj.extract().unwrap();
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#pyproto" id="pyproto"><code>#[pyproto]</code></a></h4>
<p>Most of the arguments to methods in <code>#[pyproto]</code> impls require a
<a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> implementation.
So if your protocol methods take <code>&amp;T</code> or <code>&amp;mut T</code> (where <code>T: PyClass</code>),
please use <a href="https://docs.rs/pyo3/latest/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> or <a href="https://docs.rs/pyo3/latest/pyo3/pycell/struct.PyRef.html"><code>PyRefMut</code></a> instead.</p>
<p>Before:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::class::PySequenceProtocol;
</span>#[pyclass]
struct ByteSequence {
    elements: Vec&lt;u8&gt;,
}
#[pyproto]
impl PySequenceProtocol for ByteSequence {
    fn __concat__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        let mut elements = self.elements.clone();
        elements.extend_from_slice(&amp;other.elements);
        Ok(Self { elements })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::class::PySequenceProtocol;
</span>#[pyclass]
struct ByteSequence {
    elements: Vec&lt;u8&gt;,
}
#[pyproto]
impl PySequenceProtocol for ByteSequence {
    fn __concat__(&amp;self, other: PyRef&lt;'p, Self&gt;) -&gt; PyResult&lt;Self&gt; {
        let mut elements = self.elements.clone();
        elements.extend_from_slice(&amp;other.elements);
        Ok(Self { elements })
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#using-in-python-a-rust-function-with-trait-bounds" id="using-in-python-a-rust-function-with-trait-bounds">Using in Python a Rust function with trait bounds</a></h1>
<p>PyO3 allows for easy conversion from Rust to Python for certain functions and classes (see the <a href="https://pyo3.rs/master/conversions.html">conversion table</a>).
However, it is not always straightforward to convert Rust code that requires a given trait implementation as an argument.</p>
<p>This tutorial explains how to convert a Rust function that takes a trait as argument for use in Python with classes implementing the same methods as the trait.</p>
<p>Why is this useful?</p>
<h3><a class="header" href="#pros" id="pros">Pros</a></h3>
<ul>
<li>Make your Rust code available to Python users</li>
<li>Code complex algorithms in Rust with the help of the borrow checker</li>
</ul>
<h3><a class="header" href="#cons" id="cons">Cons</a></h3>
<ul>
<li>Not as fast as native Rust (type conversion has to be performed and one part of the code runs in Python)</li>
<li>You need to adapt your code to expose it</li>
</ul>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>Let's work with the following basic example of an implementation of a optimization solver operating on a given model.</p>
<p>Let's say we have a function <code>solve</code> that operates on a model and mutates its state.
The argument of the function can be any model that implements the <code>Model</code> trait :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Model {
  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
  fn compute(&amp;mut self);
  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
}

pub fn solve&lt;T: Model&gt;(model: &amp;mut T) {
  println!(&quot;Magic solver that mutates the model into a resolved state&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's assume we have the following constraints:</p>
<ul>
<li>We cannot change that code as it runs on many Rust models.</li>
<li>We also have many Python models that cannot be solved as this solver is not available in that language.
Rewriting it in Python would be cumbersome and error-prone, as everything is already available in Rust.</li>
</ul>
<p>How could we expose this solver to Python thanks to PyO3 ?</p>
<h2><a class="header" href="#implementation-of-the-trait-bounds-for-the-python-class" id="implementation-of-the-trait-bounds-for-the-python-class">Implementation of the trait bounds for the Python class</a></h2>
<p>If a Python class implements the same three methods as the <code>Model</code> trait, it seems logical it could be adapted to use the solver.
However, it is not possible to pass a <code>PyObject</code> to it as it does not implement the Rust trait (even if the Python model has the required methods).</p>
<p>In order to implement the trait, we must write a wrapper around the calls in Rust to the Python model.
The method signatures must be the same as the trait, keeping in mind that the Rust trait cannot be changed for the purpose of making the code available in Python.</p>
<p>The Python model we want to expose is the following one, which already contains all the required methods:</p>
<pre><code class="language-python">class Model:
    def set_variables(self, inputs):
        self.inputs = inputs
    def compute(self):
        self.results = [elt**2 - 3 for elt in self.inputs]
    def get_results(self):
        return self.results
</code></pre>
<p>The following wrapper will call the Python model from Rust, using a struct to hold the model as a <code>PyAny</code> object:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::types::PyAny;

<span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span>
struct UserModel {
    model: Py&lt;PyAny&gt;,
}

impl Model for UserModel {
    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
        println!(&quot;Rust calling Python to set the variables&quot;);
        let gil = Python::acquire_gil();
        let py = gil.python();
        let values: Vec&lt;f64&gt; = var.clone();
        let list: PyObject = values.into_py(py);
        let py_model = self.model.as_ref(py);
        py_model
            .call_method(&quot;set_variables&quot;, (list,), None)
            .unwrap();
    }

    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Rust calling Python to get the results&quot;);
        let gil = Python::acquire_gil();
        let py = gil.python();
        self
            .model
            .as_ref(py)
            .call_method(&quot;get_results&quot;, (), None)
            .unwrap()
            .extract()
            .unwrap()
    }

    fn compute(&amp;mut self) {
        println!(&quot;Rust calling Python to perform the computation&quot;);
        let gil = Python::acquire_gil();
        let py = gil.python();
        self.model
            .as_ref(py)
            .call_method(&quot;compute&quot;, (), None)
            .unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now that this bit is implemented, let's expose the model wrapper to Python.
Let's add the PyO3 annotations and add a constructor:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyAny;
</span>
#[pyclass]
struct UserModel {
    model: Py&lt;PyAny&gt;,
}

#[pymodule]
fn trait_exposure(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;UserModel&gt;()?;
    Ok(())
}

#[pymethods]
impl UserModel {
    #[new]
    pub fn new(model: Py&lt;PyAny&gt;) -&gt; Self {
        UserModel { model }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we add the PyO3 annotations to the trait implementation:</p>
<pre><code class="language-rust ignore">#[pymethods]
impl Model for UserModel {
  // the previous trait implementation
}
</code></pre>
<p>However, the previous code will not compile. The compilation error is the following one:
<code>error: #[pymethods] cannot be used on trait impl blocks</code></p>
<p>That's a bummer!
However, we can write a second wrapper around these functions to call them directly.
This wrapper will also perform the type conversions between Python and Rust.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyAny;
</span><span class="boring">
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct UserModel {
</span><span class="boring">    model: Py&lt;PyAny&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Model for UserModel {
</span><span class="boring"> fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
</span><span class="boring">     println!(&quot;Rust calling Python to set the variables&quot;);
</span><span class="boring">     let gil = Python::acquire_gil();
</span><span class="boring">     let py = gil.python();
</span><span class="boring">     let values: Vec&lt;f64&gt; = var.clone();
</span><span class="boring">     let list: PyObject = values.into_py(py);
</span><span class="boring">     let py_model = self.model.as_ref(py);
</span><span class="boring">     py_model
</span><span class="boring">         .call_method(&quot;set_variables&quot;, (list,), None)
</span><span class="boring">         .unwrap();
</span><span class="boring"> }
</span><span class="boring">
</span><span class="boring"> fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
</span><span class="boring">     println!(&quot;Rust calling Python to get the results&quot;);
</span><span class="boring">     let gil = Python::acquire_gil();
</span><span class="boring">     let py = gil.python();
</span><span class="boring">     self
</span><span class="boring">         .model
</span><span class="boring">         .as_ref(py)
</span><span class="boring">         .call_method(&quot;get_results&quot;, (), None)
</span><span class="boring">         .unwrap()
</span><span class="boring">         .extract()
</span><span class="boring">         .unwrap()
</span><span class="boring"> }
</span><span class="boring">
</span><span class="boring"> fn compute(&amp;mut self) {
</span><span class="boring">     println!(&quot;Rust calling Python to perform the computation&quot;);
</span><span class="boring">     let gil = Python::acquire_gil();
</span><span class="boring">     let py = gil.python();
</span><span class="boring">     self.model
</span><span class="boring">         .as_ref(py)
</span><span class="boring">         .call_method(&quot;compute&quot;, (), None)
</span><span class="boring">         .unwrap();
</span><span class="boring"> }
</span><span class="boring">}
</span>
#[pymethods]
impl UserModel {
    pub fn set_variables(&amp;mut self, var: Vec&lt;f64&gt;) -&gt; PyResult&lt;()&gt; {
        println!(&quot;Set variables from Python calling Rust&quot;);
        Model::set_variables(self, &amp;var);
        Ok(())
    }

    pub fn get_results(&amp;mut self) -&gt; PyResult&lt;Vec&lt;f64&gt;&gt; {
        println!(&quot;Get results from Python calling Rust&quot;);
        let results = Model::get_results(self);
        let gil = Python::acquire_gil();
        let py = gil.python();
        let py_results = results.into_py(py);
        Ok(py_results)
    }

    pub fn compute(&amp;mut self) -&gt; PyResult&lt;()&gt; {
        println!(&quot;Compute from Python calling Rust&quot;);
        Model::compute(self);
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This wrapper handles the type conversion between the PyO3 requirements and the trait.
In order to meet PyO3 requirements, this wrapper must:</p>
<ul>
<li>return an object of type <code>PyResult</code></li>
<li>use only values, not references in the method signatures</li>
</ul>
<p>Let's run the file python file:</p>
<pre><code class="language-python">class Model:
    def set_variables(self, inputs):
        self.inputs = inputs
    def compute(self):
        self.results = [elt**2 - 3 for elt in self.inputs]
    def get_results(self):
        return self.results

if __name__==&quot;__main__&quot;:
  import trait_exposure

  myModel = Model()
  my_rust_model = trait_exposure.UserModel(myModel)
  my_rust_model.set_variables([2.0])
  print(&quot;Print value from Python: &quot;, myModel.inputs)
  my_rust_model.compute()
  print(&quot;Print value from Python through Rust: &quot;, my_rust_model.get_results())
  print(&quot;Print value directly from Python: &quot;, myModel.get_results())
</code></pre>
<p>This outputs:</p>
<pre><code class="language-block">Set variables from Python calling Rust
Set variables from Rust calling Python
Print value from Python:  [2.0]
Compute from Python calling Rust
Compute from Rust calling Python
Get results from Python calling Rust
Get results from Rust calling Python
Print value from Python through Rust:  [1.0]
Print value directly from Python:  [1.0]
</code></pre>
<p>We have now successfully exposed a Rust model that implements the <code>Model</code> trait to Python!</p>
<p>We will now expose the <code>solve</code> function, but before, let's talk about types errors.</p>
<h2><a class="header" href="#type-errors-in-python" id="type-errors-in-python">Type errors in Python</a></h2>
<p>What happens if you have type errors when using Python and how can you improve the error messages?</p>
<h3><a class="header" href="#wrong-types-in-python-function-arguments" id="wrong-types-in-python-function-arguments">Wrong types in Python function arguments</a></h3>
<p>Let's assume in the first case that you will use in your Python file <code>my_rust_model.set_variables(2.0)</code> instead of <code>my_rust_model.set_variables([2.0])</code>.</p>
<p>The Rust signature expects a vector, which corresponds to a list in Python.
What happens if instead of a vector, we pass a single value ?</p>
<p>At the execution of Python, we get :</p>
<pre><code class="language-block">File &quot;main.py&quot;, line 15, in &lt;module&gt;
   my_rust_model.set_variables(2)
TypeError
</code></pre>
<p>It is a type error and Python points to it, so it's easy to identify and solve.</p>
<h3><a class="header" href="#wrong-types-in-python-method-signatures" id="wrong-types-in-python-method-signatures">Wrong types in Python method signatures</a></h3>
<p>Let's assume now that the return type of one of the methods of our Model class is wrong, for example the <code>get_results</code> method that is expected to return a <code>Vec&lt;f64&gt;</code> in Rust, a list in Python.</p>
<pre><code class="language-python">class Model:
    def set_variables(self, inputs):
        self.inputs = inputs
    def compute(self):
        self.results = [elt**2 -3 for elt in self.inputs]
    def get_results(self):
        return self.results[0]
        #return self.results &lt;-- this is the expected output
</code></pre>
<p>This call results in the following panic:</p>
<pre><code class="language-block">pyo3_runtime.PanicException: called `Result::unwrap()` on an `Err` value: PyErr { type: Py(0x10dcf79f0, PhantomData) }
</code></pre>
<p>This error code is not helpful for a Python user that does not know anything about Rust, or someone that does not know PyO3 was used to interface the Rust code.</p>
<p>However, as we are responsible for making the Rust code available to Python, we can do something about it.</p>
<p>The issue is that we called <code>unwrap</code> anywhere we could, and therefore any panic from PyO3 will be directly forwarded to the end user.</p>
<p>Let's modify the code performing the type conversion to give a helpful error message to the Python user:</p>
<p>We used in our <code>get_results</code> method the following call that performs the type conversion:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyAny;
</span><span class="boring">
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct UserModel {
</span><span class="boring">    model: Py&lt;PyAny&gt;,
</span><span class="boring">}
</span>
impl Model for UserModel {
  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
    println!(&quot;Get results from Rust calling Python&quot;);
    let gil = Python::acquire_gil();
    let py = gil.python();
    self
        .model
        .as_ref(py)
        .call_method(&quot;get_results&quot;, (), None)
        .unwrap()
        .extract()
        .unwrap()
    }
<span class="boring"> fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
</span><span class="boring">     println!(&quot;Rust calling Python to set the variables&quot;);
</span><span class="boring">     let gil = Python::acquire_gil();
</span><span class="boring">     let py = gil.python();
</span><span class="boring">     let values: Vec&lt;f64&gt; = var.clone();
</span><span class="boring">     let list: PyObject = values.into_py(py);
</span><span class="boring">     let py_model = self.model.as_ref(py);
</span><span class="boring">     py_model
</span><span class="boring">         .call_method(&quot;set_variables&quot;, (list,), None)
</span><span class="boring">         .unwrap();
</span><span class="boring"> }
</span><span class="boring">
</span><span class="boring"> fn compute(&amp;mut self) {
</span><span class="boring">     println!(&quot;Rust calling Python to perform the computation&quot;);
</span><span class="boring">     let gil = Python::acquire_gil();
</span><span class="boring">     let py = gil.python();
</span><span class="boring">     self.model
</span><span class="boring">         .as_ref(py)
</span><span class="boring">         .call_method(&quot;compute&quot;, (), None)
</span><span class="boring">         .unwrap();
</span><span class="boring"> }
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>Let's break it down in order to perform better error handling:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyAny;
</span><span class="boring">
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct UserModel {
</span><span class="boring">    model: Py&lt;PyAny&gt;,
</span><span class="boring">}
</span>
impl Model for UserModel {
  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
      println!(&quot;Get results from Rust calling Python&quot;);
      let gil = Python::acquire_gil();
      let py = gil.python();
      let py_result: &amp;PyAny = self
          .model
          .as_ref(py)
          .call_method(&quot;get_results&quot;, (), None)
          .unwrap();

      if py_result.get_type().name() != &quot;list&quot; {
          panic!(&quot;Expected a list for the get_results() method signature, got {}&quot;, py_result.get_type().name());
      }
      py_result.extract().unwrap()
  }
<span class="boring"> fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
</span><span class="boring">     println!(&quot;Rust calling Python to set the variables&quot;);
</span><span class="boring">     let gil = Python::acquire_gil();
</span><span class="boring">     let py = gil.python();
</span><span class="boring">     let values: Vec&lt;f64&gt; = var.clone();
</span><span class="boring">     let list: PyObject = values.into_py(py);
</span><span class="boring">     let py_model = self.model.as_ref(py);
</span><span class="boring">     py_model
</span><span class="boring">         .call_method(&quot;set_variables&quot;, (list,), None)
</span><span class="boring">         .unwrap();
</span><span class="boring"> }
</span><span class="boring">
</span><span class="boring"> fn compute(&amp;mut self) {
</span><span class="boring">     println!(&quot;Rust calling Python to perform the computation&quot;);
</span><span class="boring">     let gil = Python::acquire_gil();
</span><span class="boring">     let py = gil.python();
</span><span class="boring">     self.model
</span><span class="boring">         .as_ref(py)
</span><span class="boring">         .call_method(&quot;compute&quot;, (), None)
</span><span class="boring">         .unwrap();
</span><span class="boring"> }
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>By doing so, you catch the result of the Python computation and check its type in order to be able to deliver a better error message before performing the unwrapping.</p>
<p>Of course, it does not cover all the possible wrong outputs:
the user could return a list of strings instead of a list of floats.
In this case, a runtime panic would still occur due to PyO3, but with an error message much more difficult to decipher for non-rust user.</p>
<p>It is up to the developer exposing the rust code to decide how much effort to invest into Python type error handling and improved error messages.</p>
<h2><a class="header" href="#the-final-code" id="the-final-code">The final code</a></h2>
<p>Now let's expose the <code>solve()</code> function to make it available from Python.</p>
<p>It is not possible to directly expose the <code>solve</code> function to Python, as the type conversion cannot be performed.
It requires an object implementing the <code>Model</code> trait as input.</p>
<p>However, the <code>UserModel</code> already implements this trait.
Because of this, we can write a function wrapper that takes the <code>UserModel</code>--which has already been exposed to Python--as an argument in order to call the core function <code>solve</code>.</p>
<p>It is also required to make the struct public.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::wrap_pyfunction;
use pyo3::types::PyAny;

pub trait Model {
    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;);
    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
    fn compute(&amp;mut self);
}

pub fn solve&lt;T: Model&gt;(model: &amp;mut T) {
  println!(&quot;Magic solver that mutates the model into a resolved state&quot;);
}

#[pyfunction]
#[name = &quot;solve&quot;]
pub fn solve_wrapper(model: &amp;mut UserModel) {
    solve(model);
}

#[pyclass]
pub struct UserModel {
    model: Py&lt;PyAny&gt;,
}

#[pymodule]
fn trait_exposure(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;UserModel&gt;()?;
    m.add_wrapped(wrap_pyfunction!(solve_wrapper)).unwrap();
    Ok(())
}

#[pymethods]
impl UserModel {
    #[new]
    pub fn new(model: Py&lt;PyAny&gt;) -&gt; Self {
        UserModel { model }
    }

    pub fn set_variables(&amp;mut self, var: Vec&lt;f64&gt;) -&gt; PyResult&lt;()&gt; {
        println!(&quot;Set variables from Python calling Rust&quot;);
        Model::set_variables(self, &amp;var);
        Ok(())
    }

    pub fn get_results(&amp;mut self) -&gt; PyResult&lt;Vec&lt;f64&gt;&gt; {
        println!(&quot;Get results from Python calling Rust&quot;);
        let results = Model::get_results(self);
        let gil = Python::acquire_gil();
        let py = gil.python();
        let py_results = results.into_py(py);
        Ok(py_results)
    }

    pub fn compute(&amp;mut self) -&gt; PyResult&lt;()&gt; {
        Model::compute(self);
        Ok(())
    }
}

impl Model for UserModel {
    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
        println!(&quot;Set variables from Rust calling Python&quot;);
        let gil = Python::acquire_gil();
        let py = gil.python();
        let values: Vec&lt;f64&gt; = var.clone();
        let list: PyObject = values.into_py(py);
        let py_model = self.model.as_ref(py);
        py_model
            .call_method(&quot;set_variables&quot;, (list,), None)
            .unwrap();
    }

    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Get results from Rust calling Python&quot;);
        let gil = Python::acquire_gil();
        let py = gil.python();
        let py_result: &amp;PyAny = self
            .model
            .as_ref(py)
            .call_method(&quot;get_results&quot;, (), None)
            .unwrap();

        if py_result.get_type().name() != &quot;list&quot; {
            panic!(&quot;Expected a list for the get_results() method signature, got {}&quot;, py_result.get_type().name());
        }
        py_result.extract().unwrap()
    }

    fn compute(&amp;mut self) {
        println!(&quot;Compute from Rust calling Python&quot;);
        let gil = Python::acquire_gil();
        let py = gil.python();
        self.model
            .as_ref(py)
            .call_method(&quot;compute&quot;, (), None)
            .unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
