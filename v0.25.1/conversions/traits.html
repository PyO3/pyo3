<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Conversion traits - PyO3 user guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="PyO3 user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/tabs.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PyO3 user guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/PyO3/pyo3/tree/main/guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/PyO3/pyo3/edit/main/guide/src/conversions/traits.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="conversion-traits"><a class="header" href="#conversion-traits">Conversion traits</a></h2>
<p>PyO3 provides some handy traits to convert between Python types and Rust types.</p>
<h3 id="extract-and-the-frompyobject-trait"><a class="header" href="#extract-and-the-frompyobject-trait"><code>.extract()</code> and the <code>FromPyObject</code> trait</a></h3>
<p>The easiest way to convert a Python object to a Rust value is using
<code>.extract()</code>.  It returns a <code>PyResult</code> with a type error if the conversion
fails, so usually you will use something like</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let list = PyList::new(py, b"foo")?;
</span>let v: Vec&lt;i32&gt; = list.extract()?;
<span class="boring">        assert_eq!(&amp;v, &amp;[102, 111, 111]);
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>This method is available for many Python object types, and can produce a wide
variety of Rust types, which you can check out in the implementor list of
<a href="https://docs.rs/pyo3/0.25.1/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a>.</p>
<p><a href="https://docs.rs/pyo3/0.25.1/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> is also implemented for your own Rust types wrapped as Python
objects (see <a href="../class.html">the chapter about classes</a>).  There, in order to both be
able to operate on mutable references <em>and</em> satisfy Rust's rules of non-aliasing
mutable references, you have to extract the PyO3 reference wrappers <a href="https://docs.rs/pyo3/0.25.1/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a>
and <a href="https://docs.rs/pyo3/0.25.1/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a>.  They work like the reference wrappers of
<code>std::cell::RefCell</code> and ensure (at runtime) that Rust borrows are allowed.</p>
<h4 id="deriving-frompyobject"><a class="header" href="#deriving-frompyobject">Deriving <a href="https://docs.rs/pyo3/0.25.1/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a></a></h4>
<p><a href="https://docs.rs/pyo3/0.25.1/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> can be automatically derived for many kinds of structs and enums
if the member types themselves implement <code>FromPyObject</code>. This even includes members
with a generic type <code>T: FromPyObject</code>. Derivation for empty enums, enum variants and
structs is not supported.</p>
<h4 id="deriving-frompyobject-for-structs"><a class="header" href="#deriving-frompyobject-for-structs">Deriving <a href="https://docs.rs/pyo3/0.25.1/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for structs</a></h4>
<p>The derivation generates code that will attempt to access the attribute  <code>my_string</code> on
the Python object, i.e. <code>obj.getattr("my_string")</code>, and call <code>extract()</code> on the attribute.</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3_ffi::c_str;

#[derive(FromPyObject)]
struct RustyStruct {
    my_string: String,
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let module = PyModule::from_code(
</span><span class="boring">            py,
</span><span class="boring">            c_str!("class Foo:
</span><span class="boring">            def __init__(self):
</span><span class="boring">                self.my_string = 'test'"),
</span><span class="boring">            c_str!(""),
</span><span class="boring">            c_str!(""),
</span><span class="boring">        )?;
</span><span class="boring">
</span><span class="boring">        let class = module.getattr("Foo")?;
</span><span class="boring">        let instance = class.call0()?;
</span><span class="boring">        let rustystruct: RustyStruct = instance.extract()?;
</span><span class="boring">        assert_eq!(rustystruct.my_string, "test");
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>By setting the <code>#[pyo3(item)]</code> attribute on the field, PyO3 will attempt to extract the value by calling the <code>get_item</code> method on the Python object.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyStruct {
    #[pyo3(item)]
    my_string: String,
}
<span class="boring">
</span><span class="boring">use pyo3::types::PyDict;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let dict = PyDict::new(py);
</span><span class="boring">        dict.set_item("my_string", "test")?;
</span><span class="boring">
</span><span class="boring">        let rustystruct: RustyStruct = dict.extract()?;
</span><span class="boring">        assert_eq!(rustystruct.my_string, "test");
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>The argument passed to <code>getattr</code> and <code>get_item</code> can also be configured:</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3_ffi::c_str;

#[derive(FromPyObject)]
struct RustyStruct {
    #[pyo3(item("key"))]
    string_in_mapping: String,
    #[pyo3(attribute("name"))]
    string_attr: String,
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let module = PyModule::from_code(
</span><span class="boring">            py,
</span><span class="boring">            c_str!("class Foo(dict):
</span><span class="boring">            def __init__(self):
</span><span class="boring">                self.name = 'test'
</span><span class="boring">                self['key'] = 'test2'"),
</span><span class="boring">            c_str!(""),
</span><span class="boring">            c_str!(""),
</span><span class="boring">        )?;
</span><span class="boring">
</span><span class="boring">        let class = module.getattr("Foo")?;
</span><span class="boring">        let instance = class.call0()?;
</span><span class="boring">        let rustystruct: RustyStruct = instance.extract()?;
</span><span class="boring">		assert_eq!(rustystruct.string_attr, "test");
</span><span class="boring">        assert_eq!(rustystruct.string_in_mapping, "test2");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>This tries to extract <code>string_attr</code> from the attribute <code>name</code> and <code>string_in_mapping</code>
from a mapping with the key <code>"key"</code>. The arguments for <code>attribute</code> are restricted to
non-empty string literals while <code>item</code> can take any valid literal that implements
<code>ToBorrowedObject</code>.</p>
<p>You can use <code>#[pyo3(from_item_all)]</code> on a struct to extract every field with <code>get_item</code> method.
In this case, you can't use <code>#[pyo3(attribute)]</code> or barely use <code>#[pyo3(item)]</code> on any field.
However, using <code>#[pyo3(item("key"))]</code> to specify the key for a field is still allowed.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
#[pyo3(from_item_all)]
struct RustyStruct {
    foo: String,
    bar: String,
    #[pyo3(item("foobar"))]
    baz: String,
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let py_dict = py.eval(pyo3::ffi::c_str!("{'foo': 'foo', 'bar': 'bar', 'foobar': 'foobar'}"), None, None)?;
</span><span class="boring">        let rustystruct: RustyStruct = py_dict.extract()?;
</span><span class="boring">		  assert_eq!(rustystruct.foo, "foo");
</span><span class="boring">        assert_eq!(rustystruct.bar, "bar");
</span><span class="boring">        assert_eq!(rustystruct.baz, "foobar");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<h4 id="deriving-frompyobject-for-tuple-structs"><a class="header" href="#deriving-frompyobject-for-tuple-structs">Deriving <a href="https://docs.rs/pyo3/0.25.1/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for tuple structs</a></h4>
<p>Tuple structs are also supported but do not allow customizing the extraction. The input is
always assumed to be a Python tuple with the same length as the Rust type, the <code>n</code>th field
is extracted from the <code>n</code>th item in the Python tuple.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyTuple(String, String);

<span class="boring">use pyo3::types::PyTuple;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let tuple = PyTuple::new(py, vec!["test", "test2"])?;
</span><span class="boring">
</span><span class="boring">        let rustytuple: RustyTuple = tuple.extract()?;
</span><span class="boring">        assert_eq!(rustytuple.0, "test");
</span><span class="boring">        assert_eq!(rustytuple.1, "test2");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>Tuple structs with a single field are treated as wrapper types which are described in the
following section. To override this behaviour and ensure that the input is in fact a tuple,
specify the struct as</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyTuple((String,));

<span class="boring">use pyo3::types::PyTuple;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let tuple = PyTuple::new(py, vec!["test"])?;
</span><span class="boring">
</span><span class="boring">        let rustytuple: RustyTuple = tuple.extract()?;
</span><span class="boring">        assert_eq!((rustytuple.0).0, "test");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<h4 id="deriving-frompyobject-for-wrapper-types"><a class="header" href="#deriving-frompyobject-for-wrapper-types">Deriving <a href="https://docs.rs/pyo3/0.25.1/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for wrapper types</a></h4>
<p>The <code>pyo3(transparent)</code> attribute can be used on structs with exactly one field. This results
in extracting directly from the input object, i.e. <code>obj.extract()</code>, rather than trying to access
an item or attribute. This behaviour is enabled per default for newtype structs and tuple-variants
with a single field.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyTransparentTupleStruct(String);

#[derive(FromPyObject)]
#[pyo3(transparent)]
struct RustyTransparentStruct {
    inner: String,
}

<span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let s = PyString::new(py, "test");
</span><span class="boring">
</span><span class="boring">        let tup: RustyTransparentTupleStruct = s.extract()?;
</span><span class="boring">        assert_eq!(tup.0, "test");
</span><span class="boring">
</span><span class="boring">        let stru: RustyTransparentStruct = s.extract()?;
</span><span class="boring">        assert_eq!(stru.inner, "test");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<h4 id="deriving-frompyobject-for-enums"><a class="header" href="#deriving-frompyobject-for-enums">Deriving <a href="https://docs.rs/pyo3/0.25.1/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for enums</a></h4>
<p>The <code>FromPyObject</code> derivation for enums generates code that tries to extract the variants in the
order of the fields. As soon as a variant can be extracted successfully, that variant is returned.
This makes it possible to extract Python union types like <code>str | int</code>.</p>
<p>The same customizations and restrictions described for struct derivations apply to enum variants,
i.e. a tuple variant assumes that the input is a Python tuple, and a struct variant defaults to
extracting fields as attributes but can be configured in the same manner. The <code>transparent</code>
attribute can be applied to single-field-variants.</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3_ffi::c_str;

#[derive(FromPyObject)]
<span class="boring">#[derive(Debug)]
</span>enum RustyEnum&lt;'py&gt; {
    Int(usize),                    // input is a positive int
    String(String),                // input is a string
    IntTuple(usize, usize),        // input is a 2-tuple with positive ints
    StringIntTuple(String, usize), // input is a 2-tuple with String and int
    Coordinates3d {
        // needs to be in front of 2d
        x: usize,
        y: usize,
        z: usize,
    },
    Coordinates2d {
        // only gets checked if the input did not have `z`
        #[pyo3(attribute("x"))]
        a: usize,
        #[pyo3(attribute("y"))]
        b: usize,
    },
    #[pyo3(transparent)]
    CatchAll(Bound&lt;'py, PyAny&gt;), // This extraction never fails
}
<span class="boring">
</span><span class="boring">use pyo3::types::{PyBytes, PyString};
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        {
</span><span class="boring">            let thing = 42_u8.into_pyobject(py)?;
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                42,
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::Int(i) =&gt; i,
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let thing = PyString::new(py, "text");
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                "text",
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::String(i) =&gt; i,
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let thing = (32_u8, 73_u8).into_pyobject(py)?;
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                (32, 73),
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::IntTuple(i, j) =&gt; (i, j),
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let thing = ("foo", 73_u8).into_pyobject(py)?;
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                (String::from("foo"), 73),
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::StringIntTuple(i, j) =&gt; (i, j),
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let module = PyModule::from_code(
</span><span class="boring">                py,
</span><span class="boring">                c_str!("class Foo(dict):
</span><span class="boring">            def __init__(self):
</span><span class="boring">                self.x = 0
</span><span class="boring">                self.y = 1
</span><span class="boring">                self.z = 2"),
</span><span class="boring">                c_str!(""),
</span><span class="boring">                c_str!(""),
</span><span class="boring">            )?;
</span><span class="boring">
</span><span class="boring">            let class = module.getattr("Foo")?;
</span><span class="boring">            let instance = class.call0()?;
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = instance.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                (0, 1, 2),
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::Coordinates3d { x, y, z } =&gt; (x, y, z),
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let module = PyModule::from_code(
</span><span class="boring">                py,
</span><span class="boring">                c_str!("class Foo(dict):
</span><span class="boring">            def __init__(self):
</span><span class="boring">                self.x = 3
</span><span class="boring">                self.y = 4"),
</span><span class="boring">                c_str!(""),
</span><span class="boring">                c_str!(""),
</span><span class="boring">            )?;
</span><span class="boring">
</span><span class="boring">            let class = module.getattr("Foo")?;
</span><span class="boring">            let instance = class.call0()?;
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = instance.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                (3, 4),
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::Coordinates2d { a, b } =&gt; (a, b),
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let thing = PyBytes::new(py, b"text");
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                b"text",
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::CatchAll(ref i) =&gt; i.downcast::&lt;PyBytes&gt;()?.as_bytes(),
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>If none of the enum variants match, a <code>PyTypeError</code> containing the names of the
tested variants is returned. The names reported in the error message can be customized
through the <code>#[pyo3(annotation = "name")]</code> attribute, e.g. to use conventional Python type
names:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
<span class="boring">#[derive(Debug)]
</span>enum RustyEnum {
    #[pyo3(transparent, annotation = "str")]
    String(String),
    #[pyo3(transparent, annotation = "int")]
    Int(isize),
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        {
</span><span class="boring">            let thing = 42_u8.into_pyobject(py)?;
</span><span class="boring">            let rust_thing: RustyEnum = thing.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                42,
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::Int(i) =&gt; i,
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let thing = "foo".into_pyobject(py)?;
</span><span class="boring">            let rust_thing: RustyEnum = thing.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                "foo",
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::String(i) =&gt; i,
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let thing = b"foo".into_pyobject(py)?;
</span><span class="boring">            let error = thing.extract::&lt;RustyEnum&gt;().unwrap_err();
</span><span class="boring">            assert!(error.is_instance_of::&lt;pyo3::exceptions::PyTypeError&gt;(py));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>If the input is neither a string nor an integer, the error message will be:
<code>"'&lt;INPUT_TYPE&gt;' cannot be converted to 'str | int'"</code>.</p>
<h4 id="derivefrompyobject-container-attributes"><a class="header" href="#derivefrompyobject-container-attributes"><code>#[derive(FromPyObject)]</code> Container Attributes</a></h4>
<ul>
<li><code>pyo3(transparent)</code>
<ul>
<li>extract the field directly from the object as <code>obj.extract()</code> instead of <code>get_item()</code> or
<code>getattr()</code></li>
<li>Newtype structs and tuple-variants are treated as transparent per default.</li>
<li>only supported for single-field structs and enum variants</li>
</ul>
</li>
<li><code>pyo3(annotation = "name")</code>
<ul>
<li>changes the name of the failed variant in the generated error message in case of failure.</li>
<li>e.g. <code>pyo3("int")</code> reports the variant's type as <code>int</code>.</li>
<li>only supported for enum variants</li>
</ul>
</li>
<li><code>pyo3(rename_all = "...")</code>
<ul>
<li>renames all attributes/item keys according to the specified renaming rule</li>
<li>Possible values are: "camelCase", "kebab-case", "lowercase", "PascalCase", "SCREAMING-KEBAB-CASE", "SCREAMING_SNAKE_CASE", "snake_case", "UPPERCASE".</li>
<li>fields with an explicit renaming via <code>attribute(...)</code>/<code>item(...)</code> are not affected</li>
</ul>
</li>
</ul>
<h4 id="derivefrompyobject-field-attributes"><a class="header" href="#derivefrompyobject-field-attributes"><code>#[derive(FromPyObject)]</code> Field Attributes</a></h4>
<ul>
<li><code>pyo3(attribute)</code>, <code>pyo3(attribute("name"))</code>
<ul>
<li>retrieve the field from an attribute, possibly with a custom name specified as an argument</li>
<li>argument must be a string-literal.</li>
</ul>
</li>
<li><code>pyo3(item)</code>, <code>pyo3(item("key"))</code>
<ul>
<li>retrieve the field from a mapping, possibly with the custom key specified as an argument.</li>
<li>can be any literal that implements <code>ToBorrowedObject</code></li>
</ul>
</li>
<li><code>pyo3(from_py_with = ...)</code>
<ul>
<li>apply a custom function to convert the field from Python the desired Rust type.</li>
<li>the argument must be the path to the function.</li>
<li>the function signature must be <code>fn(&amp;Bound&lt;PyAny&gt;) -&gt; PyResult&lt;T&gt;</code> where <code>T</code> is the Rust type of the argument.</li>
</ul>
</li>
<li><code>pyo3(default)</code>, <code>pyo3(default = ...)</code>
<ul>
<li>if the argument is set, uses the given default value.</li>
<li>in this case, the argument must be a Rust expression returning a value of the desired Rust type.</li>
<li>if the argument is not set, <a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default"><code>Default::default</code></a> is used.</li>
<li>note that the default value is only used if the field is not set.
If the field is set and the conversion function from Python to Rust fails, an exception is raised and the default value is not used.</li>
<li>this attribute is only supported on named fields.</li>
</ul>
</li>
</ul>
<p>For example, the code below applies the given conversion function on the <code>"value"</code> dict item to compute its length or fall back to the type default value (0):</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyStruct {
    #[pyo3(item("value"), default, from_py_with = Bound::&lt;'_, PyAny&gt;::len)]
    len: usize,
    #[pyo3(item)]
    other: usize,
}
<span class="boring">
</span><span class="boring">use pyo3::types::PyDict;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        // Filled case
</span><span class="boring">        let dict = PyDict::new(py);
</span><span class="boring">        dict.set_item("value", (1,)).unwrap();
</span><span class="boring">        dict.set_item("other", 1).unwrap();
</span><span class="boring">        let result = dict.extract::&lt;RustyStruct&gt;()?;
</span><span class="boring">        assert_eq!(result.len, 1);
</span><span class="boring">        assert_eq!(result.other, 1);
</span><span class="boring">
</span><span class="boring">        // Empty case
</span><span class="boring">        let dict = PyDict::new(py);
</span><span class="boring">        dict.set_item("other", 1).unwrap();
</span><span class="boring">        let result = dict.extract::&lt;RustyStruct&gt;()?;
</span><span class="boring">        assert_eq!(result.len, 0);
</span><span class="boring">        assert_eq!(result.other, 1);
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<h3 id="intopyobject"><a class="header" href="#intopyobject"><code>IntoPyObject</code></a></h3>
<p>The <a href="https://docs.rs/pyo3/0.25.1/pyo3/conversion/trait.IntoPyObject.html"><code>IntoPyObject</code></a> trait defines the to-python conversion for a Rust type. All types in PyO3 implement this trait,
as does a <code>#[pyclass]</code> which doesn't use <code>extends</code>.</p>
<p>This trait defines a single method, <code>into_pyobject()</code>, which returns a <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a> with <code>Ok</code> and <code>Err</code> types depending on the input value. For convenience, there is a companion <a href="https://docs.rs/pyo3/0.25.1/pyo3/conversion/trait.IntoPyObjectExt.html"><code>IntoPyObjectExt</code></a> trait which adds methods such as <code>into_py_any()</code> which converts the <code>Ok</code> and <code>Err</code> types to commonly used types (in the case of <code>into_py_any()</code>, <code>Py&lt;PyAny&gt;</code> and <code>PyErr</code> respectively).</p>
<p>Occasionally you may choose to implement this for custom types which are mapped to Python types
<em>without</em> having a unique python type.</p>
<h4 id="derive-macro"><a class="header" href="#derive-macro">derive macro</a></h4>
<p><code>IntoPyObject</code> can be implemented using our derive macro. Both <code>struct</code>s and <code>enum</code>s are supported.</p>
<p><code>struct</code>s will turn into a <code>PyDict</code> using the field names as keys, tuple <code>struct</code>s will turn convert
into <code>PyTuple</code> with the fields in declaration order.</p>
<pre><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">use std::hash::Hash;
</span>
// structs convert into `PyDict` with field names as keys
#[derive(IntoPyObject)]
struct Struct {
    count: usize,
    obj: Py&lt;PyAny&gt;,
}

// tuple structs convert into `PyTuple`
// lifetimes and generics are supported, the impl will be bounded by
// `K: IntoPyObject, V: IntoPyObject`
#[derive(IntoPyObject)]
struct Tuple&lt;'a, K: Hash + Eq, V&gt;(&amp;'a str, HashMap&lt;K, V&gt;);</code></pre>
<p>For structs with a single field (newtype pattern) the <code>#[pyo3(transparent)]</code> option can be used to
forward the implementation to the inner type.</p>
<pre><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>
// newtype tuple structs are implicitly `transparent`
#[derive(IntoPyObject)]
struct TransparentTuple(PyObject);

#[derive(IntoPyObject)]
#[pyo3(transparent)]
struct TransparentStruct&lt;'py&gt; {
    inner: Bound&lt;'py, PyAny&gt;, // `'py` lifetime will be used as the Python lifetime
}</code></pre>
<p>For <code>enum</code>s each variant is converted according to the rules for <code>struct</code>s above.</p>
<pre><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">use std::hash::Hash;
</span>
#[derive(IntoPyObject)]
enum Enum&lt;'a, 'py, K: Hash + Eq, V&gt; { // enums are supported and convert using the same
    TransparentTuple(PyObject),       // rules on the variants as the structs above
    #[pyo3(transparent)]
    TransparentStruct { inner: Bound&lt;'py, PyAny&gt; },
    Tuple(&amp;'a str, HashMap&lt;K, V&gt;),
    Struct { count: usize, obj: Py&lt;PyAny&gt; }
}</code></pre>
<p>Additionally <code>IntoPyObject</code> can be derived for a reference to a struct or enum using the
<code>IntoPyObjectRef</code> derive macro. All the same rules from above apply as well.</p>
<h5 id="deriveintopyobjectderiveintopyobjectref-field-attributes"><a class="header" href="#deriveintopyobjectderiveintopyobjectref-field-attributes"><code>#[derive(IntoPyObject)]</code>/<code>#[derive(IntoPyObjectRef)]</code> Field Attributes</a></h5>
<ul>
<li>
<p><code>pyo3(into_py_with = ...)</code></p>
<ul>
<li>apply a custom function to convert the field from Rust into Python.</li>
<li>the argument must be the function identifier</li>
<li>the function signature must be <code>fn(Cow&lt;'_, T&gt;, Python&lt;'py&gt;) -&gt; PyResult&lt;Bound&lt;'py, PyAny&gt;&gt;</code> where <code>T</code> is the Rust type of the argument.
<ul>
<li><code>#[derive(IntoPyObject)]</code> will invoke the function with <code>Cow::Owned</code></li>
<li><code>#[derive(IntoPyObjectRef)]</code> will invoke the function with <code>Cow::Borrowed</code></li>
</ul>
</li>
</ul>
<pre><code class="language-rust no_run"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::IntoPyObjectExt;
</span><span class="boring">use std::borrow::Cow;
</span>#[derive(Clone)]
struct NotIntoPy(usize);

#[derive(IntoPyObject, IntoPyObjectRef)]
struct MyStruct {
    #[pyo3(into_py_with = convert)]
    not_into_py: NotIntoPy,
}

/// Convert `NotIntoPy` into Python
fn convert&lt;'py&gt;(not_into_py: Cow&lt;'_, NotIntoPy&gt;, py: Python&lt;'py&gt;) -&gt; PyResult&lt;Bound&lt;'py, PyAny&gt;&gt; {
    not_into_py.0.into_bound_py_any(py)
}</code></pre>
</li>
</ul>
<h4 id="manual-implementation"><a class="header" href="#manual-implementation">manual implementation</a></h4>
<p>If the derive macro is not suitable for your use case, <code>IntoPyObject</code> can be implemented manually as
demonstrated below.</p>
<pre><code class="language-rust no_run"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[allow(dead_code)]
</span>struct MyPyObjectWrapper(PyObject);

impl&lt;'py&gt; IntoPyObject&lt;'py&gt; for MyPyObjectWrapper {
    type Target = PyAny; // the Python type
    type Output = Bound&lt;'py, Self::Target&gt;; // in most cases this will be `Bound`
    type Error = std::convert::Infallible; // the conversion error type, has to be convertible to `PyErr`

    fn into_pyobject(self, py: Python&lt;'py&gt;) -&gt; Result&lt;Self::Output, Self::Error&gt; {
        Ok(self.0.into_bound(py))
    }
}

// equivalent to former `ToPyObject` implementations
impl&lt;'a, 'py&gt; IntoPyObject&lt;'py&gt; for &amp;'a MyPyObjectWrapper {
    type Target = PyAny;
    type Output = Borrowed&lt;'a, 'py, Self::Target&gt;; // `Borrowed` can be used to optimized reference counting
    type Error = std::convert::Infallible;

    fn into_pyobject(self, py: Python&lt;'py&gt;) -&gt; Result&lt;Self::Output, Self::Error&gt; {
        Ok(self.0.bind_borrowed(py))
    }
}</code></pre>
<h4 id="boundobject-for-conversions-that-may-be-bound-or-borrowed"><a class="header" href="#boundobject-for-conversions-that-may-be-bound-or-borrowed"><code>BoundObject</code> for conversions that may be <code>Bound</code> or <code>Borrowed</code></a></h4>
<p><code>IntoPyObject::into_py_object</code> returns either <code>Bound</code> or <code>Borrowed</code> depending on the implementation for a concrete type. For example, the <code>IntoPyObject</code> implementation for <code>u32</code> produces a <code>Bound&lt;'py, PyInt&gt;</code> and the <code>bool</code> implementation produces a <code>Borrowed&lt;'py, 'py, PyBool&gt;</code>:</p>
<pre><code class="language-rust no_run">use pyo3::prelude::*;
use pyo3::IntoPyObject;
use pyo3::types::{PyBool, PyInt};

let ints: Vec&lt;u32&gt; = vec![1, 2, 3, 4];
let bools = vec![true, false, false, true];

Python::with_gil(|py| {
    let ints_as_pyint: Vec&lt;Bound&lt;'_, PyInt&gt;&gt; = ints
        .iter()
        .map(|x| Ok(x.into_pyobject(py)?))
        .collect::&lt;PyResult&lt;_&gt;&gt;()
        .unwrap();

    let bools_as_pybool: Vec&lt;Borrowed&lt;'_, '_, PyBool&gt;&gt; = bools
        .iter()
        .map(|x| Ok(x.into_pyobject(py)?))
        .collect::&lt;PyResult&lt;_&gt;&gt;()
        .unwrap();
});</code></pre>
<p>In this example if we wanted to combine <code>ints_as_pyints</code> and <code>bools_as_pybool</code> into a single <code>Vec&lt;Py&lt;PyAny&gt;&gt;</code> to return from the <code>with_gil</code> closure, we would have to manually convert the concrete types for the smart pointers and the python types.</p>
<p>Instead, we can write a function that generically converts vectors of either integers or bools into a vector of <code>Py&lt;PyAny&gt;</code> using the <a href="https://docs.rs/pyo3/0.25.1/pyo3/instance/trait.BoundObject.html"><code>BoundObject</code></a> trait:</p>
<pre><code class="language-rust no_run"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::BoundObject;
</span><span class="boring">use pyo3::IntoPyObject;
</span>
<span class="boring">let bools = vec![true, false, false, true];
</span><span class="boring">let ints = vec![1, 2, 3, 4];
</span>
fn convert_to_vec_of_pyobj&lt;'py, T&gt;(py: Python&lt;'py&gt;, the_vec: Vec&lt;T&gt;) -&gt; PyResult&lt;Vec&lt;Py&lt;PyAny&gt;&gt;&gt;
where
   T: IntoPyObject&lt;'py&gt; + Copy
{
    the_vec.iter()
        .map(|x| {
            Ok(
                // Note: the below is equivalent to `x.into_py_any()`
                // from the `IntoPyObjectExt` trait
                x.into_pyobject(py)
                .map_err(Into::into)?
                .into_any()
                .unbind()
            )
        })
        .collect()
}

let vec_of_pyobjs: Vec&lt;Py&lt;PyAny&gt;&gt; = Python::with_gil(|py| {
    let mut bools_as_pyany = convert_to_vec_of_pyobj(py, bools).unwrap();
    let mut ints_as_pyany = convert_to_vec_of_pyobj(py, ints).unwrap();
    let mut result: Vec&lt;Py&lt;PyAny&gt;&gt; = vec![];
    result.append(&amp;mut bools_as_pyany);
    result.append(&amp;mut ints_as_pyany);
    result
});</code></pre>
<p>In the example above we used <code>BoundObject::into_any</code> and <code>BoundObject::unbind</code> to manipulate the python types and smart pointers into the result type we wanted to produce from the function.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../conversions/tables.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../async-await.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../conversions/tables.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../async-await.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/tabs.js"></script>


    </div>
    </body>
</html>
